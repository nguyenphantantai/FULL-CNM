{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport axios from \"axios\";\nimport { io } from \"socket.io-client\";\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\";\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false,\n  // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false,\n  // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now()\n  }\n});\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id);\n});\nsocket.on(\"connect_error\", err => {\n  console.error(\"Socket connection error:\", err);\n});\nsocket.on(\"disconnect\", reason => {\n  console.log(\"Socket disconnected:\", reason);\n});\nsocket.on(\"error\", err => {\n  console.error(\"Socket error:\", err);\n});\nsocket.on(\"reconnect_error\", err => {\n  console.error(\"Socket reconnection error:\", err);\n});\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error;\n  console.error = (...args) => {\n    if (args[0] && typeof args[0] === \"string\" && (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))) {\n      return;\n    }\n    originalConsoleError.apply(console, args);\n  };\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  _s();\n  const navigate = useNavigate();\n\n  // State Management\n  const [user, setUser] = useState({\n    id: \"\",\n    name: \"User\",\n    avatar: \"\"\n  });\n  const [contacts, setContacts] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [selectedContact, setSelectedContact] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(socket.connected); // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [mediaFiles, setMediaFiles] = useState([]);\n  const [documents, setDocuments] = useState([]);\n  const [showMedia, setShowMedia] = useState(true);\n  const [showFiles, setShowFiles] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"chat\");\n  const [showProfileModal, setShowProfileModal] = useState(false);\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null\n  });\n  const [loading, setLoading] = useState(false);\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false);\n  const [friendEmail, setFriendEmail] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [showToast, setShowToast] = useState(false);\n  const [friendRequests, setFriendRequests] = useState([]);\n  const [recoveredContacts, setRecoveredContacts] = useState([]); // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageInputRef = useRef(null);\n  const videoInputRef = useRef(null);\n\n  // --- Utility Functions ---\n\n  const showError = useCallback(message => {\n    console.log(\"Showing Toast:\", message);\n    setError(message);\n    setShowToast(true);\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, []);\n  const apiCall = useCallback(async (method, url, data = null, token) => {\n    try {\n      console.log(`API Call: ${method.toUpperCase()} ${url}`);\n      if (data) {\n        console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data);\n      }\n      const config = {\n        method,\n        url: `${API_BASE_URL}${url}`,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n          \"If-None-Match\": \"\" // Prevent 304 responses\n        },\n        data\n      };\n      if (!(data instanceof FormData)) {\n        config.headers[\"Content-Type\"] = \"application/json\";\n      }\n      console.log(\"Using config:\", {\n        method: config.method,\n        url: config.url,\n        headers: {\n          ...config.headers,\n          Authorization: \"Bearer [HIDDEN]\"\n        }\n      });\n      const response = await axios(config);\n      console.log(`API Response ${url}:`, response.status, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error(`API Error ${url}:`, error);\n      if (error.response) {\n        console.error(\"Response status:\", error.response.status);\n        console.error(\"Response data:\", error.response.data);\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"userProfile\"); // Clear profile too\n        navigate(\"/login\");\n        // Use showError for consistency\n        showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\");\n        throw new Error(\"Phiên đăng nhập hết hạn.\"); // Throw to stop further execution\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || \"Đã xảy ra lỗi không xác định\";\n      // Don't automatically show toast here, let the calling function decide\n      // showError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [navigate, showError]); // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback(newContact => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact);\n      return;\n    }\n    console.log(\"Adding or updating contact:\", newContact);\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\");\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : [];\n      contactsArray = contactsArray.filter(c => c.id !== newContact.id);\n      contactsArray.push(newContact);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray));\n      console.log(\"Saved contact to localStorage:\", newContact.id);\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError);\n    }\n    setContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n  }, []);\n  const addOrUpdateGroup = useCallback(newGroup => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup);\n      return;\n    }\n    console.log(\"Adding or updating group:\", newGroup);\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\");\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : [];\n      groupsArray = groupsArray.filter(g => g.groupId !== newGroup.groupId);\n      groupsArray.push(newGroup);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray));\n      console.log(\"Saved group to localStorage:\", newGroup.groupId);\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError);\n    }\n    setGroups(prev => {\n      const exists = prev.some(group => group.groupId === newGroup.groupId);\n      if (exists) {\n        return prev.map(group => group.groupId === newGroup.groupId ? {\n          ...group,\n          ...newGroup\n        } : group);\n      }\n      return [...prev, newGroup];\n    });\n  }, []);\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(async token => {\n    try {\n      const response = await apiCall(\"get\", \"/api/users/profile\", null, token);\n      const userData = {\n        id: response.userId,\n        name: response.fullName || \"User\",\n        avatar: response.avatarUrl || \"\"\n      };\n      setUser(userData);\n      setProfileData({\n        fullName: response.fullName || \"\",\n        birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n        gender: response.gender || \"\",\n        avatarUrl: response.avatarUrl || null\n      });\n      // Save profile to localStorage after fetching\n      localStorage.setItem(\"userProfile\", JSON.stringify(response));\n      return response; // Return the full profile\n    } catch (error) {\n      console.error(\"Error fetching user profile:\", error);\n      showError(\"Không thể lấy thông tin người dùng: \" + error.message);\n      // No need to navigate here, apiCall handles 401\n      return null;\n    }\n  }, [apiCall, showError]);\n  const fetchMessages = useCallback(async (token, conversationId, isGroup = false) => {\n    if (!token || !conversationId) {\n      console.warn(\"fetchMessages called without token or conversationId\");\n      setMessages([]); // Clear messages if no ID\n      setMediaFiles([]);\n      setDocuments([]);\n      return;\n    }\n    setLoading(true); // Indicate loading messages\n    try {\n      let response;\n      // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n      const endpoint = `/api/messages/conversations/${conversationId}/messages`;\n      console.log(\"Fetching messages from endpoint:\", endpoint);\n      response = await apiCall(\"get\", endpoint, null, token);\n      console.log(\"Messages API response:\", response);\n      const messagesData = Array.isArray(response) ? response : response.data || [];\n      const mappedMessages = messagesData.map((msg, index) => {\n        var _msg$attachments, _msg$attachments$, _msg$attachments2, _msg$attachments$2, _msg$attachments3, _msg$attachments$3, _msg$attachments4, _msg$attachments$4, _msg$attachments5, _msg$attachments$5;\n        return {\n          id: msg.messageId || `temp-${Date.now()}-${index}`,\n          sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n          content: msg.isRecalled || msg.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\" ? msg.content : ((_msg$attachments = msg.attachments) === null || _msg$attachments === void 0 ? void 0 : (_msg$attachments$ = _msg$attachments[0]) === null || _msg$attachments$ === void 0 ? void 0 : _msg$attachments$.url) || msg.content || \"\",\n          // Ensure content exists\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          senderId: msg.senderId,\n          isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n          isVideo: msg.type === \"video\",\n          isFile: msg.type === \"file\",\n          isUnsent: msg.isRecalled || msg.isDeleted,\n          isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n          fileUrl: msg.type === \"file\" && ((_msg$attachments2 = msg.attachments) === null || _msg$attachments2 === void 0 ? void 0 : _msg$attachments2.length) > 0 ? (_msg$attachments$2 = msg.attachments[0]) === null || _msg$attachments$2 === void 0 ? void 0 : _msg$attachments$2.url : null,\n          fileName: msg.type === \"file\" && ((_msg$attachments3 = msg.attachments) === null || _msg$attachments3 === void 0 ? void 0 : _msg$attachments3.length) > 0 ? (_msg$attachments$3 = msg.attachments[0]) === null || _msg$attachments$3 === void 0 ? void 0 : _msg$attachments$3.name : null,\n          fileType: msg.type === \"file\" && ((_msg$attachments4 = msg.attachments) === null || _msg$attachments4 === void 0 ? void 0 : _msg$attachments4.length) > 0 ? (_msg$attachments$4 = msg.attachments[0]) === null || _msg$attachments$4 === void 0 ? void 0 : _msg$attachments$4.type : null,\n          duration: msg.type === \"video\" && ((_msg$attachments5 = msg.attachments) === null || _msg$attachments5 === void 0 ? void 0 : _msg$attachments5.length) > 0 ? (_msg$attachments$5 = msg.attachments[0]) === null || _msg$attachments$5 === void 0 ? void 0 : _msg$attachments$5.duration : null,\n          messageDate: new Date().toLocaleDateString() // Used for media/files list\n        };\n      }).filter(msg => msg.id); // Filter out messages without an ID\n\n      // Add system message if needed\n      if (mappedMessages.length === 0 || !mappedMessages.some(msg => msg.isSystemMessage)) {\n        const systemMessage = isGroup ? \"Chào mừng bạn đến với nhóm chat!\" : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\";\n        mappedMessages.unshift({\n          id: `system-${Date.now()}`,\n          senderId: \"system\",\n          content: systemMessage,\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          isSystemMessage: true\n        });\n      }\n      setMessages(mappedMessages);\n\n      // Update Media and Documents\n      const media = mappedMessages.filter(msg => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content).map(msg => {\n        var _msg$attachments6, _msg$attachments6$;\n        return {\n          id: msg.id,\n          type: msg.isImage ? \"image\" : \"video\",\n          url: msg.content,\n          name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n          date: msg.messageDate,\n          size: ((_msg$attachments6 = msg.attachments) === null || _msg$attachments6 === void 0 ? void 0 : (_msg$attachments6$ = _msg$attachments6[0]) === null || _msg$attachments6$ === void 0 ? void 0 : _msg$attachments6$.size) || 0,\n          // Might not be available, default to 0\n          duration: msg.duration\n        };\n      });\n      setMediaFiles(media.reverse()); // Show newest first\n\n      const files = mappedMessages.filter(msg => msg.isFile && !msg.isUnsent && msg.fileUrl).map(msg => {\n        var _msg$fileName, _msg$attachments7, _msg$attachments7$;\n        return {\n          id: msg.id,\n          type: ((_msg$fileName = msg.fileName) === null || _msg$fileName === void 0 ? void 0 : _msg$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n          url: msg.fileUrl,\n          name: msg.fileName,\n          date: msg.messageDate,\n          size: ((_msg$attachments7 = msg.attachments) === null || _msg$attachments7 === void 0 ? void 0 : (_msg$attachments7$ = _msg$attachments7[0]) === null || _msg$attachments7$ === void 0 ? void 0 : _msg$attachments7$.size) || 0\n        };\n      });\n      setDocuments(files.reverse()); // Show newest first\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      showError(\"Không thể tải tin nhắn: \" + error.message);\n      setMessages([]); // Clear messages on error\n      setMediaFiles([]);\n      setDocuments([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id to compare sender\n  );\n  const fetchContactsAndGroups = useCallback(async token => {\n    if (!token) return {\n      contacts: [],\n      groups: []\n    };\n    setLoading(true);\n    let fetchedContacts = [];\n    let fetchedGroups = [];\n    try {\n      // Fetch Friends (Contacts) from server first\n      console.log(\"Fetching friends from server...\");\n      const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token);\n      console.log(\"Friends API response:\", friendsResponse);\n\n      // Lọc ra những người bạn đã được xác nhận\n      // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n      const confirmedFriends = (friendsResponse === null || friendsResponse === void 0 ? void 0 : friendsResponse.friends) || [];\n      console.log(\"Confirmed friends:\", confirmedFriends);\n\n      // Kiểm tra xem danh sách bạn bè có hợp lệ không\n      const validFriends = confirmedFriends.filter(friend => friend && friend.userId && friend.friendshipId);\n      if (validFriends.length !== confirmedFriends.length) {\n        console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`);\n      }\n      const mappedFriends = validFriends.map(friend => {\n        var _friend$email;\n        return {\n          id: friend.userId,\n          name: friend.fullName || ((_friend$email = friend.email) === null || _friend$email === void 0 ? void 0 : _friend$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          // Trạng thái mặc định\n          friendshipId: friend.friendshipId,\n          // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null // Will be populated later\n        };\n      });\n\n      // Fetch Conversations to get conversation IDs\n      console.log(\"Fetching conversations...\");\n      const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token);\n      const conversationsMap = new Map();\n      if (convResponse && Array.isArray(convResponse)) {\n        convResponse.forEach(conv => {\n          if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n            const otherUserId = conv.participants.find(id => id !== user.id);\n            if (otherUserId) {\n              conversationsMap.set(otherUserId, conv.conversationId);\n            }\n          }\n        });\n      }\n\n      // Update conversationId for mapped friends\n      mappedFriends.forEach(friend => {\n        if (conversationsMap.has(friend.id)) {\n          friend.conversationId = conversationsMap.get(friend.id);\n        }\n      });\n\n      // Merge with existing contacts to preserve any additional data\n      const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n\n      // Create a map of existing contacts for quick lookup\n      const existingContactsMap = new Map();\n      savedContacts.forEach(contact => {\n        if (contact && contact.id) {\n          existingContactsMap.set(contact.id, contact);\n        }\n      });\n\n      // Merge server data with existing data, prioritizing server data\n      fetchedContacts = mappedFriends.map(friend => {\n        const existingContact = existingContactsMap.get(friend.id);\n        if (existingContact) {\n          // Preserve conversationId if it exists in saved contact but not in server data\n          if (!friend.conversationId && existingContact.conversationId) {\n            friend.conversationId = existingContact.conversationId;\n          }\n          return {\n            ...existingContact,\n            ...friend\n          };\n        }\n        return friend;\n      });\n\n      // Update state and localStorage\n      setContacts(fetchedContacts);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts));\n      console.log(\"Updated contacts from API:\", fetchedContacts.length);\n\n      // Fetch Groups\n      console.log(\"Fetching groups...\");\n      const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token);\n      console.log(\"Groups API response:\", groupsResponse);\n      if (groupsResponse && groupsResponse.groups) {\n        // Lọc các nhóm mà người dùng là thành viên\n        const userGroups = groupsResponse.groups.filter(group => group.members && group.members.some(member => member.userId === user.id));\n        console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`);\n        fetchedGroups = userGroups.map(group => {\n          var _group$members, _group$members2;\n          return {\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [],\n            // Lưu toàn bộ thông tin thành viên\n            memberIds: ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.map(member => member.userId)) || [],\n            // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || ((_group$members2 = group.members) === null || _group$members2 === void 0 ? void 0 : _group$members2.length) || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt\n          };\n        });\n        setGroups(fetchedGroups);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups));\n        console.log(\"Updated groups from API:\", fetchedGroups.length);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } catch (error) {\n      console.error(\"Error fetching contacts/groups:\", error);\n      showError(\"Không thể tải danh bạ/nhóm: \" + error.message);\n\n      // Fallback to localStorage only if server fetch fails\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        if (savedContacts.length > 0) {\n          console.log(\"Falling back to contacts from localStorage\");\n          setContacts(savedContacts);\n          fetchedContacts = savedContacts;\n        }\n        if (savedGroups.length > 0) {\n          console.log(\"Falling back to groups from localStorage\");\n          setGroups(savedGroups);\n          fetchedGroups = savedGroups;\n        }\n      } catch (e) {\n        console.error(\"Error reading contacts/groups from localStorage\", e);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id for conversation mapping\n  );\n  const fetchFriendRequests = useCallback(async token => {\n    if (!token) return;\n    // No need for setLoading(true) here unless it's a primary action\n    try {\n      const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token);\n      setFriendRequests(response.data || []);\n    } catch (error) {\n      console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error);\n      // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n    }\n  }, [apiCall]);\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(async (otherUserId, token) => {\n    console.log(`Creating/getting conversation with user: ${otherUserId}`);\n    if (!token || !otherUserId) {\n      throw new Error(\"Token or otherUserId missing for createOrGetConversation\");\n    }\n    try {\n      var _response$conversatio;\n      const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token);\n      if (response !== null && response !== void 0 && (_response$conversatio = response.conversation) !== null && _response$conversatio !== void 0 && _response$conversatio.conversationId) {\n        console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId);\n        return response.conversation.conversationId;\n      } else {\n        throw new Error(\"Invalid response structure from conversation API\");\n      }\n    } catch (error) {\n      console.error(\"Error in createOrGetConversation:\", error);\n      if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n        throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\");\n      }\n      throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`); // Rethrow with context\n    }\n  }, [apiCall]);\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(async contactOrGroup => {\n    if (!contactOrGroup || contactOrGroup.id === (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id)) {\n      console.log(\"Selection unchanged or invalid.\");\n      return; // Avoid re-selecting the same contact/group\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      navigate(\"/login\");\n      return;\n    }\n    console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id);\n\n    // Leave previous room\n    if (selectedContact) {\n      const roomToLeave = selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId;\n      if (roomToLeave) {\n        const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\";\n        socket.emit(eventName, roomToLeave);\n        console.log(`Left ${selectedContact.type} room:`, roomToLeave);\n      }\n    }\n\n    // Clear previous state\n    setMessages([]);\n    setMediaFiles([]);\n    setDocuments([]);\n    setSelectedContact(contactOrGroup); // Set selected contact immediately for UI update\n\n    try {\n      setLoading(true); // Show loading for message fetch\n\n      if (contactOrGroup.type === \"group\") {\n        const groupId = contactOrGroup.groupId;\n        // Sử dụng conversationId từ group object\n        const conversationId = contactOrGroup.conversationId || groupId;\n        socket.emit(\"join_group\", groupId);\n        console.log(\"Joined group room:\", groupId);\n        console.log(\"Using conversationId for group:\", conversationId);\n        await fetchMessages(token, conversationId, true);\n      } else {\n        // Handle individual contact\n        let conversationId = contactOrGroup.conversationId;\n\n        // If conversationId is missing, try to fetch/create it\n        if (!conversationId) {\n          console.log(\"Conversation ID missing, attempting to fetch/create...\");\n          try {\n            conversationId = await createOrGetConversation(contactOrGroup.id, token);\n            // Update the contact in the list and the selected contact state\n            const updatedContact = {\n              ...contactOrGroup,\n              conversationId\n            };\n            setSelectedContact(updatedContact); // Update selected state with new ID\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? updatedContact : c));\n            // Optionally save updated contacts list to localStorage\n            const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n            const updatedContactsList = currentContacts.map(c => c.id === contactOrGroup.id ? updatedContact : c);\n            localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList));\n          } catch (error) {\n            showError(error.message); // Show error from createOrGetConversation\n            setSelectedContact(null); // Deselect if conversation fails\n            setLoading(false);\n            return; // Stop execution if conversation fails\n          }\n        }\n        if (conversationId) {\n          socket.emit(\"join_conversation\", conversationId);\n          console.log(\"Joined conversation room:\", conversationId);\n          await fetchMessages(token, conversationId, false);\n\n          // Mark conversation as read with proper request body\n          try {\n            await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, {\n              read: true\n            }, token);\n\n            // Update contacts list to remove unread badge\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? {\n              ...c,\n              unreadCount: 0\n            } : c));\n          } catch (readError) {\n            console.error(\"Error marking conversation as read:\", readError);\n            // Don't show error to user since this is a non-critical operation\n          }\n        } else {\n          // This case should ideally not be reached if createOrGetConversation throws errors\n          showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\");\n          setSelectedContact(null);\n        }\n      }\n    } catch (error) {\n      // Catch errors from fetchMessages or socket emits\n      console.error(\"Error in handleContactSelect processing:\", error);\n      showError(`Lỗi khi chọn liên hệ: ${error.message}`);\n      setSelectedContact(null); // Deselect on error\n    } finally {\n      setLoading(false); // Ensure loading is turned off\n    }\n  }, [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall]);\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(async e => {\n    e.preventDefault();\n    if (!newMessage.trim() || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n    const tempMessageId = `temp-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: newMessage,\n      time: messageTime,\n      senderId: user.id,\n      isSending: true // Indicate sending state\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    const messageToSend = newMessage; // Store message before clearing\n    setNewMessage(\"\"); // Clear input immediately\n    scrollToBottom(); // Scroll after adding optimistic message\n\n    try {\n      let response;\n      let messageDataForSocket;\n      if (selectedContact.type === \"group\") {\n        var _selectedContact$memb;\n        const groupId = selectedContact.groupId;\n        console.log(\"Attempting to send group message:\", {\n          groupId,\n          messageContent: messageToSend,\n          selectedContact\n        });\n        if (!groupId) {\n          throw new Error(\"GroupId is missing\");\n        }\n\n        // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n        if (!((_selectedContact$memb = selectedContact.memberIds) !== null && _selectedContact$memb !== void 0 && _selectedContact$memb.includes(user.id))) {\n          console.error(\"User not in group members:\", {\n            userId: user.id,\n            memberIds: selectedContact.memberIds,\n            members: selectedContact.members\n          });\n          throw new Error(\"Bạn không phải là thành viên của nhóm này\");\n        }\n        try {\n          response = await apiCall(\"post\", `/api/groups/${groupId}/messages`, {\n            content: messageToSend\n          }, token);\n          console.log(\"Group message API response:\", response);\n          if (!response) {\n            throw new Error(\"No response from server\");\n          }\n          if (!response.messageData) {\n            console.error(\"Invalid response structure:\", response);\n            throw new Error(\"Invalid response structure from server\");\n          }\n          const messageData = response.messageData;\n          messageDataForSocket = {\n            messageId: messageData.messageId,\n            groupId: groupId,\n            senderId: user.id,\n            senderName: user.name,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: messageData.createdAt || new Date().toISOString()\n          };\n          console.log(\"Emitting socket event with data:\", messageDataForSocket);\n          socket.emit(\"group_message\", messageDataForSocket);\n\n          // Update optimistic message with real ID and remove sending state\n          setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n            ...msg,\n            id: messageData.messageId,\n            isSending: false,\n            time: new Date(messageData.createdAt).toLocaleTimeString([], {\n              hour: \"2-digit\",\n              minute: \"2-digit\"\n            })\n          } : msg));\n        } catch (error) {\n          var _error$response3, _error$response4;\n          console.error(\"Error details:\", {\n            error,\n            groupId,\n            selectedContact,\n            user: {\n              id: user.id,\n              name: user.name\n            }\n          });\n          if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n            throw new Error(\"Không tìm thấy nhóm chat\");\n          } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403) {\n            throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\");\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        var _response$messageData, _response$messageData2;\n        // Handle individual contact message sending\n        const conversationId = selectedContact.conversationId;\n        if (!conversationId) {\n          throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\");\n        }\n        response = await apiCall(\"post\", \"/api/messages/send/text\", {\n          conversationId: conversationId,\n          content: messageToSend,\n          tempMessageId: tempMessageId // Add tempMessageId to help match response\n        }, token);\n        messageDataForSocket = {\n          messageId: ((_response$messageData = response.messageData) === null || _response$messageData === void 0 ? void 0 : _response$messageData.messageId) || response.messageId,\n          tempMessageId: tempMessageId,\n          // Include tempMessageId in socket event\n          conversationId: conversationId,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.id,\n          content: messageToSend,\n          type: \"text\",\n          createdAt: ((_response$messageData2 = response.messageData) === null || _response$messageData2 === void 0 ? void 0 : _response$messageData2.createdAt) || new Date().toISOString(),\n          time: messageTime // Include original time for matching\n        };\n        socket.emit(\"new_message\", messageDataForSocket);\n      }\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      showError(\"Không thể gửi tin nhắn: \" + error.message);\n      // Remove or mark optimistic message as failed\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n    }\n  }, [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(async (file, fileType = \"file\") => {\n    // fileType can be 'file', 'image', 'video'\n    if (!file || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n\n    // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`);\n      return;\n    }\n    if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n      showError(\"Chỉ chấp nhận file hình ảnh.\");\n      return;\n    }\n    if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n      showError(\"Chỉ chấp nhận file video.\");\n      return;\n    }\n\n    // Video duration check\n    let videoDuration = null;\n    if (fileType === \"video\") {\n      try {\n        const duration = await getVideoDuration(file);\n        if (duration > 90) {\n          showError(\"Video không được dài quá 90 giây.\");\n          return;\n        }\n        videoDuration = Math.round(duration);\n      } catch (err) {\n        showError(\"Không thể đọc thông tin video.\");\n        return;\n      }\n    }\n    const tempMessageId = `temp-file-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const tempUrl = URL.createObjectURL(file); // For optimistic UI\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: fileType === \"text\" ? file.name : tempUrl,\n      // Use tempUrl for image/video\n      time: messageTime,\n      senderId: user.id,\n      isSending: true,\n      isFile: fileType === \"file\",\n      isImage: fileType === \"image\",\n      isVideo: fileType === \"video\",\n      fileName: file.name,\n      fileType: file.type,\n      duration: videoDuration\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    scrollToBottom();\n    const formData = new FormData();\n    let apiUrl = \"\";\n    let apiKey = \"\"; // Key for the file in FormData\n\n    if (selectedContact.type === \"group\") {\n      const groupId = selectedContact.groupId;\n      formData.append(\"groupId\", groupId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = `/api/groups/${groupId}/images`;\n          apiKey = \"image\"; // Match backend key\n          break;\n        case \"video\":\n          apiUrl = `/api/groups/${groupId}/videos`;\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = `/api/groups/${groupId}/files`;\n          apiKey = \"file\";\n          break;\n      }\n    } else {\n      const conversationId = selectedContact.conversationId;\n      if (!conversationId) {\n        showError(\"Không tìm thấy cuộc trò chuyện để gửi file\");\n        URL.revokeObjectURL(tempUrl);\n        setMessages(prev => prev.filter(msg => msg.id !== tempMessageId)); // Remove optimistic msg\n        return;\n      }\n      formData.append(\"conversationId\", conversationId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = \"/api/messages/send/image\";\n          apiKey = \"images\"; // Match backend key (plural for this endpoint)\n          break;\n        case \"video\":\n          apiUrl = \"/api/messages/send/video\";\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = \"/api/messages/send/file\";\n          apiKey = \"file\";\n          break;\n      }\n    }\n    formData.append(apiKey, file);\n    try {\n      var _messageData$attachme;\n      const response = await apiCall(\"post\", apiUrl, formData, token);\n      const messageData = response.messageData || response; // Adjust based on API response structure\n      const attachment = (_messageData$attachme = messageData.attachments) === null || _messageData$attachme === void 0 ? void 0 : _messageData$attachme[0];\n      if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n        throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\");\n      }\n\n      // Update optimistic message\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        id: messageData.messageId,\n        content: attachment.url,\n        // Use final URL\n        fileUrl: fileType === \"file\" ? attachment.url : null,\n        isSending: false,\n        time: new Date(messageData.createdAt).toLocaleTimeString([], {\n          hour: \"2-digit\",\n          minute: \"2-digit\"\n        })\n      } : msg));\n\n      // Update media/documents list\n      const newItem = {\n        id: messageData.messageId,\n        type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n        url: attachment.url,\n        name: attachment.name || file.name,\n        date: new Date(messageData.createdAt).toLocaleDateString(),\n        size: attachment.size || file.size,\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      if (fileType === \"image\" || fileType === \"video\") {\n        setMediaFiles(prev => [newItem, ...prev]); // Add to beginning (newest)\n      } else {\n        setDocuments(prev => [newItem, ...prev]);\n      }\n\n      // Emit socket event\n      const socketEventData = {\n        messageId: messageData.messageId,\n        conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n        groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n        senderId: user.id,\n        senderName: user.name,\n        receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n        type: fileType,\n        // 'file', 'image', 'video'\n        content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null,\n        // Content might be null for media\n        attachments: messageData.attachments,\n        createdAt: messageData.createdAt || new Date().toISOString(),\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\";\n      socket.emit(socketEventName, socketEventData);\n      URL.revokeObjectURL(tempUrl); // Clean up temp URL\n    } catch (error) {\n      console.error(`Error sending ${fileType}:`, error);\n      showError(`Không thể gửi ${fileType}: ${error.message}`);\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n      URL.revokeObjectURL(tempUrl);\n    }\n  }, [isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n  const getVideoDuration = file => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\");\n      video.preload = \"metadata\";\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src);\n        resolve(video.duration);\n      };\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src);\n        reject(new Error(\"Không thể tải metadata video\"));\n      };\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback(emoji => {\n    setNewMessage(prev => prev + emoji);\n    setShowEmojiPicker(false);\n  }, []);\n  const handleMessageAction = useCallback(async (messageId, action) => {\n    if (action === \"delete\") {\n      const token = localStorage.getItem(\"token\");\n      if (!token || !selectedContact) return;\n\n      // Optimistic UI update\n      const originalMessages = [...messages];\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        content: \"Đang xóa...\",\n        isUnsent: true,\n        isDeleting: true\n      } : msg));\n      try {\n        if (selectedContact.type === \"group\") {\n          await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token);\n        } else {\n          await apiCall(\"delete\", `/api/messages/${messageId}`, null, token);\n        }\n\n        // Confirm deletion in UI\n        setMessages(prev => prev.map(msg => msg.id === messageId ? {\n          ...msg,\n          content: \"Tin nhắn đã bị xóa\",\n          isDeleting: false\n        } : msg));\n\n        // Remove from media/documents lists\n        setMediaFiles(prev => prev.filter(media => media.id !== messageId));\n        setDocuments(prev => prev.filter(doc => doc.id !== messageId));\n\n        // TODO: Emit socket event for deletion if needed by backend/other clients\n      } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        showError(\"Không thể xóa tin nhắn: \" + error.message);\n        // Revert optimistic update on error\n        setMessages(originalMessages);\n      }\n    }\n    // Handle other actions like 'recall' if implemented\n  }, [apiCall, selectedContact, showError, messages] // Include messages in dependency array\n  );\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true);\n    setShowFiles(false);\n  }, []);\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false);\n    setShowFiles(true);\n  }, []);\n  const handleTabChange = useCallback(tab => {\n    setActiveTab(tab);\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchFriendRequests(token);\n      }\n    }\n  }, [fetchFriendRequests]); // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null\n    });\n    setShowProfileModal(true);\n  }, [user.name, user.avatar]); // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false);\n  }, []);\n  const handleAvatarChange = useCallback(async file => {\n    // File validation\n    if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n      showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const formData = new FormData();\n    formData.append(\"avatar\", file);\n    try {\n      setLoading(true); // Indicate loading\n      const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token);\n      // Update state optimistically/realistically\n      setProfileData(prev => ({\n        ...prev,\n        avatarUrl: response.avatarUrl\n      }));\n      setUser(prev => ({\n        ...prev,\n        avatar: response.avatarUrl\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.avatarUrl = response.avatarUrl;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật ảnh đại diện thành công!\");\n    } catch (error) {\n      showError(\"Không thể tải avatar: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError]);\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    try {\n      setLoading(true);\n      const response = await apiCall(\"put\", \"/api/users/profile\", {\n        fullName: profileData.fullName,\n        // Ensure birthdate is sent correctly or omitted if empty\n        birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n        gender: profileData.gender || undefined // Send undefined if empty to potentially clear it\n      }, token);\n      // Update user state\n      setUser(prev => ({\n        ...prev,\n        name: response.fullName || prev.name\n        // Avatar might not be in this response, keep existing one\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.fullName = response.fullName;\n      userProfile.birthdate = response.birthdate;\n      userProfile.gender = response.gender;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật hồ sơ thành công!\");\n      handleCloseProfileModal();\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal]);\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true);\n  }, []);\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false);\n    setFriendEmail(\"\"); // Reset email field\n  }, []);\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\");\n      return;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      var _searchResult$data;\n      // Search user first to get ID\n      const searchResult = await apiCall(\"get\", `/api/users/search?query=${encodeURIComponent(friendEmail)}`, null, token);\n      if (!(searchResult !== null && searchResult !== void 0 && (_searchResult$data = searchResult.data) !== null && _searchResult$data !== void 0 && _searchResult$data.length)) {\n        throw new Error(\"Không tìm thấy người dùng với email này\");\n      }\n      const receiverId = searchResult.data[0].userId;\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\");\n      }\n\n      // Check if already friends\n      if (contacts.some(c => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\");\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", {\n        receiverId,\n        message: `Kết bạn từ ${user.name}`\n      }, token);\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`);\n      handleCloseAddFriendModal();\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`);\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`);\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`);\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`);\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false);\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts]);\n  const handleRespondToFriendRequest = useCallback(async (requestId, action) => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const request = friendRequests.find(req => req.requestId === requestId);\n    if (!request) return;\n    setLoading(true); // Indicate processing\n    // Optimistically remove from list\n    setFriendRequests(prev => prev.filter(req => req.requestId !== requestId));\n    try {\n      const response = await apiCall(\"post\", \"/api/friends/requests/respond\", {\n        requestId,\n        action\n      }, token);\n      console.log(\"Friend request response:\", response);\n      if (action === \"accept\") {\n        var _response$conversatio2, _senderInfo$email;\n        showError(\"Đã chấp nhận lời mời kết bạn\");\n        const senderInfo = request.sender;\n        if (!senderInfo || !senderInfo.userId) {\n          throw new Error(\"Thông tin người gửi không hợp lệ\");\n        }\n\n        // Get conversation ID (might be in response or need creation)\n        let conversationId = (_response$conversatio2 = response.conversation) === null || _response$conversatio2 === void 0 ? void 0 : _response$conversatio2.conversationId;\n        if (!conversationId) {\n          console.log(\"No conversationId in response, creating/getting...\");\n          conversationId = await createOrGetConversation(senderInfo.userId, token);\n        }\n        if (!conversationId) {\n          throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\");\n        }\n\n        // Create new contact object\n        const newContact = {\n          id: senderInfo.userId,\n          name: senderInfo.fullName || ((_senderInfo$email = senderInfo.email) === null || _senderInfo$email === void 0 ? void 0 : _senderInfo$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: senderInfo.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          conversationId: conversationId\n        };\n        addOrUpdateContact(newContact); // Add/update contact list and localStorage\n\n        // Optionally select the new contact immediately\n        // handleContactSelect(newContact);\n\n        // Emit notification to the sender via socket\n        if (socket.connected) {\n          socket.emit(\"friend_request_accepted_notify\", {\n            accepter: {\n              userId: user.id,\n              fullName: user.name,\n              avatarUrl: user.avatar\n            },\n            senderId: senderInfo.userId,\n            // Target the sender\n            conversationId: conversationId\n          });\n          // Also tell sender to refresh their list\n          socket.emit(\"refresh_contacts_notify\", {\n            targetUserId: senderInfo.userId\n          });\n          console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\");\n        }\n      } else {\n        showError(\"Đã từ chối lời mời kết bạn\");\n        // Optionally notify sender of rejection via socket\n      }\n    } catch (error) {\n      console.error(\"Error responding to friend request:\", error);\n      showError(\"Không thể phản hồi lời mời: \" + error.message);\n      // Revert optimistic removal on error\n      setFriendRequests(prev => [...prev, request]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleRemoveFriend = useCallback(async friendId => {\n    if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    console.log(`Attempting to remove friend with ID: ${friendId}`);\n    setLoading(true);\n\n    // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n    const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\");\n    if (!contactToRemove) {\n      showError(\"Không tìm thấy người dùng trong danh sách bạn bè\");\n      setLoading(false);\n      return;\n    }\n\n    // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n    const currentContacts = [...contacts];\n    try {\n      // Cập nhật UI trước khi gọi API (optimistic update)\n      setContacts(prev => prev.filter(contact => contact.id !== friendId || contact.type !== \"contact\"));\n\n      // Cập nhật localStorage\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const updatedContacts = savedContacts.filter(c => c.id !== friendId || c.type !== \"contact\");\n        localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts));\n      } catch (e) {\n        console.error(\"Error updating localStorage after friend removal\", e);\n      }\n\n      // Bỏ chọn nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === friendId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n\n      // Gọi API để xóa bạn bè\n      try {\n        console.log(`Calling API to remove friend: ${friendId}`);\n        const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token);\n        console.log(\"Friend removal API response:\", response);\n        showError(\"Đã xóa bạn bè thành công\");\n\n        // Thông báo cho người bạn bị xóa qua socket\n        if (socket && socket.connected) {\n          socket.emit(\"friend_removed_notify\", {\n            removerId: user.id,\n            removedUserId: friendId\n          });\n          console.log(\"Emitted friend_removed_notify\");\n\n          // Thông báo cập nhật danh sách bạn bè\n          socket.emit(\"friend_list_updated\");\n        }\n\n        // Cập nhật lại danh sách bạn bè từ server\n        fetchContactsAndGroups(token);\n      } catch (apiError) {\n        console.error(\"API error removing friend:\", apiError);\n\n        // Kiểm tra lỗi cụ thể\n        if (apiError.response && apiError.response.status === 404) {\n          // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n          showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\");\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token);\n        } else {\n          // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n          showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"));\n          // Khôi phục lại danh sách bạn bè\n          setContacts(currentContacts);\n\n          // Khôi phục localStorage\n          try {\n            localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n          } catch (e) {\n            console.error(\"Error restoring localStorage\", e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in handleRemoveFriend:\", error);\n      showError(\"Không thể xóa bạn bè: \" + error.message);\n\n      // Khôi phục lại danh sách bạn bè\n      setContacts(currentContacts);\n\n      // Khôi phục localStorage\n      try {\n        localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n      } catch (e) {\n        console.error(\"Error restoring localStorage\", e);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups]);\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true);\n  }, []);\n  const handleGroupCreated = useCallback(newGroupData => {\n    var _newGroupData$members;\n    console.log(\"Group created data:\", newGroupData);\n    const groupObject = {\n      groupId: newGroupData.groupId,\n      id: newGroupData.groupId,\n      // Add id for consistency\n      name: newGroupData.name,\n      avatar: newGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: newGroupData.adminId,\n      memberCount: ((_newGroupData$members = newGroupData.members) === null || _newGroupData$members === void 0 ? void 0 : _newGroupData$members.length) || 1,\n      // At least admin is a member\n      conversationId: newGroupData.conversationId || newGroupData.groupId,\n      createdAt: newGroupData.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    setShowCreateGroupModal(false);\n    showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`);\n    // Automatically select the new group\n    handleContactSelect(groupObject);\n  }, [addOrUpdateGroup, showError, handleContactSelect]);\n  const handleGroupInfo = useCallback(group => {\n    // Fetch full group details if necessary before showing modal\n    setSelectedGroup(group); // Pass the basic group info for now\n    setShowGroupInfoModal(true);\n    // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n  }, [] // No dependencies needed to just show the modal\n  );\n  const handleGroupUpdated = useCallback(updatedGroupData => {\n    var _updatedGroupData$mem;\n    console.log(\"Group updated data:\", updatedGroupData);\n    // Ensure the data structure matches what addOrUpdateGroup expects\n    const groupObject = {\n      groupId: updatedGroupData.groupId,\n      id: updatedGroupData.groupId,\n      name: updatedGroupData.name,\n      avatar: updatedGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: updatedGroupData.adminId,\n      memberCount: updatedGroupData.memberCount || ((_updatedGroupData$mem = updatedGroupData.members) === null || _updatedGroupData$mem === void 0 ? void 0 : _updatedGroupData$mem.length) || 0,\n      conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n      createdAt: updatedGroupData.createdAt\n      // Include other relevant fields if needed\n    };\n    addOrUpdateGroup(groupObject);\n    // Update selected contact if it's the one being edited\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupObject.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    setShowGroupInfoModal(false); // Close modal on success\n    showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleLeaveGroup = useCallback(async groupId => {\n    console.log(\"Leaving group:\", groupId);\n    if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      // Gọi API để rời nhóm\n      const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token);\n      console.log(\"Leave group API response:\", response);\n\n      // Cập nhật UI sau khi API thành công\n      setGroups(prev => prev.filter(group => group.groupId !== groupId));\n\n      // Cập nhật localStorage\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after leaving group\", e);\n      }\n\n      // Bỏ chọn nhóm nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n      setShowGroupInfoModal(false); // Đóng modal\n      showError(\"Bạn đã rời khỏi nhóm thành công\");\n\n      // Thông báo qua socket nếu cần\n      if (socket.connected) {\n        socket.emit(\"left_group\", {\n          groupId\n        });\n      }\n    } catch (error) {\n      console.error(\"Error leaving group:\", error);\n      showError(\"Không thể rời khỏi nhóm: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedContact, showError, apiCall]);\n  const handleDeleteGroup = useCallback(groupId => {\n    console.log(\"Deleting group:\", groupId);\n    setGroups(prev => prev.filter(group => group.groupId !== groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after deleting group\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    setShowGroupInfoModal(false); // Close modal\n    showError(\"Đã xóa nhóm thành công\");\n    // API call to delete group should be handled within GroupInfoModal or here before state update\n  }, [selectedContact, showError]);\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      navigate(\"/login\");\n      return;\n    }\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    let socketInitialized = false;\n    const initializeApp = async () => {\n      try {\n        setLoading(true);\n        const userProfile = await fetchUserProfile(token);\n        if (!userProfile || !isMounted) return; // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token);\n        if (!isMounted) return;\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token);\n        if (!isMounted) return;\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\");\n\n          // Set socket auth and query params\n          socket.auth = {\n            token\n          };\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now()\n          };\n\n          // Connect the socket\n          socket.connect();\n          socketInitialized = true;\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\");\n      socket.off(\"reconnect\");\n      socket.off(\"friend_request\");\n      socket.off(\"new_message\");\n      socket.off(\"receive_message\");\n      socket.off(\"group_message\");\n      socket.off(\"friend_request_accepted\");\n      socket.off(\"friend_removed\");\n      socket.off(\"refresh_contacts\");\n      socket.off(\"notification\");\n      socket.off(\"group_created\");\n      socket.off(\"group_updated\");\n      socket.off(\"group_deleted\");\n      socket.off(\"member_added\");\n      socket.off(\"member_removed\");\n    };\n  }, [navigate]); // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback(data => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || !data.messageId && !data.id) {\n      console.error(\"Invalid message data received:\", data);\n      return;\n    }\n    const messageTime = data.createdAt ? new Date(data.createdAt).toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }) : new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString();\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type,\n      selectedContactGroupId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.groupId,\n      selectedContactConversationId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.conversationId\n    });\n    const isCurrentChat = (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\" && selectedContact.groupId === data.groupId || (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\" && selectedContact.conversationId === data.conversationId;\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    if (isCurrentChat) {\n      var _data$attachments, _data$attachments$, _data$attachments2, _data$attachments2$, _data$attachments3, _data$attachments3$, _data$attachments4, _data$attachments4$, _data$attachments5, _data$attachments5$;\n      const newMessage = {\n        id: data.messageId || data.id,\n        sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n        content: data.isRecalled || data.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\" ? data.content : ((_data$attachments = data.attachments) === null || _data$attachments === void 0 ? void 0 : (_data$attachments$ = _data$attachments[0]) === null || _data$attachments$ === void 0 ? void 0 : _data$attachments$.url) || data.content || \"\",\n        time: messageTime,\n        senderId: data.senderId,\n        isImage: data.type === \"image\" || data.type === \"imageGroup\",\n        isVideo: data.type === \"video\",\n        isFile: data.type === \"file\",\n        isUnsent: data.isRecalled || data.isDeleted,\n        isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n        fileUrl: data.type === \"file\" ? (_data$attachments2 = data.attachments) === null || _data$attachments2 === void 0 ? void 0 : (_data$attachments2$ = _data$attachments2[0]) === null || _data$attachments2$ === void 0 ? void 0 : _data$attachments2$.url : null,\n        fileName: data.type === \"file\" ? (_data$attachments3 = data.attachments) === null || _data$attachments3 === void 0 ? void 0 : (_data$attachments3$ = _data$attachments3[0]) === null || _data$attachments3$ === void 0 ? void 0 : _data$attachments3$.name : null,\n        fileType: data.type === \"file\" ? (_data$attachments4 = data.attachments) === null || _data$attachments4 === void 0 ? void 0 : (_data$attachments4$ = _data$attachments4[0]) === null || _data$attachments4$ === void 0 ? void 0 : _data$attachments4$.type : null,\n        duration: data.type === \"video\" ? ((_data$attachments5 = data.attachments) === null || _data$attachments5 === void 0 ? void 0 : (_data$attachments5$ = _data$attachments5[0]) === null || _data$attachments5$ === void 0 ? void 0 : _data$attachments5$.duration) || data.duration : null,\n        messageDate: messageDate\n      };\n      console.log(\"Created new message object:\", newMessage); // Log tin nhắn mới được tạo\n\n      // Check if message with this ID already exists to prevent duplicates\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        console.log(\"Message exists check:\", {\n          messageId: newMessage.id,\n          exists\n        }); // Log kiểm tra tin nhắn trùng lặp\n        if (exists) {\n          console.log(\"Message already exists in state, skipping addition:\", newMessage.id);\n          return prev;\n        }\n        console.log(\"Adding new message from socket to state:\", newMessage.id);\n        return [...prev, newMessage];\n      });\n\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles(prev => {\n          var _data$attachments6, _data$attachments6$;\n          return [{\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: ((_data$attachments6 = data.attachments) === null || _data$attachments6 === void 0 ? void 0 : (_data$attachments6$ = _data$attachments6[0]) === null || _data$attachments6$ === void 0 ? void 0 : _data$attachments6$.size) || 0,\n            duration: newMessage.duration\n          }, ...prev // Add to beginning\n          ];\n        });\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments(prev => {\n          var _newMessage$fileName, _data$attachments7, _data$attachments7$;\n          return [{\n            id: newMessage.id,\n            type: ((_newMessage$fileName = newMessage.fileName) === null || _newMessage$fileName === void 0 ? void 0 : _newMessage$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: ((_data$attachments7 = data.attachments) === null || _data$attachments7 === void 0 ? void 0 : (_data$attachments7$ = _data$attachments7[0]) === null || _data$attachments7$ === void 0 ? void 0 : _data$attachments7$.size) || 0\n          }, ...prev // Add to beginning\n          ];\n        });\n      }\n    } else {\n      var _data$content, _data$content2;\n      // Notification for message in other chat\n      let senderName = \"Người dùng\";\n      let contactId = data.senderId; // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find(g => g.groupId === data.groupId);\n        senderName = `${data.senderName || \"Ai đó\"} (${(group === null || group === void 0 ? void 0 : group.name) || \"Nhóm\"})`;\n      } else {\n        const contact = contacts.find(c => c.id === data.senderId); // Tìm contact dựa trên senderId\n        senderName = (contact === null || contact === void 0 ? void 0 : contact.name) || data.senderName || \"Ai đó\";\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n      const preview = data.type === \"text\" ? ((_data$content = data.content) === null || _data$content === void 0 ? void 0 : _data$content.substring(0, 30)) + (((_data$content2 = data.content) === null || _data$content2 === void 0 ? void 0 : _data$content2.length) > 30 ? \"...\" : \"\") : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`;\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`);\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview,\n              // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      var _contacts$find, _groups$find;\n      const contactName = data.senderName || \"Người dùng\";\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: ((_contacts$find = contacts.find(c => c.id === data.senderId)) === null || _contacts$find === void 0 ? void 0 : _contacts$find.avatar) || ((_groups$find = groups.find(g => g.groupId === data.groupId)) === null || _groups$find === void 0 ? void 0 : _groups$find.avatar) || \"/favicon.ico\" // Optional icon\n      });\n    }\n  }, [user.id, contacts, groups, selectedContact, showError]);\n  const handleFriendRequest = useCallback(data => {\n    if (!data || !data.requestId || !data.sender) return;\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab]);\n  const handleFriendRequestAccepted = useCallback(data => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\");\n      return;\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleFriendRemoved = useCallback(data => {\n    if (!data || !data.removerId) return;\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError]);\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\");\n    if (token) {\n      fetchContactsAndGroups(token);\n    }\n  }, [fetchContactsAndGroups]);\n  const handleSocketGroupCreated = useCallback(data => {\n    var _group$members3;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_created event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: ((_group$members3 = group.members) === null || _group$members3 === void 0 ? void 0 : _group$members3.length) || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`);\n  }, [addOrUpdateGroup, showError]);\n  const handleSocketGroupUpdated = useCallback(data => {\n    var _group$members4;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_updated event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members4 = group.members) === null || _group$members4 === void 0 ? void 0 : _group$members4.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleGroupDeleted = useCallback(data => {\n    var _groups$find2;\n    if (!(data !== null && data !== void 0 && data.groupId)) return;\n    console.log(\"Received group_deleted event:\", data.groupId);\n    const groupName = ((_groups$find2 = groups.find(g => g.groupId === data.groupId)) === null || _groups$find2 === void 0 ? void 0 : _groups$find2.name) || \"Một nhóm\";\n    setGroups(prev => prev.filter(group => group.groupId !== data.groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== data.groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after group delete\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === data.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`);\n  }, [groups, selectedContact, showError]);\n  const handleMemberAdded = useCallback(data => {\n    var _group$members5;\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.member) || !(data !== null && data !== void 0 && data.addedBy)) return;\n    console.log(\"Received member_added event:\", data);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members5 = group.members) === null || _group$members5 === void 0 ? void 0 : _group$members5.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleMemberRemoved = useCallback(data => {\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.memberId) || !(data !== null && data !== void 0 && data.removedBy)) return;\n    console.log(\"Received member_removed event:\", data);\n    const group = data.group;\n    const groupId = group.groupId;\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`);\n      setGroups(prev => prev.filter(g => g.groupId !== groupId));\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after being removed from group\", e);\n      }\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n    } else {\n      var _group$members6, _data$member;\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || ((_group$members6 = group.members) === null || _group$members6 === void 0 ? void 0 : _group$members6.length) || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt\n      };\n      addOrUpdateGroup(groupObject);\n      const memberName = ((_data$member = data.member) === null || _data$member === void 0 ? void 0 : _data$member.fullName) || \"một thành viên\";\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`);\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(groupObject);\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleNotification = useCallback(data => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data);\n      return;\n    }\n    if (data.type === \"success\") {\n      showError(data.message);\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\");\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\");\n    } else {\n      showError(data.message);\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchContactsAndGroups(token);\n      }\n    }\n  }, [showError, fetchContactsAndGroups]);\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true;\n    const handleConnect = () => {\n      if (!isMounted) return;\n      console.log(\"Socket re-connected inside hook.\");\n      setIsConnected(true);\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId);\n      }\n    };\n\n    // Add handler for message_sent event\n    const handleMessageSent = data => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data);\n        return;\n      }\n      console.log(\"Received message_sent_success event:\", data);\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n        // Match by tempMessageId if available\n        data.tempMessageId && msg.id === data.tempMessageId ||\n        // Or match by conversationId and content if tempMessageId not available\n        data.conversationId && msg.conversationId === data.conversationId && msg.content === data.content)) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          });\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          };\n        }\n        return msg;\n      }));\n    };\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect);\n    socket.on(\"message_sent_success\", handleMessageSent); // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage);\n    socket.on(\"receive_message\", handleNewMessage);\n    socket.on(\"group_message\", handleNewMessage);\n    socket.on(\"friend_request\", handleFriendRequest);\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted);\n    socket.on(\"friend_removed\", handleFriendRemoved);\n    socket.on(\"refresh_contacts\", handleRefreshContacts);\n    socket.on(\"notification\", handleNotification);\n    socket.on(\"group_created\", handleSocketGroupCreated);\n    socket.on(\"group_updated\", handleSocketGroupUpdated);\n    socket.on(\"group_deleted\", handleGroupDeleted);\n    socket.on(\"member_added\", handleMemberAdded);\n    socket.on(\"member_removed\", handleMemberRemoved);\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false;\n      socket.off(\"connect\", handleConnect);\n      socket.off(\"message_sent_success\", handleMessageSent); // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage);\n      socket.off(\"receive_message\", handleNewMessage);\n      socket.off(\"group_message\", handleNewMessage);\n      socket.off(\"friend_request\", handleFriendRequest);\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted);\n      socket.off(\"friend_removed\", handleFriendRemoved);\n      socket.off(\"refresh_contacts\", handleRefreshContacts);\n      socket.off(\"notification\", handleNotification);\n      socket.off(\"group_created\", handleSocketGroupCreated);\n      socket.off(\"group_updated\", handleSocketGroupUpdated);\n      socket.off(\"group_deleted\", handleGroupDeleted);\n      socket.off(\"member_added\", handleMemberAdded);\n      socket.off(\"member_removed\", handleMemberRemoved);\n    };\n  }, [handleNewMessage, handleFriendRequest, handleFriendRequestAccepted, handleFriendRemoved, handleRefreshContacts, handleNotification, handleSocketGroupCreated, handleSocketGroupUpdated, handleGroupDeleted, handleMemberAdded, handleMemberRemoved, selectedContact // Add selectedContact as dependency\n  ]);\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]); // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n      var _messagesEndRef$curre;\n      (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"end\"\n      });\n    }, 100);\n  };\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(contact => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const filteredGroups = groups.filter(group => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"]; // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts,\n    // Return full contacts list if needed elsewhere\n    groups,\n    // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab,\n    // Needed for friend request notification\n    setShowProfileModal,\n    // Needed for closing modal from component\n    setProfileData,\n    // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal,\n    // Needed for closing modal from component\n    setFriendEmail,\n    // Needed for form input\n    // setError, // Internal state\n    setShowToast,\n    // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal,\n    // Needed for closing modal from component\n    setShowGroupInfoModal,\n    // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile,\n    // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError,\n    // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\") // Pass token for Modals\n  };\n};\n_s(useChat, \"niuaukvlN0tu09YWhzXcsW2hdxg=\", false, function () {\n  return [useNavigate];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useNavigate","axios","io","API_BASE_URL","socket","autoConnect","reconnection","reconnectionAttempts","Number","POSITIVE_INFINITY","reconnectionDelay","reconnectionDelayMax","timeout","transports","upgrade","forceNew","query","timestamp","Date","now","on","console","log","id","err","error","reason","window","originalConsoleError","args","includes","apply","useChat","_s","navigate","user","setUser","name","avatar","contacts","setContacts","groups","setGroups","selectedContact","setSelectedContact","messages","setMessages","newMessage","setNewMessage","isConnected","setIsConnected","connected","showEmojiPicker","setShowEmojiPicker","searchQuery","setSearchQuery","mediaFiles","setMediaFiles","documents","setDocuments","showMedia","setShowMedia","showFiles","setShowFiles","activeTab","setActiveTab","showProfileModal","setShowProfileModal","profileData","setProfileData","fullName","birthdate","gender","avatarUrl","loading","setLoading","showAddFriendModal","setShowAddFriendModal","friendEmail","setFriendEmail","setError","showToast","setShowToast","friendRequests","setFriendRequests","recoveredContacts","setRecoveredContacts","showCreateGroupModal","setShowCreateGroupModal","showGroupInfoModal","setShowGroupInfoModal","selectedGroup","setSelectedGroup","messagesEndRef","fileInputRef","imageInputRef","videoInputRef","showError","message","apiCall","method","url","data","token","toUpperCase","FormData","config","headers","Authorization","Pragma","response","status","_error$response","_error$response2","_error$response2$data","localStorage","removeItem","Error","errorMessage","addOrUpdateContact","newContact","savedContacts","getItem","contactsArray","JSON","parse","filter","c","push","setItem","stringify","storageError","prev","exists","some","contact","map","addOrUpdateGroup","newGroup","groupId","savedGroups","groupsArray","g","group","fetchUserProfile","userData","userId","toISOString","split","fetchMessages","conversationId","isGroup","warn","endpoint","messagesData","Array","isArray","mappedMessages","msg","index","_msg$attachments","_msg$attachments$","_msg$attachments2","_msg$attachments$2","_msg$attachments3","_msg$attachments$3","_msg$attachments4","_msg$attachments$4","_msg$attachments5","_msg$attachments$5","messageId","sender","senderId","senderName","content","isRecalled","isDeleted","type","attachments","time","toLocaleTimeString","hour","minute","isImage","isVideo","isFile","isUnsent","isSystemMessage","fileUrl","length","fileName","fileType","duration","messageDate","toLocaleDateString","systemMessage","unshift","media","_msg$attachments6","_msg$attachments6$","date","size","reverse","files","_msg$fileName","_msg$attachments7","_msg$attachments7$","pop","toLowerCase","fetchContactsAndGroups","fetchedContacts","fetchedGroups","friendsResponse","confirmedFriends","friends","validFriends","friend","friendshipId","mappedFriends","_friend$email","email","convResponse","conversationsMap","Map","forEach","conv","participants","otherUserId","find","set","has","get","existingContactsMap","existingContact","groupsResponse","userGroups","members","member","_group$members","_group$members2","adminId","admin","memberIds","memberCount","createdAt","e","fetchFriendRequests","createOrGetConversation","_response$conversatio","conversation","handleContactSelect","contactOrGroup","roomToLeave","eventName","emit","updatedContact","currentContacts","updatedContactsList","read","unreadCount","readError","handleSendMessage","preventDefault","trim","tempMessageId","messageTime","optimisticMessage","isSending","messageToSend","scrollToBottom","messageDataForSocket","_selectedContact$memb","messageContent","messageData","_error$response3","_error$response4","_response$messageData","_response$messageData2","receiverId","isError","handleSendFile","file","maxSize","startsWith","videoDuration","getVideoDuration","Math","round","tempUrl","URL","createObjectURL","formData","apiUrl","apiKey","append","revokeObjectURL","_messageData$attachme","attachment","newItem","socketEventData","socketEventName","Promise","resolve","reject","video","document","createElement","preload","onloadedmetadata","src","onerror","handleEmojiSelect","emoji","handleMessageAction","action","originalMessages","isDeleting","doc","toggleMediaView","toggleFilesView","handleTabChange","tab","handleProfileClick","userProfile","handleCloseProfileModal","handleAvatarChange","handleUpdateProfile","undefined","handleAddFriend","handleCloseAddFriendModal","handleSubmitAddFriend","emailRegex","test","_searchResult$data","searchResult","encodeURIComponent","handleRespondToFriendRequest","requestId","request","req","_response$conversatio2","_senderInfo$email","senderInfo","accepter","targetUserId","handleRemoveFriend","friendId","confirm","contactToRemove","updatedContacts","removerId","removedUserId","apiError","handleCreateGroup","handleGroupCreated","newGroupData","_newGroupData$members","groupObject","handleGroupInfo","handleGroupUpdated","updatedGroupData","_updatedGroupData$mem","handleLeaveGroup","updatedGroups","handleDeleteGroup","isMounted","socketInitialized","initializeApp","auth","opts","connect","off","handleNewMessage","selectedContactType","selectedContactGroupId","selectedContactConversationId","isCurrentChat","_data$attachments","_data$attachments$","_data$attachments2","_data$attachments2$","_data$attachments3","_data$attachments3$","_data$attachments4","_data$attachments4$","_data$attachments5","_data$attachments5$","_data$attachments6","_data$attachments6$","_newMessage$fileName","_data$attachments7","_data$attachments7$","_data$content","_data$content2","contactId","targetId","isGroupMessage","preview","substring","item","itemIdToMatch","lastMessage","lastMessageAt","hidden","Notification","permission","_contacts$find","_groups$find","contactName","body","icon","handleFriendRequest","handleFriendRequestAccepted","handleFriendRemoved","handleRefreshContacts","handleSocketGroupCreated","_group$members3","handleSocketGroupUpdated","_group$members4","handleGroupDeleted","_groups$find2","groupName","handleMemberAdded","_group$members5","addedBy","handleMemberRemoved","memberId","removedBy","_group$members6","_data$member","memberName","handleNotification","refreshContacts","handleConnect","handleMessageSent","prevMessages","oldId","newId","setTimeout","_messagesEndRef$curre","current","scrollIntoView","behavior","block","filteredContacts","filteredGroups","emojis"],"sources":["C:/Users/ADMIN/Desktop/Nhom12_Zalo_Web/FE-WebAppZola/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\"\nimport { useNavigate } from \"react-router-dom\"\nimport axios from \"axios\"\nimport { io } from \"socket.io-client\"\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\"\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false, // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false, // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now(),\n  },\n})\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id)\n})\n\nsocket.on(\"connect_error\", (err) => {\n  console.error(\"Socket connection error:\", err)\n})\n\nsocket.on(\"disconnect\", (reason) => {\n  console.log(\"Socket disconnected:\", reason)\n})\n\nsocket.on(\"error\", (err) => {\n  console.error(\"Socket error:\", err)\n})\n\nsocket.on(\"reconnect_error\", (err) => {\n  console.error(\"Socket reconnection error:\", err)\n})\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error\n  console.error = (...args) => {\n    if (\n      args[0] &&\n      typeof args[0] === \"string\" &&\n      (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))\n    ) {\n      return\n    }\n    originalConsoleError.apply(console, args)\n  }\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  const navigate = useNavigate()\n\n  // State Management\n  const [user, setUser] = useState({ id: \"\", name: \"User\", avatar: \"\" })\n  const [contacts, setContacts] = useState([])\n  const [groups, setGroups] = useState([])\n  const [selectedContact, setSelectedContact] = useState(null)\n  const [messages, setMessages] = useState([])\n  const [newMessage, setNewMessage] = useState(\"\")\n  const [isConnected, setIsConnected] = useState(socket.connected) // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false)\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [mediaFiles, setMediaFiles] = useState([])\n  const [documents, setDocuments] = useState([])\n  const [showMedia, setShowMedia] = useState(true)\n  const [showFiles, setShowFiles] = useState(false)\n  const [activeTab, setActiveTab] = useState(\"chat\")\n  const [showProfileModal, setShowProfileModal] = useState(false)\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null,\n  })\n  const [loading, setLoading] = useState(false)\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false)\n  const [friendEmail, setFriendEmail] = useState(\"\")\n  const [error, setError] = useState(null)\n  const [showToast, setShowToast] = useState(false)\n  const [friendRequests, setFriendRequests] = useState([])\n  const [recoveredContacts, setRecoveredContacts] = useState([]) // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false)\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false)\n  const [selectedGroup, setSelectedGroup] = useState(null)\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null)\n  const fileInputRef = useRef(null)\n  const imageInputRef = useRef(null)\n  const videoInputRef = useRef(null)\n\n  // --- Utility Functions ---\n\n  const showError = useCallback((message) => {\n    console.log(\"Showing Toast:\", message)\n    setError(message)\n    setShowToast(true)\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, [])\n\n  const apiCall = useCallback(\n    async (method, url, data = null, token) => {\n      try {\n        console.log(`API Call: ${method.toUpperCase()} ${url}`)\n        if (data) {\n          console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data)\n        }\n\n        const config = {\n          method,\n          url: `${API_BASE_URL}${url}`,\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n            \"If-None-Match\": \"\", // Prevent 304 responses\n          },\n          data,\n        }\n\n        if (!(data instanceof FormData)) {\n          config.headers[\"Content-Type\"] = \"application/json\"\n        }\n\n        console.log(\"Using config:\", {\n          method: config.method,\n          url: config.url,\n          headers: { ...config.headers, Authorization: \"Bearer [HIDDEN]\" },\n        })\n\n        const response = await axios(config)\n        console.log(`API Response ${url}:`, response.status, response.data)\n        return response.data\n      } catch (error) {\n        console.error(`API Error ${url}:`, error)\n        if (error.response) {\n          console.error(\"Response status:\", error.response.status)\n          console.error(\"Response data:\", error.response.data)\n        }\n\n        if (error.response?.status === 401) {\n          localStorage.removeItem(\"token\")\n          localStorage.removeItem(\"userProfile\") // Clear profile too\n          navigate(\"/login\")\n          // Use showError for consistency\n          showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\")\n          throw new Error(\"Phiên đăng nhập hết hạn.\") // Throw to stop further execution\n        }\n\n        const errorMessage = error.response?.data?.message || error.message || \"Đã xảy ra lỗi không xác định\"\n        // Don't automatically show toast here, let the calling function decide\n        // showError(errorMessage);\n        throw new Error(errorMessage)\n      }\n    },\n    [navigate, showError],\n  ) // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback((newContact) => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact)\n      return\n    }\n    console.log(\"Adding or updating contact:\", newContact)\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\")\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : []\n      contactsArray = contactsArray.filter((c) => c.id !== newContact.id)\n      contactsArray.push(newContact)\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray))\n      console.log(\"Saved contact to localStorage:\", newContact.id)\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError)\n    }\n    setContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n  }, [])\n\n  const addOrUpdateGroup = useCallback((newGroup) => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup)\n      return\n    }\n    console.log(\"Adding or updating group:\", newGroup)\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\")\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : []\n      groupsArray = groupsArray.filter((g) => g.groupId !== newGroup.groupId)\n      groupsArray.push(newGroup)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray))\n      console.log(\"Saved group to localStorage:\", newGroup.groupId)\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError)\n    }\n    setGroups((prev) => {\n      const exists = prev.some((group) => group.groupId === newGroup.groupId)\n      if (exists) {\n        return prev.map((group) => (group.groupId === newGroup.groupId ? { ...group, ...newGroup } : group))\n      }\n      return [...prev, newGroup]\n    })\n  }, [])\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(\n    async (token) => {\n      try {\n        const response = await apiCall(\"get\", \"/api/users/profile\", null, token)\n        const userData = {\n          id: response.userId,\n          name: response.fullName || \"User\",\n          avatar: response.avatarUrl || \"\",\n        }\n        setUser(userData)\n        setProfileData({\n          fullName: response.fullName || \"\",\n          birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n          gender: response.gender || \"\",\n          avatarUrl: response.avatarUrl || null,\n        })\n        // Save profile to localStorage after fetching\n        localStorage.setItem(\"userProfile\", JSON.stringify(response))\n        return response // Return the full profile\n      } catch (error) {\n        console.error(\"Error fetching user profile:\", error)\n        showError(\"Không thể lấy thông tin người dùng: \" + error.message)\n        // No need to navigate here, apiCall handles 401\n        return null\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const fetchMessages = useCallback(\n    async (token, conversationId, isGroup = false) => {\n      if (!token || !conversationId) {\n        console.warn(\"fetchMessages called without token or conversationId\")\n        setMessages([]) // Clear messages if no ID\n        setMediaFiles([])\n        setDocuments([])\n        return\n      }\n      setLoading(true) // Indicate loading messages\n      try {\n        let response\n        // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n        const endpoint = `/api/messages/conversations/${conversationId}/messages`\n\n        console.log(\"Fetching messages from endpoint:\", endpoint)\n        response = await apiCall(\"get\", endpoint, null, token)\n        console.log(\"Messages API response:\", response)\n\n        const messagesData = Array.isArray(response) ? response : response.data || []\n\n        const mappedMessages = messagesData\n          .map((msg, index) => ({\n            id: msg.messageId || `temp-${Date.now()}-${index}`,\n            sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n            content:\n              msg.isRecalled || msg.isDeleted\n                ? \"Tin nhắn đã bị thu hồi/xóa\"\n                : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\"\n                  ? msg.content\n                  : msg.attachments?.[0]?.url || msg.content || \"\", // Ensure content exists\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            senderId: msg.senderId,\n            isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n            isVideo: msg.type === \"video\",\n            isFile: msg.type === \"file\",\n            isUnsent: msg.isRecalled || msg.isDeleted,\n            isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n            fileUrl: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.url : null,\n            fileName: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.name : null,\n            fileType: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.type : null,\n            duration: msg.type === \"video\" && msg.attachments?.length > 0 ? msg.attachments[0]?.duration : null,\n            messageDate: new Date().toLocaleDateString(), // Used for media/files list\n          }))\n          .filter((msg) => msg.id) // Filter out messages without an ID\n\n        // Add system message if needed\n        if (mappedMessages.length === 0 || !mappedMessages.some((msg) => msg.isSystemMessage)) {\n          const systemMessage = isGroup\n            ? \"Chào mừng bạn đến với nhóm chat!\"\n            : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\"\n          mappedMessages.unshift({\n            id: `system-${Date.now()}`,\n            senderId: \"system\",\n            content: systemMessage,\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            isSystemMessage: true,\n          })\n        }\n\n        setMessages(mappedMessages)\n\n        // Update Media and Documents\n        const media = mappedMessages\n          .filter((msg) => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.isImage ? \"image\" : \"video\",\n            url: msg.content,\n            name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0, // Might not be available, default to 0\n            duration: msg.duration,\n          }))\n        setMediaFiles(media.reverse()) // Show newest first\n\n        const files = mappedMessages\n          .filter((msg) => msg.isFile && !msg.isUnsent && msg.fileUrl)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: msg.fileUrl,\n            name: msg.fileName,\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0,\n          }))\n        setDocuments(files.reverse()) // Show newest first\n      } catch (error) {\n        console.error(\"Error fetching messages:\", error)\n        showError(\"Không thể tải tin nhắn: \" + error.message)\n        setMessages([]) // Clear messages on error\n        setMediaFiles([])\n        setDocuments([])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id to compare sender\n  )\n\n  const fetchContactsAndGroups = useCallback(\n    async (token) => {\n      if (!token) return { contacts: [], groups: [] }\n      setLoading(true)\n      let fetchedContacts = []\n      let fetchedGroups = []\n\n      try {\n        // Fetch Friends (Contacts) from server first\n        console.log(\"Fetching friends from server...\")\n        const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token)\n        console.log(\"Friends API response:\", friendsResponse)\n\n        // Lọc ra những người bạn đã được xác nhận\n        // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n        const confirmedFriends = friendsResponse?.friends || []\n        console.log(\"Confirmed friends:\", confirmedFriends)\n\n        // Kiểm tra xem danh sách bạn bè có hợp lệ không\n        const validFriends = confirmedFriends.filter(friend =>\n          friend && friend.userId && friend.friendshipId\n        )\n\n        if (validFriends.length !== confirmedFriends.length) {\n          console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`)\n        }\n\n        const mappedFriends = validFriends.map((friend) => ({\n          id: friend.userId,\n          name: friend.fullName || friend.email?.split(\"@\")[0] || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\", // Trạng thái mặc định\n          friendshipId: friend.friendshipId, // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null, // Will be populated later\n        }))\n\n        // Fetch Conversations to get conversation IDs\n        console.log(\"Fetching conversations...\")\n        const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token)\n        const conversationsMap = new Map()\n        if (convResponse && Array.isArray(convResponse)) {\n          convResponse.forEach((conv) => {\n            if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n              const otherUserId = conv.participants.find((id) => id !== user.id)\n              if (otherUserId) {\n                conversationsMap.set(otherUserId, conv.conversationId)\n              }\n            }\n          })\n        }\n\n        // Update conversationId for mapped friends\n        mappedFriends.forEach((friend) => {\n          if (conversationsMap.has(friend.id)) {\n            friend.conversationId = conversationsMap.get(friend.id)\n          }\n        })\n\n        // Merge with existing contacts to preserve any additional data\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n\n        // Create a map of existing contacts for quick lookup\n        const existingContactsMap = new Map()\n        savedContacts.forEach(contact => {\n          if (contact && contact.id) {\n            existingContactsMap.set(contact.id, contact)\n          }\n        })\n\n        // Merge server data with existing data, prioritizing server data\n        fetchedContacts = mappedFriends.map(friend => {\n          const existingContact = existingContactsMap.get(friend.id)\n          if (existingContact) {\n            // Preserve conversationId if it exists in saved contact but not in server data\n            if (!friend.conversationId && existingContact.conversationId) {\n              friend.conversationId = existingContact.conversationId\n            }\n            return { ...existingContact, ...friend }\n          }\n          return friend\n        })\n\n        // Update state and localStorage\n        setContacts(fetchedContacts)\n        localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts))\n        console.log(\"Updated contacts from API:\", fetchedContacts.length)\n\n        // Fetch Groups\n        console.log(\"Fetching groups...\")\n        const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token)\n        console.log(\"Groups API response:\", groupsResponse)\n\n        if (groupsResponse && groupsResponse.groups) {\n          // Lọc các nhóm mà người dùng là thành viên\n          const userGroups = groupsResponse.groups.filter(\n            (group) => group.members && group.members.some(member => member.userId === user.id)\n          )\n          console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`)\n\n          fetchedGroups = userGroups.map((group) => ({\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [], // Lưu toàn bộ thông tin thành viên\n            memberIds: group.members?.map(member => member.userId) || [], // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || group.members?.length || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt,\n          }))\n          setGroups(fetchedGroups)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups))\n          console.log(\"Updated groups from API:\", fetchedGroups.length)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } catch (error) {\n        console.error(\"Error fetching contacts/groups:\", error)\n        showError(\"Không thể tải danh bạ/nhóm: \" + error.message)\n\n        // Fallback to localStorage only if server fetch fails\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n\n          if (savedContacts.length > 0) {\n            console.log(\"Falling back to contacts from localStorage\")\n            setContacts(savedContacts)\n            fetchedContacts = savedContacts\n          }\n\n          if (savedGroups.length > 0) {\n            console.log(\"Falling back to groups from localStorage\")\n            setGroups(savedGroups)\n            fetchedGroups = savedGroups\n          }\n        } catch (e) {\n          console.error(\"Error reading contacts/groups from localStorage\", e)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id for conversation mapping\n  )\n\n  const fetchFriendRequests = useCallback(\n    async (token) => {\n      if (!token) return\n      // No need for setLoading(true) here unless it's a primary action\n      try {\n        const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token)\n        setFriendRequests(response.data || [])\n      } catch (error) {\n        console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error)\n        // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(\n    async (otherUserId, token) => {\n      console.log(`Creating/getting conversation with user: ${otherUserId}`)\n      if (!token || !otherUserId) {\n        throw new Error(\"Token or otherUserId missing for createOrGetConversation\")\n      }\n      try {\n        const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token)\n        if (response?.conversation?.conversationId) {\n          console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId)\n          return response.conversation.conversationId\n        } else {\n          throw new Error(\"Invalid response structure from conversation API\")\n        }\n      } catch (error) {\n        console.error(\"Error in createOrGetConversation:\", error)\n        if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n          throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\")\n        }\n        throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`) // Rethrow with context\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(\n    async (contactOrGroup) => {\n      if (!contactOrGroup || contactOrGroup.id === selectedContact?.id) {\n        console.log(\"Selection unchanged or invalid.\")\n        return // Avoid re-selecting the same contact/group\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        navigate(\"/login\")\n        return\n      }\n\n      console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id)\n\n      // Leave previous room\n      if (selectedContact) {\n        const roomToLeave =\n          selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId\n        if (roomToLeave) {\n          const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\"\n          socket.emit(eventName, roomToLeave)\n          console.log(`Left ${selectedContact.type} room:`, roomToLeave)\n        }\n      }\n\n      // Clear previous state\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n      setSelectedContact(contactOrGroup) // Set selected contact immediately for UI update\n\n      try {\n        setLoading(true) // Show loading for message fetch\n\n        if (contactOrGroup.type === \"group\") {\n          const groupId = contactOrGroup.groupId\n          // Sử dụng conversationId từ group object\n          const conversationId = contactOrGroup.conversationId || groupId\n          socket.emit(\"join_group\", groupId)\n          console.log(\"Joined group room:\", groupId)\n          console.log(\"Using conversationId for group:\", conversationId)\n          await fetchMessages(token, conversationId, true)\n        } else {\n          // Handle individual contact\n          let conversationId = contactOrGroup.conversationId\n\n          // If conversationId is missing, try to fetch/create it\n          if (!conversationId) {\n            console.log(\"Conversation ID missing, attempting to fetch/create...\")\n            try {\n              conversationId = await createOrGetConversation(contactOrGroup.id, token)\n              // Update the contact in the list and the selected contact state\n              const updatedContact = { ...contactOrGroup, conversationId }\n              setSelectedContact(updatedContact) // Update selected state with new ID\n              setContacts((prev) => prev.map((c) => (c.id === contactOrGroup.id ? updatedContact : c)))\n              // Optionally save updated contacts list to localStorage\n              const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n              const updatedContactsList = currentContacts.map((c) =>\n                c.id === contactOrGroup.id ? updatedContact : c,\n              )\n              localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList))\n            } catch (error) {\n              showError(error.message) // Show error from createOrGetConversation\n              setSelectedContact(null) // Deselect if conversation fails\n              setLoading(false)\n              return // Stop execution if conversation fails\n            }\n          }\n\n          if (conversationId) {\n            socket.emit(\"join_conversation\", conversationId)\n            console.log(\"Joined conversation room:\", conversationId)\n            await fetchMessages(token, conversationId, false)\n\n            // Mark conversation as read with proper request body\n            try {\n              await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, { read: true }, token)\n\n              // Update contacts list to remove unread badge\n              setContacts((prev) =>\n                prev.map((c) =>\n                  c.id === contactOrGroup.id ? { ...c, unreadCount: 0 } : c\n                )\n              )\n            } catch (readError) {\n              console.error(\"Error marking conversation as read:\", readError)\n              // Don't show error to user since this is a non-critical operation\n            }\n          } else {\n            // This case should ideally not be reached if createOrGetConversation throws errors\n            showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\")\n            setSelectedContact(null)\n          }\n        }\n      } catch (error) {\n        // Catch errors from fetchMessages or socket emits\n        console.error(\"Error in handleContactSelect processing:\", error)\n        showError(`Lỗi khi chọn liên hệ: ${error.message}`)\n        setSelectedContact(null) // Deselect on error\n      } finally {\n        setLoading(false) // Ensure loading is turned off\n      }\n    },\n    [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall],\n  )\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(\n    async (e) => {\n      e.preventDefault()\n      if (!newMessage.trim() || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      const tempMessageId = `temp-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: newMessage,\n        time: messageTime,\n        senderId: user.id,\n        isSending: true, // Indicate sending state\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      const messageToSend = newMessage // Store message before clearing\n      setNewMessage(\"\") // Clear input immediately\n      scrollToBottom() // Scroll after adding optimistic message\n\n      try {\n        let response\n        let messageDataForSocket\n\n        if (selectedContact.type === \"group\") {\n          const groupId = selectedContact.groupId\n          console.log(\"Attempting to send group message:\", {\n            groupId,\n            messageContent: messageToSend,\n            selectedContact\n          })\n\n          if (!groupId) {\n            throw new Error(\"GroupId is missing\")\n          }\n\n          // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n          if (!selectedContact.memberIds?.includes(user.id)) {\n            console.error(\"User not in group members:\", {\n              userId: user.id,\n              memberIds: selectedContact.memberIds,\n              members: selectedContact.members\n            })\n            throw new Error(\"Bạn không phải là thành viên của nhóm này\")\n          }\n\n          try {\n            response = await apiCall(\n              \"post\", \n              `/api/groups/${groupId}/messages`, \n              { content: messageToSend }, \n              token\n            )\n            \n            console.log(\"Group message API response:\", response)\n            \n            if (!response) {\n              throw new Error(\"No response from server\")\n            }\n\n            if (!response.messageData) {\n              console.error(\"Invalid response structure:\", response)\n              throw new Error(\"Invalid response structure from server\")\n            }\n            \n            const messageData = response.messageData\n            messageDataForSocket = {\n              messageId: messageData.messageId,\n              groupId: groupId,\n              senderId: user.id,\n              senderName: user.name,\n              content: messageToSend,\n              type: \"text\",\n              createdAt: messageData.createdAt || new Date().toISOString(),\n            }\n\n            console.log(\"Emitting socket event with data:\", messageDataForSocket)\n            socket.emit(\"group_message\", messageDataForSocket)\n\n            // Update optimistic message with real ID and remove sending state\n            setMessages((prev) =>\n              prev.map((msg) =>\n                msg.id === tempMessageId\n                  ? {\n                      ...msg,\n                      id: messageData.messageId,\n                      isSending: false,\n                      time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    }\n                  : msg\n              )\n            )\n          } catch (error) {\n            console.error(\"Error details:\", {\n              error,\n              groupId,\n              selectedContact,\n              user: { id: user.id, name: user.name }\n            })\n            \n            if (error.response?.status === 404) {\n              throw new Error(\"Không tìm thấy nhóm chat\")\n            } else if (error.response?.status === 403) {\n              throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\")\n            } else {\n              throw error\n            }\n          }\n        } else {\n          // Handle individual contact message sending\n          const conversationId = selectedContact.conversationId\n          if (!conversationId) {\n            throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\")\n          }\n          response = await apiCall(\n            \"post\",\n            \"/api/messages/send/text\",\n            { \n              conversationId: conversationId, \n              content: messageToSend,\n              tempMessageId: tempMessageId // Add tempMessageId to help match response\n            },\n            token\n          )\n          messageDataForSocket = {\n            messageId: response.messageData?.messageId || response.messageId,\n            tempMessageId: tempMessageId, // Include tempMessageId in socket event\n            conversationId: conversationId,\n            senderId: user.id,\n            senderName: user.name,\n            receiverId: selectedContact.id,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: response.messageData?.createdAt || new Date().toISOString(),\n            time: messageTime // Include original time for matching\n          }\n          socket.emit(\"new_message\", messageDataForSocket)\n        }\n      } catch (error) {\n        console.error(\"Error sending message:\", error)\n        showError(\"Không thể gửi tin nhắn: \" + error.message)\n        // Remove or mark optimistic message as failed\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n      }\n    },\n    [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(\n    async (file, fileType = \"file\") => {\n      // fileType can be 'file', 'image', 'video'\n      if (!file || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n      const maxSize = 50 * 1024 * 1024 // 50MB\n      if (file.size > maxSize) {\n        showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`)\n        return\n      }\n      if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n        showError(\"Chỉ chấp nhận file hình ảnh.\")\n        return\n      }\n      if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n        showError(\"Chỉ chấp nhận file video.\")\n        return\n      }\n\n      // Video duration check\n      let videoDuration = null\n      if (fileType === \"video\") {\n        try {\n          const duration = await getVideoDuration(file)\n          if (duration > 90) {\n            showError(\"Video không được dài quá 90 giây.\")\n            return\n          }\n          videoDuration = Math.round(duration)\n        } catch (err) {\n          showError(\"Không thể đọc thông tin video.\")\n          return\n        }\n      }\n\n      const tempMessageId = `temp-file-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      const tempUrl = URL.createObjectURL(file) // For optimistic UI\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: fileType === \"text\" ? file.name : tempUrl, // Use tempUrl for image/video\n        time: messageTime,\n        senderId: user.id,\n        isSending: true,\n        isFile: fileType === \"file\",\n        isImage: fileType === \"image\",\n        isVideo: fileType === \"video\",\n        fileName: file.name,\n        fileType: file.type,\n        duration: videoDuration,\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      scrollToBottom()\n\n      const formData = new FormData()\n      let apiUrl = \"\"\n      let apiKey = \"\" // Key for the file in FormData\n\n      if (selectedContact.type === \"group\") {\n        const groupId = selectedContact.groupId\n        formData.append(\"groupId\", groupId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = `/api/groups/${groupId}/images`\n            apiKey = \"image\" // Match backend key\n            break\n          case \"video\":\n            apiUrl = `/api/groups/${groupId}/videos`\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = `/api/groups/${groupId}/files`\n            apiKey = \"file\"\n            break\n        }\n      } else {\n        const conversationId = selectedContact.conversationId\n        if (!conversationId) {\n          showError(\"Không tìm thấy cuộc trò chuyện để gửi file\")\n          URL.revokeObjectURL(tempUrl)\n          setMessages((prev) => prev.filter((msg) => msg.id !== tempMessageId)) // Remove optimistic msg\n          return\n        }\n        formData.append(\"conversationId\", conversationId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = \"/api/messages/send/image\"\n            apiKey = \"images\" // Match backend key (plural for this endpoint)\n            break\n          case \"video\":\n            apiUrl = \"/api/messages/send/video\"\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = \"/api/messages/send/file\"\n            apiKey = \"file\"\n            break\n        }\n      }\n\n      formData.append(apiKey, file)\n\n      try {\n        const response = await apiCall(\"post\", apiUrl, formData, token)\n        const messageData = response.messageData || response // Adjust based on API response structure\n        const attachment = messageData.attachments?.[0]\n\n        if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n          throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\")\n        }\n\n        // Update optimistic message\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === tempMessageId\n              ? {\n                  ...msg,\n                  id: messageData.messageId,\n                  content: attachment.url, // Use final URL\n                  fileUrl: fileType === \"file\" ? attachment.url : null,\n                  isSending: false,\n                  time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                  }),\n                }\n              : msg,\n          ),\n        )\n\n        // Update media/documents list\n        const newItem = {\n          id: messageData.messageId,\n          type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n          url: attachment.url,\n          name: attachment.name || file.name,\n          date: new Date(messageData.createdAt).toLocaleDateString(),\n          size: attachment.size || file.size,\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        if (fileType === \"image\" || fileType === \"video\") {\n          setMediaFiles((prev) => [newItem, ...prev]) // Add to beginning (newest)\n        } else {\n          setDocuments((prev) => [newItem, ...prev])\n        }\n\n        // Emit socket event\n        const socketEventData = {\n          messageId: messageData.messageId,\n          conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n          groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n          type: fileType, // 'file', 'image', 'video'\n          content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null, // Content might be null for media\n          attachments: messageData.attachments,\n          createdAt: messageData.createdAt || new Date().toISOString(),\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\"\n        socket.emit(socketEventName, socketEventData)\n\n        URL.revokeObjectURL(tempUrl) // Clean up temp URL\n      } catch (error) {\n        console.error(`Error sending ${fileType}:`, error)\n        showError(`Không thể gửi ${fileType}: ${error.message}`)\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n        URL.revokeObjectURL(tempUrl)\n      }\n    },\n    [isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  const getVideoDuration = (file) => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\")\n      video.preload = \"metadata\"\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src)\n        resolve(video.duration)\n      }\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src)\n        reject(new Error(\"Không thể tải metadata video\"))\n      }\n      video.src = URL.createObjectURL(file)\n    })\n  }\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback((emoji) => {\n    setNewMessage((prev) => prev + emoji)\n    setShowEmojiPicker(false)\n  }, [])\n\n  const handleMessageAction = useCallback(\n    async (messageId, action) => {\n      if (action === \"delete\") {\n        const token = localStorage.getItem(\"token\")\n        if (!token || !selectedContact) return\n\n        // Optimistic UI update\n        const originalMessages = [...messages]\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === messageId ? { ...msg, content: \"Đang xóa...\", isUnsent: true, isDeleting: true } : msg,\n          ),\n        )\n\n        try {\n          if (selectedContact.type === \"group\") {\n            await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token)\n          } else {\n            await apiCall(\"delete\", `/api/messages/${messageId}`, null, token)\n          }\n\n          // Confirm deletion in UI\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === messageId ? { ...msg, content: \"Tin nhắn đã bị xóa\", isDeleting: false } : msg,\n            ),\n          )\n\n          // Remove from media/documents lists\n          setMediaFiles((prev) => prev.filter((media) => media.id !== messageId))\n          setDocuments((prev) => prev.filter((doc) => doc.id !== messageId))\n\n          // TODO: Emit socket event for deletion if needed by backend/other clients\n        } catch (error) {\n          console.error(\"Error deleting message:\", error)\n          showError(\"Không thể xóa tin nhắn: \" + error.message)\n          // Revert optimistic update on error\n          setMessages(originalMessages)\n        }\n      }\n      // Handle other actions like 'recall' if implemented\n    },\n    [apiCall, selectedContact, showError, messages], // Include messages in dependency array\n  )\n\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true)\n    setShowFiles(false)\n  }, [])\n\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false)\n    setShowFiles(true)\n  }, [])\n\n  const handleTabChange = useCallback((tab) => {\n    setActiveTab(tab)\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchFriendRequests(token)\n      }\n    }\n  }, [fetchFriendRequests]) // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null,\n    })\n    setShowProfileModal(true)\n  }, [user.name, user.avatar]) // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false)\n  }, [])\n\n  const handleAvatarChange = useCallback(\n    async (file) => {\n      // File validation\n      if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n        showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\")\n        return\n      }\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const formData = new FormData()\n      formData.append(\"avatar\", file)\n\n      try {\n        setLoading(true) // Indicate loading\n        const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token)\n        // Update state optimistically/realistically\n        setProfileData((prev) => ({ ...prev, avatarUrl: response.avatarUrl }))\n        setUser((prev) => ({ ...prev, avatar: response.avatarUrl }))\n        // Update localStorage userProfile\n        const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n        userProfile.avatarUrl = response.avatarUrl\n        localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n        showError(\"Cập nhật ảnh đại diện thành công!\")\n      } catch (error) {\n        showError(\"Không thể tải avatar: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    try {\n      setLoading(true)\n      const response = await apiCall(\n        \"put\",\n        \"/api/users/profile\",\n        {\n          fullName: profileData.fullName,\n          // Ensure birthdate is sent correctly or omitted if empty\n          birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n          gender: profileData.gender || undefined, // Send undefined if empty to potentially clear it\n        },\n        token,\n      )\n      // Update user state\n      setUser((prev) => ({\n        ...prev,\n        name: response.fullName || prev.name,\n        // Avatar might not be in this response, keep existing one\n      }))\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      userProfile.fullName = response.fullName\n      userProfile.birthdate = response.birthdate\n      userProfile.gender = response.gender\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n\n      showError(\"Cập nhật hồ sơ thành công!\")\n      handleCloseProfileModal()\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message)\n    } finally {\n      setLoading(false)\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal])\n\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true)\n  }, [])\n\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false)\n    setFriendEmail(\"\") // Reset email field\n  }, [])\n\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\")\n      return\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\")\n      return\n    }\n\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    setLoading(true)\n    try {\n      // Search user first to get ID\n      const searchResult = await apiCall(\n        \"get\",\n        `/api/users/search?query=${encodeURIComponent(friendEmail)}`,\n        null,\n        token,\n      )\n      if (!searchResult?.data?.length) {\n        throw new Error(\"Không tìm thấy người dùng với email này\")\n      }\n      const receiverId = searchResult.data[0].userId\n\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\")\n      }\n\n      // Check if already friends\n      if (contacts.some((c) => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\")\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", { receiverId, message: `Kết bạn từ ${user.name}` }, token)\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`)\n      handleCloseAddFriendModal()\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`)\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`)\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`)\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`)\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false)\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts])\n\n  const handleRespondToFriendRequest = useCallback(\n    async (requestId, action) => {\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const request = friendRequests.find((req) => req.requestId === requestId)\n      if (!request) return\n\n      setLoading(true) // Indicate processing\n      // Optimistically remove from list\n      setFriendRequests((prev) => prev.filter((req) => req.requestId !== requestId))\n\n      try {\n        const response = await apiCall(\"post\", \"/api/friends/requests/respond\", { requestId, action }, token)\n        console.log(\"Friend request response:\", response)\n\n        if (action === \"accept\") {\n          showError(\"Đã chấp nhận lời mời kết bạn\")\n          const senderInfo = request.sender\n          if (!senderInfo || !senderInfo.userId) {\n            throw new Error(\"Thông tin người gửi không hợp lệ\")\n          }\n\n          // Get conversation ID (might be in response or need creation)\n          let conversationId = response.conversation?.conversationId\n          if (!conversationId) {\n            console.log(\"No conversationId in response, creating/getting...\")\n            conversationId = await createOrGetConversation(senderInfo.userId, token)\n          }\n\n          if (!conversationId) {\n            throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\")\n          }\n\n          // Create new contact object\n          const newContact = {\n            id: senderInfo.userId,\n            name: senderInfo.fullName || senderInfo.email?.split(\"@\")[0] || \"Unknown\",\n            avatar: senderInfo.avatarUrl || \"\",\n            type: \"contact\",\n            status: \"Bạn bè\",\n            conversationId: conversationId,\n          }\n\n          addOrUpdateContact(newContact) // Add/update contact list and localStorage\n\n          // Optionally select the new contact immediately\n          // handleContactSelect(newContact);\n\n          // Emit notification to the sender via socket\n          if (socket.connected) {\n            socket.emit(\"friend_request_accepted_notify\", {\n              accepter: { userId: user.id, fullName: user.name, avatarUrl: user.avatar },\n              senderId: senderInfo.userId, // Target the sender\n              conversationId: conversationId,\n            })\n            // Also tell sender to refresh their list\n            socket.emit(\"refresh_contacts_notify\", { targetUserId: senderInfo.userId })\n            console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\")\n          }\n        } else {\n          showError(\"Đã từ chối lời mời kết bạn\")\n          // Optionally notify sender of rejection via socket\n        }\n      } catch (error) {\n        console.error(\"Error responding to friend request:\", error)\n        showError(\"Không thể phản hồi lời mời: \" + error.message)\n        // Revert optimistic removal on error\n        setFriendRequests((prev) => [...prev, request])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user],\n  )\n\n  const handleRemoveFriend = useCallback(\n    async (friendId) => {\n      if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      console.log(`Attempting to remove friend with ID: ${friendId}`)\n      setLoading(true)\n\n      // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n      const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\")\n      if (!contactToRemove) {\n        showError(\"Không tìm thấy người dùng trong danh sách bạn bè\")\n        setLoading(false)\n        return\n      }\n\n      // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n      const currentContacts = [...contacts]\n\n      try {\n        // Cập nhật UI trước khi gọi API (optimistic update)\n        setContacts((prev) => prev.filter((contact) => contact.id !== friendId || contact.type !== \"contact\"))\n\n        // Cập nhật localStorage\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const updatedContacts = savedContacts.filter((c) => c.id !== friendId || c.type !== \"contact\")\n          localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts))\n        } catch (e) {\n          console.error(\"Error updating localStorage after friend removal\", e)\n        }\n\n        // Bỏ chọn nếu đang được chọn\n        if (selectedContact?.id === friendId && selectedContact?.type === \"contact\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        // Gọi API để xóa bạn bè\n        try {\n          console.log(`Calling API to remove friend: ${friendId}`)\n          const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token)\n          console.log(\"Friend removal API response:\", response)\n\n          showError(\"Đã xóa bạn bè thành công\")\n\n          // Thông báo cho người bạn bị xóa qua socket\n          if (socket && socket.connected) {\n            socket.emit(\"friend_removed_notify\", { removerId: user.id, removedUserId: friendId })\n            console.log(\"Emitted friend_removed_notify\")\n\n            // Thông báo cập nhật danh sách bạn bè\n            socket.emit(\"friend_list_updated\")\n          }\n\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token)\n        } catch (apiError) {\n          console.error(\"API error removing friend:\", apiError)\n\n          // Kiểm tra lỗi cụ thể\n          if (apiError.response && apiError.response.status === 404) {\n            // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n            showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\")\n            // Cập nhật lại danh sách bạn bè từ server\n            fetchContactsAndGroups(token)\n          } else {\n            // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n            showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"))\n            // Khôi phục lại danh sách bạn bè\n            setContacts(currentContacts)\n\n            // Khôi phục localStorage\n            try {\n              localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n            } catch (e) {\n              console.error(\"Error restoring localStorage\", e)\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error in handleRemoveFriend:\", error)\n        showError(\"Không thể xóa bạn bè: \" + error.message)\n\n        // Khôi phục lại danh sách bạn bè\n        setContacts(currentContacts)\n\n        // Khôi phục localStorage\n        try {\n          localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n        } catch (e) {\n          console.error(\"Error restoring localStorage\", e)\n        }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups],\n  )\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true)\n  }, [])\n\n  const handleGroupCreated = useCallback(\n    (newGroupData) => {\n      console.log(\"Group created data:\", newGroupData)\n      const groupObject = {\n        groupId: newGroupData.groupId,\n        id: newGroupData.groupId, // Add id for consistency\n        name: newGroupData.name,\n        avatar: newGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: newGroupData.adminId,\n        memberCount: newGroupData.members?.length || 1, // At least admin is a member\n        conversationId: newGroupData.conversationId || newGroupData.groupId,\n        createdAt: newGroupData.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      setShowCreateGroupModal(false)\n      showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`)\n      // Automatically select the new group\n      handleContactSelect(groupObject)\n    },\n    [addOrUpdateGroup, showError, handleContactSelect],\n  )\n\n  const handleGroupInfo = useCallback(\n    (group) => {\n      // Fetch full group details if necessary before showing modal\n      setSelectedGroup(group) // Pass the basic group info for now\n      setShowGroupInfoModal(true)\n      // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n    },\n    [], // No dependencies needed to just show the modal\n  )\n\n  const handleGroupUpdated = useCallback(\n    (updatedGroupData) => {\n      console.log(\"Group updated data:\", updatedGroupData)\n      // Ensure the data structure matches what addOrUpdateGroup expects\n      const groupObject = {\n        groupId: updatedGroupData.groupId,\n        id: updatedGroupData.groupId,\n        name: updatedGroupData.name,\n        avatar: updatedGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: updatedGroupData.adminId,\n        memberCount: updatedGroupData.memberCount || updatedGroupData.members?.length || 0,\n        conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n        createdAt: updatedGroupData.createdAt,\n        // Include other relevant fields if needed\n      }\n      addOrUpdateGroup(groupObject)\n      // Update selected contact if it's the one being edited\n      if (selectedContact?.id === groupObject.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n      setShowGroupInfoModal(false) // Close modal on success\n      showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`)\n    },\n    [addOrUpdateGroup, selectedContact, showError],\n  )\n\n  const handleLeaveGroup = useCallback(\n    async (groupId) => {\n      console.log(\"Leaving group:\", groupId)\n\n      if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      setLoading(true)\n\n      try {\n        // Gọi API để rời nhóm\n        const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token)\n        console.log(\"Leave group API response:\", response)\n\n        // Cập nhật UI sau khi API thành công\n        setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n\n        // Cập nhật localStorage\n        try {\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n          const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n        } catch (e) {\n          console.error(\"Error updating localStorage after leaving group\", e)\n        }\n\n        // Bỏ chọn nhóm nếu đang được chọn\n        if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        setShowGroupInfoModal(false) // Đóng modal\n        showError(\"Bạn đã rời khỏi nhóm thành công\")\n\n        // Thông báo qua socket nếu cần\n        if (socket.connected) {\n          socket.emit(\"left_group\", { groupId })\n        }\n      } catch (error) {\n        console.error(\"Error leaving group:\", error)\n        showError(\"Không thể rời khỏi nhóm: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [selectedContact, showError, apiCall],\n  )\n\n  const handleDeleteGroup = useCallback(\n    (groupId) => {\n      console.log(\"Deleting group:\", groupId)\n      setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch (e) {\n        console.error(\"Error updating localStorage after deleting group\", e)\n      }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n      setShowGroupInfoModal(false) // Close modal\n      showError(\"Đã xóa nhóm thành công\")\n      // API call to delete group should be handled within GroupInfoModal or here before state update\n    },\n    [selectedContact, showError],\n  )\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) {\n      navigate(\"/login\")\n      return\n    }\n\n    let isMounted = true // Flag to prevent state updates on unmounted component\n    let socketInitialized = false\n\n    const initializeApp = async () => {\n      try {\n        setLoading(true)\n        const userProfile = await fetchUserProfile(token)\n        if (!userProfile || !isMounted) return // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token)\n        if (!isMounted) return\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token)\n        if (!isMounted) return\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\")\n          \n          // Set socket auth and query params\n          socket.auth = { token }\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now(),\n          }\n\n          // Connect the socket\n          socket.connect()\n          socketInitialized = true\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error)\n      } finally {\n        if (isMounted) {\n          setLoading(false)\n        }\n      }\n    }\n\n    initializeApp()\n\n    // Cleanup function\n    return () => {\n      isMounted = false\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\")\n      socket.off(\"reconnect\")\n      socket.off(\"friend_request\")\n      socket.off(\"new_message\")\n      socket.off(\"receive_message\")\n      socket.off(\"group_message\")\n      socket.off(\"friend_request_accepted\")\n      socket.off(\"friend_removed\")\n      socket.off(\"refresh_contacts\")\n      socket.off(\"notification\")\n      socket.off(\"group_created\")\n      socket.off(\"group_updated\")\n      socket.off(\"group_deleted\")\n      socket.off(\"member_added\")\n      socket.off(\"member_removed\")\n    }\n  }, [navigate]) // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback((data) => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || (!data.messageId && !data.id)) {\n      console.error(\"Invalid message data received:\", data)\n      return\n    }\n\n    const messageTime = data.createdAt\n      ? new Date(data.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      : new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString()\n\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact?.type,\n      selectedContactGroupId: selectedContact?.groupId,\n      selectedContactConversationId: selectedContact?.conversationId\n    });\n\n    const isCurrentChat =\n      (selectedContact?.type === \"group\" && selectedContact.groupId === data.groupId) ||\n      (selectedContact?.type === \"contact\" && selectedContact.conversationId === data.conversationId)\n\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    if (isCurrentChat) {\n      const newMessage = {\n        id: data.messageId || data.id,\n        sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n        content:\n          data.isRecalled || data.isDeleted\n            ? \"Tin nhắn đã bị thu hồi/xóa\"\n            : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\"\n              ? data.content\n              : data.attachments?.[0]?.url || data.content || \"\",\n        time: messageTime,\n        senderId: data.senderId,\n        isImage: data.type === \"image\" || data.type === \"imageGroup\",\n        isVideo: data.type === \"video\",\n        isFile: data.type === \"file\",\n        isUnsent: data.isRecalled || data.isDeleted,\n        isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n        fileUrl: data.type === \"file\" ? data.attachments?.[0]?.url : null,\n        fileName: data.type === \"file\" ? data.attachments?.[0]?.name : null,\n        fileType: data.type === \"file\" ? data.attachments?.[0]?.type : null,\n        duration: data.type === \"video\" ? data.attachments?.[0]?.duration || data.duration : null,\n        messageDate: messageDate,\n      }\n\n      console.log(\"Created new message object:\", newMessage); // Log tin nhắn mới được tạo\n\n      // Check if message with this ID already exists to prevent duplicates\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        console.log(\"Message exists check:\", { messageId: newMessage.id, exists }); // Log kiểm tra tin nhắn trùng lặp\n        if (exists) {\n          console.log(\"Message already exists in state, skipping addition:\", newMessage.id);\n          return prev;\n        }\n        console.log(\"Adding new message from socket to state:\", newMessage.id);\n        return [...prev, newMessage];\n      });\n\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n            duration: newMessage.duration,\n          },\n          ...prev, // Add to beginning\n        ])\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n          },\n          ...prev, // Add to beginning\n        ])\n      }\n    } else {\n      // Notification for message in other chat\n      let senderName = \"Người dùng\"\n      let contactId = data.senderId // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find((g) => g.groupId === data.groupId)\n        senderName = `${data.senderName || \"Ai đó\"} (${group?.name || \"Nhóm\"})`\n      } else {\n        const contact = contacts.find((c) => c.id === data.senderId) // Tìm contact dựa trên senderId\n        senderName = contact?.name || data.senderName || \"Ai đó\"\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n\n      const preview =\n        data.type === \"text\"\n          ? data.content?.substring(0, 30) + (data.content?.length > 30 ? \"...\" : \"\")\n          : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`)\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview, // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      const contactName = data.senderName || \"Người dùng\"\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: contacts.find((c) => c.id === data.senderId)?.avatar || groups.find(g => g.groupId === data.groupId)?.avatar || \"/favicon.ico\", // Optional icon\n      })\n    }\n  }, [user.id, contacts, groups, selectedContact, showError])\n\n  const handleFriendRequest = useCallback((data) => {\n    if (!data || !data.requestId || !data.sender) return\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab])\n\n  const handleFriendRequestAccepted = useCallback((data) => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\")\n      return\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user])\n\n  const handleFriendRemoved = useCallback((data) => {\n    if (!data || !data.removerId) return\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError])\n\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\")\n    if (token) {\n      fetchContactsAndGroups(token)\n    }\n  }, [fetchContactsAndGroups])\n\n  const handleSocketGroupCreated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_created event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.members?.length || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`)\n  }, [addOrUpdateGroup, showError])\n\n  const handleSocketGroupUpdated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_updated event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`)\n  }, [addOrUpdateGroup, selectedContact, showError])\n\n  const handleGroupDeleted = useCallback((data) => {\n    if (!data?.groupId) return\n    console.log(\"Received group_deleted event:\", data.groupId)\n    const groupName = groups.find(g => g.groupId === data.groupId)?.name || \"Một nhóm\"\n    setGroups((prev) => prev.filter((group) => group.groupId !== data.groupId))\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n      const updatedGroups = savedGroups.filter((g) => g.groupId !== data.groupId)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n    } catch (e) { console.error(\"Error updating localStorage after group delete\", e) }\n\n    if (selectedContact?.id === data.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(null)\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`)\n  }, [groups, selectedContact, showError])\n\n  const handleMemberAdded = useCallback((data) => {\n    if (!data?.group || !data?.member || !data?.addedBy) return\n    console.log(\"Received member_added event:\", data)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`)\n    }\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleMemberRemoved = useCallback((data) => {\n    if (!data?.group || !data?.memberId || !data?.removedBy) return\n    console.log(\"Received member_removed event:\", data)\n    const group = data.group\n    const groupId = group.groupId\n\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`)\n      setGroups((prev) => prev.filter((g) => g.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch(e) { console.error(\"Error updating localStorage after being removed from group\", e) }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n    } else {\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || group.members?.length || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      const memberName = data.member?.fullName || \"một thành viên\"\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`)\n      if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleNotification = useCallback((data) => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data)\n      return\n    }\n    if (data.type === \"success\") {\n      showError(data.message)\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\")\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\")\n    } else {\n      showError(data.message)\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchContactsAndGroups(token)\n      }\n    }\n  }, [showError, fetchContactsAndGroups])\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true\n\n    const handleConnect = () => {\n      if (!isMounted) return\n      console.log(\"Socket re-connected inside hook.\")\n      setIsConnected(true)\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId)\n      }\n    }\n\n    // Add handler for message_sent event\n    const handleMessageSent = (data) => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data)\n        return\n      }\n      console.log(\"Received message_sent_success event:\", data)\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n          // Match by tempMessageId if available\n          (data.tempMessageId && msg.id === data.tempMessageId) ||\n          // Or match by conversationId and content if tempMessageId not available\n          (data.conversationId && msg.conversationId === data.conversationId && \n           msg.content === data.content)\n        )) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          })\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          }\n        }\n        return msg\n      }))\n    }\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect)\n    socket.on(\"message_sent_success\", handleMessageSent) // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage)\n    socket.on(\"receive_message\", handleNewMessage)\n    socket.on(\"group_message\", handleNewMessage)\n    socket.on(\"friend_request\", handleFriendRequest)\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted)\n    socket.on(\"friend_removed\", handleFriendRemoved)\n    socket.on(\"refresh_contacts\", handleRefreshContacts)\n    socket.on(\"notification\", handleNotification)\n    socket.on(\"group_created\", handleSocketGroupCreated)\n    socket.on(\"group_updated\", handleSocketGroupUpdated)\n    socket.on(\"group_deleted\", handleGroupDeleted)\n    socket.on(\"member_added\", handleMemberAdded)\n    socket.on(\"member_removed\", handleMemberRemoved)\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false\n      socket.off(\"connect\", handleConnect)\n      socket.off(\"message_sent_success\", handleMessageSent) // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage)\n      socket.off(\"receive_message\", handleNewMessage)\n      socket.off(\"group_message\", handleNewMessage)\n      socket.off(\"friend_request\", handleFriendRequest)\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted)\n      socket.off(\"friend_removed\", handleFriendRemoved)\n      socket.off(\"refresh_contacts\", handleRefreshContacts)\n      socket.off(\"notification\", handleNotification)\n      socket.off(\"group_created\", handleSocketGroupCreated)\n      socket.off(\"group_updated\", handleSocketGroupUpdated)\n      socket.off(\"group_deleted\", handleGroupDeleted)\n      socket.off(\"member_added\", handleMemberAdded)\n      socket.off(\"member_removed\", handleMemberRemoved)\n    }\n  }, [\n    handleNewMessage,\n    handleFriendRequest,\n    handleFriendRequestAccepted,\n    handleFriendRemoved,\n    handleRefreshContacts,\n    handleNotification,\n    handleSocketGroupCreated,\n    handleSocketGroupUpdated,\n    handleGroupDeleted,\n    handleMemberAdded,\n    handleMemberRemoved,\n    selectedContact // Add selectedContact as dependency\n  ])\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages]) // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n        messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }, 100);\n  }\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(\n    (contact) => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n  const filteredGroups = groups.filter(\n    (group) => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"] // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts, // Return full contacts list if needed elsewhere\n    groups,   // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab, // Needed for friend request notification\n    setShowProfileModal, // Needed for closing modal from component\n    setProfileData, // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal, // Needed for closing modal from component\n    setFriendEmail, // Needed for form input\n    // setError, // Internal state\n    setShowToast, // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal, // Needed for closing modal from component\n    setShowGroupInfoModal, // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile, // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError, // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"), // Pass token for Modals\n  }\n}\n\nexport default useChat\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}