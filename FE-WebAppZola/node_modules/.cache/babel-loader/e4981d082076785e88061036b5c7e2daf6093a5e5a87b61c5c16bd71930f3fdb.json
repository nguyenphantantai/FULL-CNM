{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport axios from \"axios\";\nimport { io } from \"socket.io-client\";\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\";\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false,\n  // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false,\n  // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now()\n  }\n});\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id);\n});\nsocket.on(\"connect_error\", err => {\n  console.error(\"Socket connection error:\", err);\n});\nsocket.on(\"disconnect\", reason => {\n  console.log(\"Socket disconnected:\", reason);\n});\nsocket.on(\"error\", err => {\n  console.error(\"Socket error:\", err);\n});\nsocket.on(\"reconnect_error\", err => {\n  console.error(\"Socket reconnection error:\", err);\n});\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error;\n  console.error = (...args) => {\n    if (args[0] && typeof args[0] === \"string\" && (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))) {\n      return;\n    }\n    originalConsoleError.apply(console, args);\n  };\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  _s();\n  const navigate = useNavigate();\n\n  // State Management\n  const [user, setUser] = useState({\n    id: \"\",\n    name: \"User\",\n    avatar: \"\"\n  });\n  const [contacts, setContacts] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [selectedContact, setSelectedContact] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(socket.connected); // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [mediaFiles, setMediaFiles] = useState([]);\n  const [documents, setDocuments] = useState([]);\n  const [showMedia, setShowMedia] = useState(true);\n  const [showFiles, setShowFiles] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"chat\");\n  const [showProfileModal, setShowProfileModal] = useState(false);\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null\n  });\n  const [loading, setLoading] = useState(false);\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false);\n  const [friendEmail, setFriendEmail] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [showToast, setShowToast] = useState(false);\n  const [friendRequests, setFriendRequests] = useState([]);\n  const [recoveredContacts, setRecoveredContacts] = useState([]); // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({});\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageInputRef = useRef(null);\n  const videoInputRef = useRef(null);\n\n  // --- Utility Functions ---\n\n  const showError = useCallback(message => {\n    console.log(\"Showing Toast:\", message);\n    setError(message);\n    setShowToast(true);\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, []);\n  const apiCall = useCallback(async (method, url, data = null, token) => {\n    try {\n      console.log(`API Call: ${method.toUpperCase()} ${url}`);\n      if (data) {\n        console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data);\n      }\n      const config = {\n        method,\n        url: `${API_BASE_URL}${url}`,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n          \"If-None-Match\": \"\" // Prevent 304 responses\n        },\n        data\n      };\n      if (!(data instanceof FormData)) {\n        config.headers[\"Content-Type\"] = \"application/json\";\n      }\n      console.log(\"Using config:\", {\n        method: config.method,\n        url: config.url,\n        headers: {\n          ...config.headers,\n          Authorization: \"Bearer [HIDDEN]\"\n        }\n      });\n      const response = await axios(config);\n      console.log(`API Response ${url}:`, response.status, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error(`API Error ${url}:`, error);\n      if (error.response) {\n        console.error(\"Response status:\", error.response.status);\n        console.error(\"Response data:\", error.response.data);\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"userProfile\"); // Clear profile too\n        navigate(\"/login\");\n        // Use showError for consistency\n        showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\");\n        throw new Error(\"Phiên đăng nhập hết hạn.\"); // Throw to stop further execution\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || \"Đã xảy ra lỗi không xác định\";\n      // Don't automatically show toast here, let the calling function decide\n      // showError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [navigate, showError]); // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback(newContact => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact);\n      return;\n    }\n    console.log(\"Adding or updating contact:\", newContact);\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\");\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : [];\n      contactsArray = contactsArray.filter(c => c.id !== newContact.id);\n      contactsArray.push(newContact);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray));\n      console.log(\"Saved contact to localStorage:\", newContact.id);\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError);\n    }\n    setContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n  }, []);\n  const addOrUpdateGroup = useCallback(newGroup => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup);\n      return;\n    }\n    console.log(\"Adding or updating group:\", newGroup);\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\");\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : [];\n      groupsArray = groupsArray.filter(g => g.groupId !== newGroup.groupId);\n      groupsArray.push(newGroup);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray));\n      console.log(\"Saved group to localStorage:\", newGroup.groupId);\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError);\n    }\n    setGroups(prev => {\n      const exists = prev.some(group => group.groupId === newGroup.groupId);\n      if (exists) {\n        return prev.map(group => group.groupId === newGroup.groupId ? {\n          ...group,\n          ...newGroup\n        } : group);\n      }\n      return [...prev, newGroup];\n    });\n  }, []);\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(async token => {\n    try {\n      const response = await apiCall(\"get\", \"/api/users/profile\", null, token);\n      const userData = {\n        id: response.userId,\n        name: response.fullName || \"User\",\n        avatar: response.avatarUrl || \"\"\n      };\n      setUser(userData);\n      setProfileData({\n        fullName: response.fullName || \"\",\n        birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n        gender: response.gender || \"\",\n        avatarUrl: response.avatarUrl || null\n      });\n      // Save profile to localStorage after fetching\n      localStorage.setItem(\"userProfile\", JSON.stringify(response));\n      return response; // Return the full profile\n    } catch (error) {\n      console.error(\"Error fetching user profile:\", error);\n      showError(\"Không thể lấy thông tin người dùng: \" + error.message);\n      // No need to navigate here, apiCall handles 401\n      return null;\n    }\n  }, [apiCall, showError]);\n  const fetchMessages = useCallback(async (token, conversationId, isGroup = false) => {\n    if (!token || !conversationId) {\n      console.warn(\"fetchMessages called without token or conversationId\");\n      setMessages([]); // Clear messages if no ID\n      setMediaFiles([]);\n      setDocuments([]);\n      return;\n    }\n    setLoading(true); // Indicate loading messages\n    try {\n      let response;\n      // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n      const endpoint = `/api/messages/conversations/${conversationId}/messages`;\n      console.log(\"Fetching messages from endpoint:\", endpoint);\n      response = await apiCall(\"get\", endpoint, null, token);\n      console.log(\"Messages API response:\", response);\n      const messagesData = Array.isArray(response) ? response : response.data || [];\n      const mappedMessages = messagesData.map((msg, index) => {\n        var _msg$attachments, _msg$attachments$, _msg$attachments2, _msg$attachments$2, _msg$attachments3, _msg$attachments$3, _msg$attachments4, _msg$attachments$4, _msg$attachments5, _msg$attachments$5;\n        return {\n          id: msg.messageId || `temp-${Date.now()}-${index}`,\n          sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n          content: msg.isRecalled || msg.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\" ? msg.content : ((_msg$attachments = msg.attachments) === null || _msg$attachments === void 0 ? void 0 : (_msg$attachments$ = _msg$attachments[0]) === null || _msg$attachments$ === void 0 ? void 0 : _msg$attachments$.url) || msg.content || \"\",\n          // Ensure content exists\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          senderId: msg.senderId,\n          isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n          isVideo: msg.type === \"video\",\n          isFile: msg.type === \"file\",\n          isUnsent: msg.isRecalled || msg.isDeleted,\n          isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n          fileUrl: msg.type === \"file\" && ((_msg$attachments2 = msg.attachments) === null || _msg$attachments2 === void 0 ? void 0 : _msg$attachments2.length) > 0 ? (_msg$attachments$2 = msg.attachments[0]) === null || _msg$attachments$2 === void 0 ? void 0 : _msg$attachments$2.url : null,\n          fileName: msg.type === \"file\" && ((_msg$attachments3 = msg.attachments) === null || _msg$attachments3 === void 0 ? void 0 : _msg$attachments3.length) > 0 ? (_msg$attachments$3 = msg.attachments[0]) === null || _msg$attachments$3 === void 0 ? void 0 : _msg$attachments$3.name : null,\n          fileType: msg.type === \"file\" && ((_msg$attachments4 = msg.attachments) === null || _msg$attachments4 === void 0 ? void 0 : _msg$attachments4.length) > 0 ? (_msg$attachments$4 = msg.attachments[0]) === null || _msg$attachments$4 === void 0 ? void 0 : _msg$attachments$4.type : null,\n          duration: msg.type === \"video\" && ((_msg$attachments5 = msg.attachments) === null || _msg$attachments5 === void 0 ? void 0 : _msg$attachments5.length) > 0 ? (_msg$attachments$5 = msg.attachments[0]) === null || _msg$attachments$5 === void 0 ? void 0 : _msg$attachments$5.duration : null,\n          messageDate: new Date().toLocaleDateString() // Used for media/files list\n        };\n      }).filter(msg => msg.id); // Filter out messages without an ID\n\n      // Add system message if needed\n      if (mappedMessages.length === 0 || !mappedMessages.some(msg => msg.isSystemMessage)) {\n        const systemMessage = isGroup ? \"Chào mừng bạn đến với nhóm chat!\" : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\";\n        mappedMessages.unshift({\n          id: `system-${Date.now()}`,\n          senderId: \"system\",\n          content: systemMessage,\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          isSystemMessage: true\n        });\n      }\n\n      // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n      let mergedMessages = mappedMessages;\n      // Lấy cache mới nhất từ localStorage thay vì chỉ lấy từ state\n      const cacheFromStorage = JSON.parse(localStorage.getItem('cachedMessages') || '{}');\n      const cacheList = cacheFromStorage[conversationId] || [];\n      console.log('Cache for this conversation:', cacheList);\n      const newFromCache = cacheList.filter(cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id));\n      mergedMessages = [...mappedMessages, ...newFromCache];\n      // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n      mergedMessages.sort((a, b) => {\n        const aTime = new Date(a.createdAt || a.time || a.messageDate);\n        const bTime = new Date(b.createdAt || b.time || b.messageDate);\n        return aTime - bTime;\n      });\n      console.log('Merged messages after cache merge:', mergedMessages);\n      setMessages(mergedMessages);\n\n      // Update Media and Documents\n      const media = mappedMessages.filter(msg => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content).map(msg => {\n        var _msg$attachments6, _msg$attachments6$;\n        return {\n          id: msg.id,\n          type: msg.isImage ? \"image\" : \"video\",\n          url: msg.content,\n          name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n          date: msg.messageDate,\n          size: ((_msg$attachments6 = msg.attachments) === null || _msg$attachments6 === void 0 ? void 0 : (_msg$attachments6$ = _msg$attachments6[0]) === null || _msg$attachments6$ === void 0 ? void 0 : _msg$attachments6$.size) || 0,\n          // Might not be available, default to 0\n          duration: msg.duration\n        };\n      });\n      setMediaFiles(media.reverse()); // Show newest first\n\n      const files = mappedMessages.filter(msg => msg.isFile && !msg.isUnsent && msg.fileUrl).map(msg => {\n        var _msg$fileName, _msg$attachments7, _msg$attachments7$;\n        return {\n          id: msg.id,\n          type: ((_msg$fileName = msg.fileName) === null || _msg$fileName === void 0 ? void 0 : _msg$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n          url: msg.fileUrl,\n          name: msg.fileName,\n          date: msg.messageDate,\n          size: ((_msg$attachments7 = msg.attachments) === null || _msg$attachments7 === void 0 ? void 0 : (_msg$attachments7$ = _msg$attachments7[0]) === null || _msg$attachments7$ === void 0 ? void 0 : _msg$attachments7$.size) || 0\n        };\n      });\n      setDocuments(files.reverse()); // Show newest first\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      showError(\"Không thể tải tin nhắn: \" + error.message);\n      setMessages([]); // Clear messages on error\n      setMediaFiles([]);\n      setDocuments([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id to compare sender\n  );\n  const fetchContactsAndGroups = useCallback(async token => {\n    if (!token) return {\n      contacts: [],\n      groups: []\n    };\n    setLoading(true);\n    let fetchedContacts = [];\n    let fetchedGroups = [];\n    try {\n      // Fetch Friends (Contacts) from server first\n      console.log(\"Fetching friends from server...\");\n      const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token);\n      console.log(\"Friends API response:\", friendsResponse);\n\n      // Lọc ra những người bạn đã được xác nhận\n      // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n      const confirmedFriends = (friendsResponse === null || friendsResponse === void 0 ? void 0 : friendsResponse.friends) || [];\n      console.log(\"Confirmed friends:\", confirmedFriends);\n\n      // Kiểm tra xem danh sách bạn bè có hợp lệ không\n      const validFriends = confirmedFriends.filter(friend => friend && friend.userId && friend.friendshipId);\n      if (validFriends.length !== confirmedFriends.length) {\n        console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`);\n      }\n      const mappedFriends = validFriends.map(friend => {\n        var _friend$email;\n        return {\n          id: friend.userId,\n          name: friend.fullName || ((_friend$email = friend.email) === null || _friend$email === void 0 ? void 0 : _friend$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          // Trạng thái mặc định\n          friendshipId: friend.friendshipId,\n          // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null // Will be populated later\n        };\n      });\n\n      // Fetch Conversations to get conversation IDs\n      console.log(\"Fetching conversations...\");\n      const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token);\n      const conversationsMap = new Map();\n      if (convResponse && Array.isArray(convResponse)) {\n        convResponse.forEach(conv => {\n          if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n            const otherUserId = conv.participants.find(id => id !== user.id);\n            if (otherUserId) {\n              conversationsMap.set(otherUserId, conv.conversationId);\n            }\n          }\n        });\n      }\n\n      // Update conversationId for mapped friends\n      mappedFriends.forEach(friend => {\n        if (conversationsMap.has(friend.id)) {\n          friend.conversationId = conversationsMap.get(friend.id);\n        }\n      });\n\n      // Merge with existing contacts to preserve any additional data\n      const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n\n      // Create a map of existing contacts for quick lookup\n      const existingContactsMap = new Map();\n      savedContacts.forEach(contact => {\n        if (contact && contact.id) {\n          existingContactsMap.set(contact.id, contact);\n        }\n      });\n\n      // Merge server data with existing data, prioritizing server data\n      fetchedContacts = mappedFriends.map(friend => {\n        const existingContact = existingContactsMap.get(friend.id);\n        if (existingContact) {\n          // Preserve conversationId if it exists in saved contact but not in server data\n          if (!friend.conversationId && existingContact.conversationId) {\n            friend.conversationId = existingContact.conversationId;\n          }\n          return {\n            ...existingContact,\n            ...friend\n          };\n        }\n        return friend;\n      });\n\n      // Update state and localStorage\n      setContacts(fetchedContacts);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts));\n      console.log(\"Updated contacts from API:\", fetchedContacts.length);\n\n      // Fetch Groups\n      console.log(\"Fetching groups...\");\n      const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token);\n      console.log(\"Groups API response:\", groupsResponse);\n      if (groupsResponse && groupsResponse.groups) {\n        // Lọc các nhóm mà người dùng là thành viên\n        const userGroups = groupsResponse.groups.filter(group => group.members && group.members.some(member => member.userId === user.id));\n        console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`);\n        fetchedGroups = userGroups.map(group => {\n          var _group$members, _group$members2;\n          return {\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [],\n            // Lưu toàn bộ thông tin thành viên\n            memberIds: ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.map(member => member.userId)) || [],\n            // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || ((_group$members2 = group.members) === null || _group$members2 === void 0 ? void 0 : _group$members2.length) || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt\n          };\n        });\n        setGroups(fetchedGroups);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups));\n        console.log(\"Updated groups from API:\", fetchedGroups.length);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } catch (error) {\n      console.error(\"Error fetching contacts/groups:\", error);\n      showError(\"Không thể tải danh bạ/nhóm: \" + error.message);\n\n      // Fallback to localStorage only if server fetch fails\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        if (savedContacts.length > 0) {\n          console.log(\"Falling back to contacts from localStorage\");\n          setContacts(savedContacts);\n          fetchedContacts = savedContacts;\n        }\n        if (savedGroups.length > 0) {\n          console.log(\"Falling back to groups from localStorage\");\n          setGroups(savedGroups);\n          fetchedGroups = savedGroups;\n        }\n      } catch (e) {\n        console.error(\"Error reading contacts/groups from localStorage\", e);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id for conversation mapping\n  );\n  const fetchFriendRequests = useCallback(async token => {\n    if (!token) return;\n    // No need for setLoading(true) here unless it's a primary action\n    try {\n      const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token);\n      setFriendRequests(response.data || []);\n    } catch (error) {\n      console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error);\n      // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n    }\n  }, [apiCall]);\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(async (otherUserId, token) => {\n    console.log(`Creating/getting conversation with user: ${otherUserId}`);\n    if (!token || !otherUserId) {\n      throw new Error(\"Token or otherUserId missing for createOrGetConversation\");\n    }\n    try {\n      var _response$conversatio;\n      const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token);\n      if (response !== null && response !== void 0 && (_response$conversatio = response.conversation) !== null && _response$conversatio !== void 0 && _response$conversatio.conversationId) {\n        console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId);\n        return response.conversation.conversationId;\n      } else {\n        throw new Error(\"Invalid response structure from conversation API\");\n      }\n    } catch (error) {\n      console.error(\"Error in createOrGetConversation:\", error);\n      if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n        throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\");\n      }\n      throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`); // Rethrow with context\n    }\n  }, [apiCall]);\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(async contactOrGroup => {\n    if (!contactOrGroup || contactOrGroup.id === (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id)) {\n      console.log(\"Selection unchanged or invalid.\");\n      return; // Avoid re-selecting the same contact/group\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      navigate(\"/login\");\n      return;\n    }\n    console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id);\n\n    // Leave previous room\n    if (selectedContact) {\n      const roomToLeave = selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId;\n      if (roomToLeave) {\n        const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\";\n        socket.emit(eventName, roomToLeave);\n        console.log(`Left ${selectedContact.type} room:`, roomToLeave);\n      }\n    }\n\n    // Clear previous state\n    setMessages([]);\n    setMediaFiles([]);\n    setDocuments([]);\n    setSelectedContact(contactOrGroup); // Set selected contact immediately for UI update\n\n    try {\n      setLoading(true); // Show loading for message fetch\n\n      if (contactOrGroup.type === \"group\") {\n        const groupId = contactOrGroup.groupId;\n        // Sử dụng conversationId từ group object\n        const conversationId = contactOrGroup.conversationId || groupId;\n        socket.emit(\"join_group\", groupId);\n        console.log(\"Joined group room:\", groupId);\n        console.log(\"Using conversationId for group:\", conversationId);\n        await fetchMessages(token, conversationId, true);\n      } else {\n        // Handle individual contact\n        let conversationId = contactOrGroup.conversationId;\n\n        // If conversationId is missing, try to fetch/create it\n        if (!conversationId) {\n          console.log(\"Conversation ID missing, attempting to fetch/create...\");\n          try {\n            conversationId = await createOrGetConversation(contactOrGroup.id, token);\n            // Update the contact in the list and the selected contact state\n            const updatedContact = {\n              ...contactOrGroup,\n              conversationId\n            };\n            setSelectedContact(updatedContact); // Update selected state with new ID\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? updatedContact : c));\n            // Optionally save updated contacts list to localStorage\n            const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n            const updatedContactsList = currentContacts.map(c => c.id === contactOrGroup.id ? updatedContact : c);\n            localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList));\n          } catch (error) {\n            showError(error.message); // Show error from createOrGetConversation\n            setSelectedContact(null); // Deselect if conversation fails\n            setLoading(false);\n            return; // Stop execution if conversation fails\n          }\n        }\n        if (conversationId) {\n          socket.emit(\"join_conversation\", conversationId);\n          console.log(\"Joined conversation room:\", conversationId);\n          await fetchMessages(token, conversationId, false);\n\n          // Mark conversation as read with proper request body\n          try {\n            await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, {\n              read: true\n            }, token);\n\n            // Update contacts list to remove unread badge\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? {\n              ...c,\n              unreadCount: 0\n            } : c));\n          } catch (readError) {\n            console.error(\"Error marking conversation as read:\", readError);\n            // Don't show error to user since this is a non-critical operation\n          }\n        } else {\n          // This case should ideally not be reached if createOrGetConversation throws errors\n          showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\");\n          setSelectedContact(null);\n        }\n      }\n    } catch (error) {\n      // Catch errors from fetchMessages or socket emits\n      console.error(\"Error in handleContactSelect processing:\", error);\n      showError(`Lỗi khi chọn liên hệ: ${error.message}`);\n      setSelectedContact(null); // Deselect on error\n    } finally {\n      setLoading(false); // Ensure loading is turned off\n    }\n  }, [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages]);\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(async e => {\n    e.preventDefault();\n    if (!newMessage.trim() || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n    const tempMessageId = `temp-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: newMessage,\n      time: messageTime,\n      senderId: user.id,\n      isSending: true // Indicate sending state\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    const messageToSend = newMessage; // Store message before clearing\n    setNewMessage(\"\"); // Clear input immediately\n    scrollToBottom(); // Scroll after adding optimistic message\n\n    try {\n      let response;\n      let messageDataForSocket;\n      if (selectedContact.type === \"group\") {\n        var _selectedContact$memb;\n        const groupId = selectedContact.groupId;\n        console.log(\"Attempting to send group message:\", {\n          groupId,\n          messageContent: messageToSend,\n          selectedContact\n        });\n        if (!groupId) {\n          throw new Error(\"GroupId is missing\");\n        }\n\n        // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n        if (!((_selectedContact$memb = selectedContact.memberIds) !== null && _selectedContact$memb !== void 0 && _selectedContact$memb.includes(user.id))) {\n          console.error(\"User not in group members:\", {\n            userId: user.id,\n            memberIds: selectedContact.memberIds,\n            members: selectedContact.members\n          });\n          throw new Error(\"Bạn không phải là thành viên của nhóm này\");\n        }\n        try {\n          response = await apiCall(\"post\", `/api/groups/${groupId}/messages`, {\n            content: messageToSend\n          }, token);\n          console.log(\"Group message API response:\", response);\n          if (!response) {\n            throw new Error(\"No response from server\");\n          }\n          if (!response.messageData) {\n            console.error(\"Invalid response structure:\", response);\n            throw new Error(\"Invalid response structure from server\");\n          }\n          const messageData = response.messageData;\n          messageDataForSocket = {\n            messageId: messageData.messageId,\n            groupId: groupId,\n            senderId: user.id,\n            senderName: user.name,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: messageData.createdAt || new Date().toISOString()\n          };\n          console.log(\"Emitting socket event with data:\", messageDataForSocket);\n          socket.emit(\"group_message\", messageDataForSocket);\n\n          // Update optimistic message with real ID and remove sending state\n          setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n            ...msg,\n            id: messageData.messageId,\n            isSending: false,\n            time: new Date(messageData.createdAt).toLocaleTimeString([], {\n              hour: \"2-digit\",\n              minute: \"2-digit\"\n            })\n          } : msg));\n        } catch (error) {\n          var _error$response3, _error$response4;\n          console.error(\"Error details:\", {\n            error,\n            groupId,\n            selectedContact,\n            user: {\n              id: user.id,\n              name: user.name\n            }\n          });\n          if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n            throw new Error(\"Không tìm thấy nhóm chat\");\n          } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403) {\n            throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\");\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        var _response$messageData, _response$messageData2;\n        // Handle individual contact message sending\n        const conversationId = selectedContact.conversationId;\n        if (!conversationId) {\n          throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\");\n        }\n        response = await apiCall(\"post\", \"/api/messages/send/text\", {\n          conversationId: conversationId,\n          content: messageToSend,\n          tempMessageId: tempMessageId // Add tempMessageId to help match response\n        }, token);\n        messageDataForSocket = {\n          messageId: ((_response$messageData = response.messageData) === null || _response$messageData === void 0 ? void 0 : _response$messageData.messageId) || response.messageId,\n          tempMessageId: tempMessageId,\n          // Include tempMessageId in socket event\n          conversationId: conversationId,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.id,\n          content: messageToSend,\n          type: \"text\",\n          createdAt: ((_response$messageData2 = response.messageData) === null || _response$messageData2 === void 0 ? void 0 : _response$messageData2.createdAt) || new Date().toISOString(),\n          time: messageTime // Include original time for matching\n        };\n        socket.emit(\"new_message\", messageDataForSocket);\n      }\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      showError(\"Không thể gửi tin nhắn: \" + error.message);\n      // Remove or mark optimistic message as failed\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n    }\n  }, [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(async (file, fileType = \"file\") => {\n    // fileType can be 'file', 'image', 'video'\n    if (!file || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n\n    // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`);\n      return;\n    }\n    if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n      showError(\"Chỉ chấp nhận file hình ảnh.\");\n      return;\n    }\n    if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n      showError(\"Chỉ chấp nhận file video.\");\n      return;\n    }\n\n    // Video duration check\n    let videoDuration = null;\n    if (fileType === \"video\") {\n      try {\n        const duration = await getVideoDuration(file);\n        if (duration > 90) {\n          showError(\"Video không được dài quá 90 giây.\");\n          return;\n        }\n        videoDuration = Math.round(duration);\n      } catch (err) {\n        showError(\"Không thể đọc thông tin video.\");\n        return;\n      }\n    }\n    const tempMessageId = `temp-file-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const tempUrl = URL.createObjectURL(file); // For optimistic UI\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: fileType === \"text\" ? file.name : tempUrl,\n      // Use tempUrl for image/video\n      time: messageTime,\n      senderId: user.id,\n      isSending: true,\n      isFile: fileType === \"file\",\n      isImage: fileType === \"image\",\n      isVideo: fileType === \"video\",\n      fileName: file.name,\n      fileType: file.type,\n      duration: videoDuration\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    scrollToBottom();\n    const formData = new FormData();\n    let apiUrl = \"\";\n    let apiKey = \"\"; // Key for the file in FormData\n\n    if (selectedContact.type === \"group\") {\n      const groupId = selectedContact.groupId;\n      formData.append(\"groupId\", groupId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = `/api/groups/${groupId}/images`;\n          apiKey = \"image\"; // Match backend key\n          break;\n        case \"video\":\n          apiUrl = `/api/groups/${groupId}/videos`;\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = `/api/groups/${groupId}/files`;\n          apiKey = \"file\";\n          break;\n      }\n    } else {\n      const conversationId = selectedContact.conversationId;\n      if (!conversationId) {\n        showError(\"Không tìm thấy cuộc trò chuyện để gửi file\");\n        URL.revokeObjectURL(tempUrl);\n        setMessages(prev => prev.filter(msg => msg.id !== tempMessageId)); // Remove optimistic msg\n        return;\n      }\n      formData.append(\"conversationId\", conversationId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = \"/api/messages/send/image\";\n          apiKey = \"images\"; // Match backend key (plural for this endpoint)\n          break;\n        case \"video\":\n          apiUrl = \"/api/messages/send/video\";\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = \"/api/messages/send/file\";\n          apiKey = \"file\";\n          break;\n      }\n    }\n    formData.append(apiKey, file);\n    try {\n      var _messageData$attachme;\n      const response = await apiCall(\"post\", apiUrl, formData, token);\n      const messageData = response.messageData || response; // Adjust based on API response structure\n      const attachment = (_messageData$attachme = messageData.attachments) === null || _messageData$attachme === void 0 ? void 0 : _messageData$attachme[0];\n      if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n        throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\");\n      }\n\n      // Update optimistic message\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        id: messageData.messageId,\n        content: attachment.url,\n        // Use final URL\n        fileUrl: fileType === \"file\" ? attachment.url : null,\n        isSending: false,\n        time: new Date(messageData.createdAt).toLocaleTimeString([], {\n          hour: \"2-digit\",\n          minute: \"2-digit\"\n        })\n      } : msg));\n\n      // Update media/documents list\n      const newItem = {\n        id: messageData.messageId,\n        type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n        url: attachment.url,\n        name: attachment.name || file.name,\n        date: new Date(messageData.createdAt).toLocaleDateString(),\n        size: attachment.size || file.size,\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      if (fileType === \"image\" || fileType === \"video\") {\n        setMediaFiles(prev => [newItem, ...prev]); // Add to beginning (newest)\n      } else {\n        setDocuments(prev => [newItem, ...prev]);\n      }\n\n      // Emit socket event\n      const socketEventData = {\n        messageId: messageData.messageId,\n        conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n        groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n        senderId: user.id,\n        senderName: user.name,\n        receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n        type: fileType,\n        // 'file', 'image', 'video'\n        content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null,\n        // Content might be null for media\n        attachments: messageData.attachments,\n        createdAt: messageData.createdAt || new Date().toISOString(),\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\";\n      socket.emit(socketEventName, socketEventData);\n      URL.revokeObjectURL(tempUrl); // Clean up temp URL\n    } catch (error) {\n      console.error(`Error sending ${fileType}:`, error);\n      showError(`Không thể gửi ${fileType}: ${error.message}`);\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n      URL.revokeObjectURL(tempUrl);\n    }\n  }, [isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n  const getVideoDuration = file => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\");\n      video.preload = \"metadata\";\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src);\n        resolve(video.duration);\n      };\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src);\n        reject(new Error(\"Không thể tải metadata video\"));\n      };\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback(emoji => {\n    setNewMessage(prev => prev + emoji);\n    setShowEmojiPicker(false);\n  }, []);\n  const handleMessageAction = useCallback(async (messageId, action) => {\n    if (action === \"delete\") {\n      const token = localStorage.getItem(\"token\");\n      if (!token || !selectedContact) return;\n\n      // Optimistic UI update\n      const originalMessages = [...messages];\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        content: \"Đang xóa...\",\n        isUnsent: true,\n        isDeleting: true\n      } : msg));\n      try {\n        if (selectedContact.type === \"group\") {\n          await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, undefined, token);\n        } else {\n          await apiCall(\"delete\", `/api/messages/${messageId}`, undefined, token);\n        }\n\n        // Confirm deletion in UI\n        setMessages(prev => prev.map(msg => msg.id === messageId ? {\n          ...msg,\n          content: \"Tin nhắn đã bị xóa\",\n          isDeleting: false\n        } : msg));\n\n        // Remove from media/documents lists\n        setMediaFiles(prev => prev.filter(media => media.id !== messageId));\n        setDocuments(prev => prev.filter(doc => doc.id !== messageId));\n\n        // TODO: Emit socket event for deletion if needed by backend/other clients\n      } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        showError(\"Không thể xóa tin nhắn: \" + error.message);\n        // Revert optimistic update on error\n        setMessages(originalMessages);\n      }\n    }\n    // Handle other actions like 'recall' if implemented\n  }, [apiCall, selectedContact, showError, messages] // Include messages in dependency array\n  );\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true);\n    setShowFiles(false);\n  }, []);\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false);\n    setShowFiles(true);\n  }, []);\n  const handleTabChange = useCallback(tab => {\n    setActiveTab(tab);\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchFriendRequests(token);\n      }\n    }\n  }, [fetchFriendRequests]); // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null\n    });\n    setShowProfileModal(true);\n  }, [user.name, user.avatar]); // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false);\n  }, []);\n  const handleAvatarChange = useCallback(async file => {\n    // File validation\n    if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n      showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const formData = new FormData();\n    formData.append(\"avatar\", file);\n    try {\n      setLoading(true); // Indicate loading\n      const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token);\n      // Update state optimistically/realistically\n      setProfileData(prev => ({\n        ...prev,\n        avatarUrl: response.avatarUrl\n      }));\n      setUser(prev => ({\n        ...prev,\n        avatar: response.avatarUrl\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.avatarUrl = response.avatarUrl;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật ảnh đại diện thành công!\");\n    } catch (error) {\n      showError(\"Không thể tải avatar: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError]);\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    try {\n      setLoading(true);\n      const response = await apiCall(\"put\", \"/api/users/profile\", {\n        fullName: profileData.fullName,\n        // Ensure birthdate is sent correctly or omitted if empty\n        birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n        gender: profileData.gender || undefined // Send undefined if empty to potentially clear it\n      }, token);\n      // Update user state\n      setUser(prev => ({\n        ...prev,\n        name: response.fullName || prev.name\n        // Avatar might not be in this response, keep existing one\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.fullName = response.fullName;\n      userProfile.birthdate = response.birthdate;\n      userProfile.gender = response.gender;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật hồ sơ thành công!\");\n      handleCloseProfileModal();\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal]);\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true);\n  }, []);\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false);\n    setFriendEmail(\"\"); // Reset email field\n  }, []);\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\");\n      return;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      var _searchResult$data;\n      // Search user first to get ID\n      const searchResult = await apiCall(\"get\", `/api/users/search?query=${encodeURIComponent(friendEmail)}`, null, token);\n      if (!(searchResult !== null && searchResult !== void 0 && (_searchResult$data = searchResult.data) !== null && _searchResult$data !== void 0 && _searchResult$data.length)) {\n        throw new Error(\"Không tìm thấy người dùng với email này\");\n      }\n      const receiverId = searchResult.data[0].userId;\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\");\n      }\n\n      // Check if already friends\n      if (contacts.some(c => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\");\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", {\n        receiverId,\n        message: `Kết bạn từ ${user.name}`\n      }, token);\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`);\n      handleCloseAddFriendModal();\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`);\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`);\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`);\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`);\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false);\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts]);\n  const handleRespondToFriendRequest = useCallback(async (requestId, action) => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const request = friendRequests.find(req => req.requestId === requestId);\n    if (!request) return;\n    setLoading(true); // Indicate processing\n    // Optimistically remove from list\n    setFriendRequests(prev => prev.filter(req => req.requestId !== requestId));\n    try {\n      const response = await apiCall(\"post\", \"/api/friends/requests/respond\", {\n        requestId,\n        action\n      }, token);\n      console.log(\"Friend request response:\", response);\n      if (action === \"accept\") {\n        var _response$conversatio2, _senderInfo$email;\n        showError(\"Đã chấp nhận lời mời kết bạn\");\n        const senderInfo = request.sender;\n        if (!senderInfo || !senderInfo.userId) {\n          throw new Error(\"Thông tin người gửi không hợp lệ\");\n        }\n\n        // Get conversation ID (might be in response or need creation)\n        let conversationId = (_response$conversatio2 = response.conversation) === null || _response$conversatio2 === void 0 ? void 0 : _response$conversatio2.conversationId;\n        if (!conversationId) {\n          console.log(\"No conversationId in response, creating/getting...\");\n          conversationId = await createOrGetConversation(senderInfo.userId, token);\n        }\n        if (!conversationId) {\n          throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\");\n        }\n\n        // Create new contact object\n        const newContact = {\n          id: senderInfo.userId,\n          name: senderInfo.fullName || ((_senderInfo$email = senderInfo.email) === null || _senderInfo$email === void 0 ? void 0 : _senderInfo$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: senderInfo.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          conversationId: conversationId\n        };\n        addOrUpdateContact(newContact); // Add/update contact list and localStorage\n\n        // Optionally select the new contact immediately\n        // handleContactSelect(newContact);\n\n        // Emit notification to the sender via socket\n        if (socket.connected) {\n          socket.emit(\"friend_request_accepted_notify\", {\n            accepter: {\n              userId: user.id,\n              fullName: user.name,\n              avatarUrl: user.avatar\n            },\n            senderId: senderInfo.userId,\n            // Target the sender\n            conversationId: conversationId\n          });\n          // Also tell sender to refresh their list\n          socket.emit(\"refresh_contacts_notify\", {\n            targetUserId: senderInfo.userId\n          });\n          console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\");\n        }\n      } else {\n        showError(\"Đã từ chối lời mời kết bạn\");\n        // Optionally notify sender of rejection via socket\n      }\n    } catch (error) {\n      console.error(\"Error responding to friend request:\", error);\n      showError(\"Không thể phản hồi lời mời: \" + error.message);\n      // Revert optimistic removal on error\n      setFriendRequests(prev => [...prev, request]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleRemoveFriend = useCallback(async friendId => {\n    if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    console.log(`Attempting to remove friend with ID: ${friendId}`);\n    setLoading(true);\n\n    // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n    const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\");\n    if (!contactToRemove) {\n      showError(\"Không tìm thấy người dùng trong danh sách bạn bè\");\n      setLoading(false);\n      return;\n    }\n\n    // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n    const currentContacts = [...contacts];\n    try {\n      // Cập nhật UI trước khi gọi API (optimistic update)\n      setContacts(prev => prev.filter(contact => contact.id !== friendId || contact.type !== \"contact\"));\n\n      // Cập nhật localStorage\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const updatedContacts = savedContacts.filter(c => c.id !== friendId || c.type !== \"contact\");\n        localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts));\n      } catch (e) {\n        console.error(\"Error updating localStorage after friend removal\", e);\n      }\n\n      // Bỏ chọn nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === friendId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n\n      // Gọi API để xóa bạn bè\n      try {\n        console.log(`Calling API to remove friend: ${friendId}`);\n        const response = await apiCall(\"delete\", `/api/friends/${friendId}`, undefined, token);\n        console.log(\"Friend removal API response:\", response);\n        showError(\"Đã xóa bạn bè thành công\");\n\n        // Thông báo cho người bạn bị xóa qua socket\n        if (socket && socket.connected) {\n          socket.emit(\"friend_removed_notify\", {\n            removerId: user.id,\n            removedUserId: friendId\n          });\n          console.log(\"Emitted friend_removed_notify\");\n\n          // Thông báo cập nhật danh sách bạn bè\n          socket.emit(\"friend_list_updated\");\n        }\n\n        // Cập nhật lại danh sách bạn bè từ server\n        fetchContactsAndGroups(token);\n      } catch (apiError) {\n        console.error(\"API error removing friend:\", apiError);\n\n        // Kiểm tra lỗi cụ thể\n        if (apiError.response && apiError.response.status === 404) {\n          // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n          showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\");\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token);\n        } else {\n          // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n          showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"));\n          // Khôi phục lại danh sách bạn bè\n          setContacts(currentContacts);\n\n          // Khôi phục localStorage\n          try {\n            localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n          } catch (e) {\n            console.error(\"Error restoring localStorage\", e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in handleRemoveFriend:\", error);\n      showError(\"Không thể xóa bạn bè: \" + error.message);\n\n      // Khôi phục lại danh sách bạn bè\n      setContacts(currentContacts);\n\n      // Khôi phục localStorage\n      try {\n        localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n      } catch (e) {\n        console.error(\"Error restoring localStorage\", e);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups]);\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true);\n  }, []);\n  const handleGroupCreated = useCallback(newGroupData => {\n    var _newGroupData$members;\n    console.log(\"Group created data:\", newGroupData);\n    const groupObject = {\n      groupId: newGroupData.groupId,\n      id: newGroupData.groupId,\n      // Add id for consistency\n      name: newGroupData.name,\n      avatar: newGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: newGroupData.adminId,\n      memberCount: ((_newGroupData$members = newGroupData.members) === null || _newGroupData$members === void 0 ? void 0 : _newGroupData$members.length) || 1,\n      // At least admin is a member\n      conversationId: newGroupData.conversationId || newGroupData.groupId,\n      createdAt: newGroupData.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    setShowCreateGroupModal(false);\n    showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`);\n    // Automatically select the new group\n    handleContactSelect(groupObject);\n  }, [addOrUpdateGroup, showError, handleContactSelect]);\n  const handleGroupInfo = useCallback(group => {\n    // Fetch full group details if necessary before showing modal\n    setSelectedGroup(group); // Pass the basic group info for now\n    setShowGroupInfoModal(true);\n    // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n  }, [] // No dependencies needed to just show the modal\n  );\n  const handleGroupUpdated = useCallback(updatedGroupData => {\n    var _updatedGroupData$mem;\n    console.log(\"Group updated data:\", updatedGroupData);\n    // Ensure the data structure matches what addOrUpdateGroup expects\n    const groupObject = {\n      groupId: updatedGroupData.groupId,\n      id: updatedGroupData.groupId,\n      name: updatedGroupData.name,\n      avatar: updatedGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: updatedGroupData.adminId,\n      memberCount: updatedGroupData.memberCount || ((_updatedGroupData$mem = updatedGroupData.members) === null || _updatedGroupData$mem === void 0 ? void 0 : _updatedGroupData$mem.length) || 0,\n      conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n      createdAt: updatedGroupData.createdAt\n      // Include other relevant fields if needed\n    };\n    addOrUpdateGroup(groupObject);\n    // Update selected contact if it's the one being edited\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupObject.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    setShowGroupInfoModal(false); // Close modal on success\n    showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleLeaveGroup = useCallback(async groupId => {\n    console.log(\"Leaving group:\", groupId);\n    if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      // Gọi API để rời nhóm\n      const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, undefined, token);\n      console.log(\"Leave group API response:\", response);\n\n      // Cập nhật UI sau khi API thành công\n      setGroups(prev => prev.filter(group => group.groupId !== groupId));\n\n      // Cập nhật localStorage\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after leaving group\", e);\n      }\n\n      // Bỏ chọn nhóm nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n      setShowGroupInfoModal(false); // Đóng modal\n      showError(\"Bạn đã rời khỏi nhóm thành công\");\n\n      // Thông báo qua socket nếu cần\n      if (socket.connected) {\n        socket.emit(\"left_group\", {\n          groupId\n        });\n      }\n    } catch (error) {\n      console.error(\"Error leaving group:\", error);\n      showError(\"Không thể rời khỏi nhóm: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedContact, showError, apiCall]);\n  const handleDeleteGroup = useCallback(groupId => {\n    console.log(\"Deleting group:\", groupId);\n    setGroups(prev => prev.filter(group => group.groupId !== groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after deleting group\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    setShowGroupInfoModal(false); // Close modal\n    showError(\"Đã xóa nhóm thành công\");\n    // API call to delete group should be handled within GroupInfoModal or here before state update\n  }, [selectedContact, showError]);\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      navigate(\"/login\");\n      return;\n    }\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    let socketInitialized = false;\n    const initializeApp = async () => {\n      try {\n        setLoading(true);\n        const userProfile = await fetchUserProfile(token);\n        if (!userProfile || !isMounted) return; // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token);\n        if (!isMounted) return;\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token);\n        if (!isMounted) return;\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\");\n\n          // Set socket auth and query params\n          socket.auth = {\n            token\n          };\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now()\n          };\n\n          // Connect the socket\n          socket.connect();\n          socketInitialized = true;\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\");\n      socket.off(\"reconnect\");\n      socket.off(\"friend_request\");\n      socket.off(\"new_message\");\n      socket.off(\"receive_message\");\n      socket.off(\"group_message\");\n      socket.off(\"friend_request_accepted\");\n      socket.off(\"friend_removed\");\n      socket.off(\"refresh_contacts\");\n      socket.off(\"notification\");\n      socket.off(\"group_created\");\n      socket.off(\"group_updated\");\n      socket.off(\"group_deleted\");\n      socket.off(\"member_added\");\n      socket.off(\"member_removed\");\n    };\n  }, [navigate]); // Only depend on navigate\n\n  // Khi khởi tạo component, đọc cache từ localStorage\n  useEffect(() => {\n    // ... các logic khác\n    const cache = localStorage.getItem('cachedMessages');\n    if (cache) {\n      setCachedMessages(JSON.parse(cache));\n    }\n  }, [navigate]);\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback(data => {\n    var _data$attachments, _data$attachments$, _data$attachments2, _data$attachments2$, _data$attachments3, _data$attachments3$, _data$attachments4, _data$attachments4$, _data$attachments5, _data$attachments5$;\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || !data.messageId && !data.id) {\n      console.error(\"Invalid message data received:\", data);\n      return;\n    }\n    const messageTime = data.createdAt ? new Date(data.createdAt).toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }) : new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString();\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type,\n      selectedContactGroupId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.groupId,\n      selectedContactConversationId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.conversationId\n    });\n    const isCurrentChat = (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\" && selectedContact.groupId === data.groupId || (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\" && selectedContact.conversationId === data.conversationId;\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content: data.isRecalled || data.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\" ? data.content : ((_data$attachments = data.attachments) === null || _data$attachments === void 0 ? void 0 : (_data$attachments$ = _data$attachments[0]) === null || _data$attachments$ === void 0 ? void 0 : _data$attachments$.url) || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: data.type === \"image\" || data.type === \"imageGroup\",\n      isVideo: data.type === \"video\",\n      isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: data.type === \"file\" ? (_data$attachments2 = data.attachments) === null || _data$attachments2 === void 0 ? void 0 : (_data$attachments2$ = _data$attachments2[0]) === null || _data$attachments2$ === void 0 ? void 0 : _data$attachments2$.url : null,\n      fileName: data.type === \"file\" ? (_data$attachments3 = data.attachments) === null || _data$attachments3 === void 0 ? void 0 : (_data$attachments3$ = _data$attachments3[0]) === null || _data$attachments3$ === void 0 ? void 0 : _data$attachments3$.name : null,\n      fileType: data.type === \"file\" ? (_data$attachments4 = data.attachments) === null || _data$attachments4 === void 0 ? void 0 : (_data$attachments4$ = _data$attachments4[0]) === null || _data$attachments4$ === void 0 ? void 0 : _data$attachments4$.type : null,\n      duration: data.type === \"video\" ? ((_data$attachments5 = data.attachments) === null || _data$attachments5 === void 0 ? void 0 : (_data$attachments5$ = _data$attachments5[0]) === null || _data$attachments5$ === void 0 ? void 0 : _data$attachments5$.duration) || data.duration : null,\n      messageDate: messageDate\n    };\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || [];\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev;\n        const updated = {\n          ...prev,\n          [data.conversationId]: [...prevList, newMessage]\n        };\n        // Lưu vào localStorage\n        localStorage.setItem('cachedMessages', JSON.stringify(updated));\n        console.log('>>> Updated cachedMessages:', updated);\n        return updated;\n      });\n    }\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        if (exists) return prev;\n        return [...prev, newMessage];\n      });\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles(prev => {\n          var _data$attachments6, _data$attachments6$;\n          return [{\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: ((_data$attachments6 = data.attachments) === null || _data$attachments6 === void 0 ? void 0 : (_data$attachments6$ = _data$attachments6[0]) === null || _data$attachments6$ === void 0 ? void 0 : _data$attachments6$.size) || 0,\n            duration: newMessage.duration\n          }, ...prev // Add to beginning\n          ];\n        });\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments(prev => {\n          var _newMessage$fileName, _data$attachments7, _data$attachments7$;\n          return [{\n            id: newMessage.id,\n            type: ((_newMessage$fileName = newMessage.fileName) === null || _newMessage$fileName === void 0 ? void 0 : _newMessage$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: ((_data$attachments7 = data.attachments) === null || _data$attachments7 === void 0 ? void 0 : (_data$attachments7$ = _data$attachments7[0]) === null || _data$attachments7$ === void 0 ? void 0 : _data$attachments7$.size) || 0\n          }, ...prev // Add to beginning\n          ];\n        });\n      }\n    } else {\n      var _data$content, _data$content2;\n      // Notification for message in other chat\n      let senderName = \"Người dùng\";\n      let contactId = data.senderId; // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find(g => g.groupId === data.groupId);\n        senderName = `${data.senderName || \"Ai đó\"} (${(group === null || group === void 0 ? void 0 : group.name) || \"Nhóm\"})`;\n      } else {\n        const contact = contacts.find(c => c.id === data.senderId); // Tìm contact dựa trên senderId\n        senderName = (contact === null || contact === void 0 ? void 0 : contact.name) || data.senderName || \"Ai đó\";\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n      const preview = data.type === \"text\" ? ((_data$content = data.content) === null || _data$content === void 0 ? void 0 : _data$content.substring(0, 30)) + (((_data$content2 = data.content) === null || _data$content2 === void 0 ? void 0 : _data$content2.length) > 30 ? \"...\" : \"\") : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`;\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`);\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview,\n              // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(c => c.conversationId === data.conversationId || c.id === data.senderId);\n        if (foundContact) {\n          setSelectedContact(foundContact);\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || []);\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      var _contacts$find, _groups$find;\n      const contactName = data.senderName || \"Người dùng\";\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: ((_contacts$find = contacts.find(c => c.id === data.senderId)) === null || _contacts$find === void 0 ? void 0 : _contacts$find.avatar) || ((_groups$find = groups.find(g => g.groupId === data.groupId)) === null || _groups$find === void 0 ? void 0 : _groups$find.avatar) || \"/favicon.ico\" // Optional icon\n      });\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages]);\n  const handleFriendRequest = useCallback(data => {\n    if (!data || !data.requestId || !data.sender) return;\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab]);\n  const handleFriendRequestAccepted = useCallback(data => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\");\n      return;\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleFriendRemoved = useCallback(data => {\n    if (!data || !data.removerId) return;\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError]);\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\");\n    if (token) {\n      fetchContactsAndGroups(token);\n    }\n  }, [fetchContactsAndGroups]);\n  const handleSocketGroupCreated = useCallback(data => {\n    var _group$members3;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_created event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: ((_group$members3 = group.members) === null || _group$members3 === void 0 ? void 0 : _group$members3.length) || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`);\n  }, [addOrUpdateGroup, showError]);\n  const handleSocketGroupUpdated = useCallback(data => {\n    var _group$members4;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_updated event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members4 = group.members) === null || _group$members4 === void 0 ? void 0 : _group$members4.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleGroupDeleted = useCallback(data => {\n    var _groups$find2;\n    if (!(data !== null && data !== void 0 && data.groupId)) return;\n    console.log(\"Received group_deleted event:\", data.groupId);\n    const groupName = ((_groups$find2 = groups.find(g => g.groupId === data.groupId)) === null || _groups$find2 === void 0 ? void 0 : _groups$find2.name) || \"Một nhóm\";\n    setGroups(prev => prev.filter(group => group.groupId !== data.groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== data.groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after group delete\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === data.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`);\n  }, [groups, selectedContact, showError]);\n  const handleMemberAdded = useCallback(data => {\n    var _group$members5;\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.member) || !(data !== null && data !== void 0 && data.addedBy)) return;\n    console.log(\"Received member_added event:\", data);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members5 = group.members) === null || _group$members5 === void 0 ? void 0 : _group$members5.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleMemberRemoved = useCallback(data => {\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.memberId) || !(data !== null && data !== void 0 && data.removedBy)) return;\n    console.log(\"Received member_removed event:\", data);\n    const group = data.group;\n    const groupId = group.groupId;\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`);\n      setGroups(prev => prev.filter(g => g.groupId !== groupId));\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after being removed from group\", e);\n      }\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n    } else {\n      var _group$members6, _data$member;\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || ((_group$members6 = group.members) === null || _group$members6 === void 0 ? void 0 : _group$members6.length) || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt\n      };\n      addOrUpdateGroup(groupObject);\n      const memberName = ((_data$member = data.member) === null || _data$member === void 0 ? void 0 : _data$member.fullName) || \"một thành viên\";\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`);\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(groupObject);\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleNotification = useCallback(data => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data);\n      return;\n    }\n    if (data.type === \"success\") {\n      showError(data.message);\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\");\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\");\n    } else {\n      showError(data.message);\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchContactsAndGroups(token);\n      }\n    }\n  }, [showError, fetchContactsAndGroups]);\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true;\n    const handleConnect = () => {\n      if (!isMounted) return;\n      console.log(\"Socket re-connected inside hook.\");\n      setIsConnected(true);\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId);\n      }\n    };\n\n    // Add handler for message_sent event\n    const handleMessageSent = data => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data);\n        return;\n      }\n      console.log(\"Received message_sent_success event:\", data);\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n        // Match by tempMessageId if available\n        data.tempMessageId && msg.id === data.tempMessageId ||\n        // Or match by conversationId and content if tempMessageId not available\n        data.conversationId && msg.conversationId === data.conversationId && msg.content === data.content)) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          });\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          };\n        }\n        return msg;\n      }));\n    };\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect);\n    socket.on(\"message_sent_success\", handleMessageSent); // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage);\n    socket.on(\"receive_message\", handleNewMessage);\n    socket.on(\"group_message\", handleNewMessage);\n    socket.on(\"friend_request\", handleFriendRequest);\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted);\n    socket.on(\"friend_removed\", handleFriendRemoved);\n    socket.on(\"refresh_contacts\", handleRefreshContacts);\n    socket.on(\"notification\", handleNotification);\n    socket.on(\"group_created\", handleSocketGroupCreated);\n    socket.on(\"group_updated\", handleSocketGroupUpdated);\n    socket.on(\"group_deleted\", handleGroupDeleted);\n    socket.on(\"member_added\", handleMemberAdded);\n    socket.on(\"member_removed\", handleMemberRemoved);\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false;\n      socket.off(\"connect\", handleConnect);\n      socket.off(\"message_sent_success\", handleMessageSent); // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage);\n      socket.off(\"receive_message\", handleNewMessage);\n      socket.off(\"group_message\", handleNewMessage);\n      socket.off(\"friend_request\", handleFriendRequest);\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted);\n      socket.off(\"friend_removed\", handleFriendRemoved);\n      socket.off(\"refresh_contacts\", handleRefreshContacts);\n      socket.off(\"notification\", handleNotification);\n      socket.off(\"group_created\", handleSocketGroupCreated);\n      socket.off(\"group_updated\", handleSocketGroupUpdated);\n      socket.off(\"group_deleted\", handleGroupDeleted);\n      socket.off(\"member_added\", handleMemberAdded);\n      socket.off(\"member_removed\", handleMemberRemoved);\n    };\n  }, [handleNewMessage, handleFriendRequest, handleFriendRequestAccepted, handleFriendRemoved, handleRefreshContacts, handleNotification, handleSocketGroupCreated, handleSocketGroupUpdated, handleGroupDeleted, handleMemberAdded, handleMemberRemoved, selectedContact // Add selectedContact as dependency\n  ]);\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]); // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n      var _messagesEndRef$curre;\n      (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"end\"\n      });\n    }, 100);\n  };\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(contact => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const filteredGroups = groups.filter(group => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"]; // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts,\n    // Return full contacts list if needed elsewhere\n    groups,\n    // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab,\n    // Needed for friend request notification\n    setShowProfileModal,\n    // Needed for closing modal from component\n    setProfileData,\n    // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal,\n    // Needed for closing modal from component\n    setFriendEmail,\n    // Needed for form input\n    // setError, // Internal state\n    setShowToast,\n    // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal,\n    // Needed for closing modal from component\n    setShowGroupInfoModal,\n    // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile,\n    // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError,\n    // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\") // Pass token for Modals\n  };\n};\n_s(useChat, \"G51PC2RsFnfrsDmnqgaTpV73UBk=\", false, function () {\n  return [useNavigate];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useNavigate","axios","io","API_BASE_URL","socket","autoConnect","reconnection","reconnectionAttempts","Number","POSITIVE_INFINITY","reconnectionDelay","reconnectionDelayMax","timeout","transports","upgrade","forceNew","query","timestamp","Date","now","on","console","log","id","err","error","reason","window","originalConsoleError","args","includes","apply","useChat","_s","navigate","user","setUser","name","avatar","contacts","setContacts","groups","setGroups","selectedContact","setSelectedContact","messages","setMessages","newMessage","setNewMessage","isConnected","setIsConnected","connected","showEmojiPicker","setShowEmojiPicker","searchQuery","setSearchQuery","mediaFiles","setMediaFiles","documents","setDocuments","showMedia","setShowMedia","showFiles","setShowFiles","activeTab","setActiveTab","showProfileModal","setShowProfileModal","profileData","setProfileData","fullName","birthdate","gender","avatarUrl","loading","setLoading","showAddFriendModal","setShowAddFriendModal","friendEmail","setFriendEmail","setError","showToast","setShowToast","friendRequests","setFriendRequests","recoveredContacts","setRecoveredContacts","showCreateGroupModal","setShowCreateGroupModal","showGroupInfoModal","setShowGroupInfoModal","selectedGroup","setSelectedGroup","cachedMessages","setCachedMessages","messagesEndRef","fileInputRef","imageInputRef","videoInputRef","showError","message","apiCall","method","url","data","token","toUpperCase","FormData","config","headers","Authorization","Pragma","response","status","_error$response","_error$response2","_error$response2$data","localStorage","removeItem","Error","errorMessage","addOrUpdateContact","newContact","savedContacts","getItem","contactsArray","JSON","parse","filter","c","push","setItem","stringify","storageError","prev","exists","some","contact","map","addOrUpdateGroup","newGroup","groupId","savedGroups","groupsArray","g","group","fetchUserProfile","userData","userId","toISOString","split","fetchMessages","conversationId","isGroup","warn","endpoint","messagesData","Array","isArray","mappedMessages","msg","index","_msg$attachments","_msg$attachments$","_msg$attachments2","_msg$attachments$2","_msg$attachments3","_msg$attachments$3","_msg$attachments4","_msg$attachments$4","_msg$attachments5","_msg$attachments$5","messageId","sender","senderId","senderName","content","isRecalled","isDeleted","type","attachments","time","toLocaleTimeString","hour","minute","isImage","isVideo","isFile","isUnsent","isSystemMessage","fileUrl","length","fileName","fileType","duration","messageDate","toLocaleDateString","systemMessage","unshift","mergedMessages","cacheFromStorage","cacheList","newFromCache","cacheMsg","sort","a","b","aTime","createdAt","bTime","media","_msg$attachments6","_msg$attachments6$","date","size","reverse","files","_msg$fileName","_msg$attachments7","_msg$attachments7$","pop","toLowerCase","fetchContactsAndGroups","fetchedContacts","fetchedGroups","friendsResponse","confirmedFriends","friends","validFriends","friend","friendshipId","mappedFriends","_friend$email","email","convResponse","conversationsMap","Map","forEach","conv","participants","otherUserId","find","set","has","get","existingContactsMap","existingContact","groupsResponse","userGroups","members","member","_group$members","_group$members2","adminId","admin","memberIds","memberCount","e","fetchFriendRequests","createOrGetConversation","_response$conversatio","conversation","handleContactSelect","contactOrGroup","roomToLeave","eventName","emit","updatedContact","currentContacts","updatedContactsList","read","unreadCount","readError","handleSendMessage","preventDefault","trim","tempMessageId","messageTime","optimisticMessage","isSending","messageToSend","scrollToBottom","messageDataForSocket","_selectedContact$memb","messageContent","messageData","_error$response3","_error$response4","_response$messageData","_response$messageData2","receiverId","isError","handleSendFile","file","maxSize","startsWith","videoDuration","getVideoDuration","Math","round","tempUrl","URL","createObjectURL","formData","apiUrl","apiKey","append","revokeObjectURL","_messageData$attachme","attachment","newItem","socketEventData","socketEventName","Promise","resolve","reject","video","document","createElement","preload","onloadedmetadata","src","onerror","handleEmojiSelect","emoji","handleMessageAction","action","originalMessages","isDeleting","undefined","doc","toggleMediaView","toggleFilesView","handleTabChange","tab","handleProfileClick","userProfile","handleCloseProfileModal","handleAvatarChange","handleUpdateProfile","handleAddFriend","handleCloseAddFriendModal","handleSubmitAddFriend","emailRegex","test","_searchResult$data","searchResult","encodeURIComponent","handleRespondToFriendRequest","requestId","request","req","_response$conversatio2","_senderInfo$email","senderInfo","accepter","targetUserId","handleRemoveFriend","friendId","confirm","contactToRemove","updatedContacts","removerId","removedUserId","apiError","handleCreateGroup","handleGroupCreated","newGroupData","_newGroupData$members","groupObject","handleGroupInfo","handleGroupUpdated","updatedGroupData","_updatedGroupData$mem","handleLeaveGroup","updatedGroups","handleDeleteGroup","isMounted","socketInitialized","initializeApp","auth","opts","connect","off","cache","handleNewMessage","_data$attachments","_data$attachments$","_data$attachments2","_data$attachments2$","_data$attachments3","_data$attachments3$","_data$attachments4","_data$attachments4$","_data$attachments5","_data$attachments5$","selectedContactType","selectedContactGroupId","selectedContactConversationId","isCurrentChat","prevList","updated","_data$attachments6","_data$attachments6$","_newMessage$fileName","_data$attachments7","_data$attachments7$","_data$content","_data$content2","contactId","targetId","isGroupMessage","preview","substring","item","itemIdToMatch","lastMessage","lastMessageAt","foundContact","hidden","Notification","permission","_contacts$find","_groups$find","contactName","body","icon","handleFriendRequest","handleFriendRequestAccepted","handleFriendRemoved","handleRefreshContacts","handleSocketGroupCreated","_group$members3","handleSocketGroupUpdated","_group$members4","handleGroupDeleted","_groups$find2","groupName","handleMemberAdded","_group$members5","addedBy","handleMemberRemoved","memberId","removedBy","_group$members6","_data$member","memberName","handleNotification","refreshContacts","handleConnect","handleMessageSent","prevMessages","oldId","newId","setTimeout","_messagesEndRef$curre","current","scrollIntoView","behavior","block","filteredContacts","filteredGroups","emojis"],"sources":["C:/Users/ADMIN/Desktop/Nhom12_Zalo_Web/FE-WebAppZola/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\"\nimport { useNavigate } from \"react-router-dom\"\nimport axios from \"axios\"\nimport { io } from \"socket.io-client\"\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\"\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false, // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false, // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now(),\n  },\n})\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id)\n})\n\nsocket.on(\"connect_error\", (err) => {\n  console.error(\"Socket connection error:\", err)\n})\n\nsocket.on(\"disconnect\", (reason) => {\n  console.log(\"Socket disconnected:\", reason)\n})\n\nsocket.on(\"error\", (err) => {\n  console.error(\"Socket error:\", err)\n})\n\nsocket.on(\"reconnect_error\", (err) => {\n  console.error(\"Socket reconnection error:\", err)\n})\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error\n  console.error = (...args) => {\n    if (\n      args[0] &&\n      typeof args[0] === \"string\" &&\n      (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))\n    ) {\n      return\n    }\n    originalConsoleError.apply(console, args)\n  }\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  const navigate = useNavigate()\n\n  // State Management\n  const [user, setUser] = useState({ id: \"\", name: \"User\", avatar: \"\" })\n  const [contacts, setContacts] = useState([])\n  const [groups, setGroups] = useState([])\n  const [selectedContact, setSelectedContact] = useState(null)\n  const [messages, setMessages] = useState([])\n  const [newMessage, setNewMessage] = useState(\"\")\n  const [isConnected, setIsConnected] = useState(socket.connected) // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false)\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [mediaFiles, setMediaFiles] = useState([])\n  const [documents, setDocuments] = useState([])\n  const [showMedia, setShowMedia] = useState(true)\n  const [showFiles, setShowFiles] = useState(false)\n  const [activeTab, setActiveTab] = useState(\"chat\")\n  const [showProfileModal, setShowProfileModal] = useState(false)\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null,\n  })\n  const [loading, setLoading] = useState(false)\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false)\n  const [friendEmail, setFriendEmail] = useState(\"\")\n  const [error, setError] = useState(null)\n  const [showToast, setShowToast] = useState(false)\n  const [friendRequests, setFriendRequests] = useState([])\n  const [recoveredContacts, setRecoveredContacts] = useState([]) // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false)\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false)\n  const [selectedGroup, setSelectedGroup] = useState(null)\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({})\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null)\n  const fileInputRef = useRef(null)\n  const imageInputRef = useRef(null)\n  const videoInputRef = useRef(null)\n\n  // --- Utility Functions ---\n\n  const showError = useCallback((message) => {\n    console.log(\"Showing Toast:\", message)\n    setError(message)\n    setShowToast(true)\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, [])\n\n  const apiCall = useCallback(\n    async (method, url, data = null, token) => {\n      try {\n        console.log(`API Call: ${method.toUpperCase()} ${url}`)\n        if (data) {\n          console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data)\n        }\n\n        const config = {\n          method,\n          url: `${API_BASE_URL}${url}`,\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n            \"If-None-Match\": \"\", // Prevent 304 responses\n          },\n          data,\n        }\n\n        if (!(data instanceof FormData)) {\n          config.headers[\"Content-Type\"] = \"application/json\"\n        }\n\n        console.log(\"Using config:\", {\n          method: config.method,\n          url: config.url,\n          headers: { ...config.headers, Authorization: \"Bearer [HIDDEN]\" },\n        })\n\n        const response = await axios(config)\n        console.log(`API Response ${url}:`, response.status, response.data)\n        return response.data\n      } catch (error) {\n        console.error(`API Error ${url}:`, error)\n        if (error.response) {\n          console.error(\"Response status:\", error.response.status)\n          console.error(\"Response data:\", error.response.data)\n        }\n\n        if (error.response?.status === 401) {\n          localStorage.removeItem(\"token\")\n          localStorage.removeItem(\"userProfile\") // Clear profile too\n          navigate(\"/login\")\n          // Use showError for consistency\n          showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\")\n          throw new Error(\"Phiên đăng nhập hết hạn.\") // Throw to stop further execution\n        }\n\n        const errorMessage = error.response?.data?.message || error.message || \"Đã xảy ra lỗi không xác định\"\n        // Don't automatically show toast here, let the calling function decide\n        // showError(errorMessage);\n        throw new Error(errorMessage)\n      }\n    },\n    [navigate, showError],\n  ) // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback((newContact) => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact)\n      return\n    }\n    console.log(\"Adding or updating contact:\", newContact)\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\")\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : []\n      contactsArray = contactsArray.filter((c) => c.id !== newContact.id)\n      contactsArray.push(newContact)\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray))\n      console.log(\"Saved contact to localStorage:\", newContact.id)\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError)\n    }\n    setContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n  }, [])\n\n  const addOrUpdateGroup = useCallback((newGroup) => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup)\n      return\n    }\n    console.log(\"Adding or updating group:\", newGroup)\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\")\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : []\n      groupsArray = groupsArray.filter((g) => g.groupId !== newGroup.groupId)\n      groupsArray.push(newGroup)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray))\n      console.log(\"Saved group to localStorage:\", newGroup.groupId)\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError)\n    }\n    setGroups((prev) => {\n      const exists = prev.some((group) => group.groupId === newGroup.groupId)\n      if (exists) {\n        return prev.map((group) => (group.groupId === newGroup.groupId ? { ...group, ...newGroup } : group))\n      }\n      return [...prev, newGroup]\n    })\n  }, [])\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(\n    async (token) => {\n      try {\n        const response = await apiCall(\"get\", \"/api/users/profile\", null, token)\n        const userData = {\n          id: response.userId,\n          name: response.fullName || \"User\",\n          avatar: response.avatarUrl || \"\",\n        }\n        setUser(userData)\n        setProfileData({\n          fullName: response.fullName || \"\",\n          birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n          gender: response.gender || \"\",\n          avatarUrl: response.avatarUrl || null,\n        })\n        // Save profile to localStorage after fetching\n        localStorage.setItem(\"userProfile\", JSON.stringify(response))\n        return response // Return the full profile\n      } catch (error) {\n        console.error(\"Error fetching user profile:\", error)\n        showError(\"Không thể lấy thông tin người dùng: \" + error.message)\n        // No need to navigate here, apiCall handles 401\n        return null\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const fetchMessages = useCallback(\n    async (token, conversationId, isGroup = false) => {\n      if (!token || !conversationId) {\n        console.warn(\"fetchMessages called without token or conversationId\")\n        setMessages([]) // Clear messages if no ID\n        setMediaFiles([])\n        setDocuments([])\n        return\n      }\n      setLoading(true) // Indicate loading messages\n      try {\n        let response\n        // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n        const endpoint = `/api/messages/conversations/${conversationId}/messages`\n\n        console.log(\"Fetching messages from endpoint:\", endpoint)\n        response = await apiCall(\"get\", endpoint, null, token)\n        console.log(\"Messages API response:\", response)\n\n        const messagesData = Array.isArray(response) ? response : response.data || []\n\n        const mappedMessages = messagesData\n          .map((msg, index) => ({\n              id: msg.messageId || `temp-${Date.now()}-${index}`,\n              sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n              content:\n                msg.isRecalled || msg.isDeleted\n                  ? \"Tin nhắn đã bị thu hồi/xóa\"\n                  : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\"\n                    ? msg.content\n                    : msg.attachments?.[0]?.url || msg.content || \"\", // Ensure content exists\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n              senderId: msg.senderId,\n              isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n              isVideo: msg.type === \"video\",\n              isFile: msg.type === \"file\",\n              isUnsent: msg.isRecalled || msg.isDeleted,\n              isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n              fileUrl: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.url : null,\n              fileName: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.name : null,\n              fileType: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.type : null,\n              duration: msg.type === \"video\" && msg.attachments?.length > 0 ? msg.attachments[0]?.duration : null,\n            messageDate: new Date().toLocaleDateString(), // Used for media/files list\n          }))\n          .filter((msg) => msg.id) // Filter out messages without an ID\n\n        // Add system message if needed\n        if (mappedMessages.length === 0 || !mappedMessages.some((msg) => msg.isSystemMessage)) {\n          const systemMessage = isGroup\n            ? \"Chào mừng bạn đến với nhóm chat!\"\n            : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\"\n          mappedMessages.unshift({\n            id: `system-${Date.now()}`,\n            senderId: \"system\",\n            content: systemMessage,\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            isSystemMessage: true,\n          })\n        }\n\n        // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n        let mergedMessages = mappedMessages\n        // Lấy cache mới nhất từ localStorage thay vì chỉ lấy từ state\n        const cacheFromStorage = JSON.parse(localStorage.getItem('cachedMessages') || '{}')\n        const cacheList = cacheFromStorage[conversationId] || []\n        console.log('Cache for this conversation:', cacheList)\n        const newFromCache = cacheList.filter(\n          cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id)\n        )\n        mergedMessages = [...mappedMessages, ...newFromCache]\n        // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n        mergedMessages.sort((a, b) => {\n          const aTime = new Date(a.createdAt || a.time || a.messageDate)\n          const bTime = new Date(b.createdAt || b.time || b.messageDate)\n          return aTime - bTime\n        })\n        console.log('Merged messages after cache merge:', mergedMessages)\n        setMessages(mergedMessages)\n\n        // Update Media and Documents\n        const media = mappedMessages\n          .filter((msg) => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.isImage ? \"image\" : \"video\",\n            url: msg.content,\n            name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0, // Might not be available, default to 0\n            duration: msg.duration,\n          }))\n        setMediaFiles(media.reverse()) // Show newest first\n\n        const files = mappedMessages\n          .filter((msg) => msg.isFile && !msg.isUnsent && msg.fileUrl)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: msg.fileUrl,\n            name: msg.fileName,\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0,\n          }))\n        setDocuments(files.reverse()) // Show newest first\n      } catch (error) {\n        console.error(\"Error fetching messages:\", error)\n        showError(\"Không thể tải tin nhắn: \" + error.message)\n        setMessages([]) // Clear messages on error\n        setMediaFiles([])\n        setDocuments([])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id to compare sender\n  )\n\n  const fetchContactsAndGroups = useCallback(\n    async (token) => {\n      if (!token) return { contacts: [], groups: [] }\n      setLoading(true)\n      let fetchedContacts = []\n      let fetchedGroups = []\n\n      try {\n        // Fetch Friends (Contacts) from server first\n        console.log(\"Fetching friends from server...\")\n        const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token)\n        console.log(\"Friends API response:\", friendsResponse)\n\n        // Lọc ra những người bạn đã được xác nhận\n        // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n        const confirmedFriends = friendsResponse?.friends || []\n        console.log(\"Confirmed friends:\", confirmedFriends)\n\n        // Kiểm tra xem danh sách bạn bè có hợp lệ không\n        const validFriends = confirmedFriends.filter(friend =>\n          friend && friend.userId && friend.friendshipId\n        )\n\n        if (validFriends.length !== confirmedFriends.length) {\n          console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`)\n        }\n\n        const mappedFriends = validFriends.map((friend) => ({\n          id: friend.userId,\n          name: friend.fullName || friend.email?.split(\"@\")[0] || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\", // Trạng thái mặc định\n          friendshipId: friend.friendshipId, // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null, // Will be populated later\n        }))\n\n        // Fetch Conversations to get conversation IDs\n        console.log(\"Fetching conversations...\")\n        const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token)\n        const conversationsMap = new Map()\n        if (convResponse && Array.isArray(convResponse)) {\n          convResponse.forEach((conv) => {\n            if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n              const otherUserId = conv.participants.find((id) => id !== user.id)\n              if (otherUserId) {\n                conversationsMap.set(otherUserId, conv.conversationId)\n              }\n            }\n          })\n        }\n\n        // Update conversationId for mapped friends\n        mappedFriends.forEach((friend) => {\n          if (conversationsMap.has(friend.id)) {\n            friend.conversationId = conversationsMap.get(friend.id)\n          }\n        })\n\n        // Merge with existing contacts to preserve any additional data\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n\n        // Create a map of existing contacts for quick lookup\n        const existingContactsMap = new Map()\n        savedContacts.forEach(contact => {\n          if (contact && contact.id) {\n            existingContactsMap.set(contact.id, contact)\n          }\n        })\n\n        // Merge server data with existing data, prioritizing server data\n        fetchedContacts = mappedFriends.map(friend => {\n          const existingContact = existingContactsMap.get(friend.id)\n          if (existingContact) {\n            // Preserve conversationId if it exists in saved contact but not in server data\n            if (!friend.conversationId && existingContact.conversationId) {\n              friend.conversationId = existingContact.conversationId\n            }\n            return { ...existingContact, ...friend }\n          }\n          return friend\n        })\n\n        // Update state and localStorage\n        setContacts(fetchedContacts)\n        localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts))\n        console.log(\"Updated contacts from API:\", fetchedContacts.length)\n\n        // Fetch Groups\n        console.log(\"Fetching groups...\")\n        const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token)\n        console.log(\"Groups API response:\", groupsResponse)\n\n        if (groupsResponse && groupsResponse.groups) {\n          // Lọc các nhóm mà người dùng là thành viên\n          const userGroups = groupsResponse.groups.filter(\n            (group) => group.members && group.members.some(member => member.userId === user.id)\n          )\n          console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`)\n\n          fetchedGroups = userGroups.map((group) => ({\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [], // Lưu toàn bộ thông tin thành viên\n            memberIds: group.members?.map(member => member.userId) || [], // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || group.members?.length || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt,\n          }))\n          setGroups(fetchedGroups)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups))\n          console.log(\"Updated groups from API:\", fetchedGroups.length)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } catch (error) {\n        console.error(\"Error fetching contacts/groups:\", error)\n        showError(\"Không thể tải danh bạ/nhóm: \" + error.message)\n\n        // Fallback to localStorage only if server fetch fails\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n\n          if (savedContacts.length > 0) {\n            console.log(\"Falling back to contacts from localStorage\")\n            setContacts(savedContacts)\n            fetchedContacts = savedContacts\n          }\n\n          if (savedGroups.length > 0) {\n            console.log(\"Falling back to groups from localStorage\")\n            setGroups(savedGroups)\n            fetchedGroups = savedGroups\n          }\n        } catch (e) {\n          console.error(\"Error reading contacts/groups from localStorage\", e)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id for conversation mapping\n  )\n\n  const fetchFriendRequests = useCallback(\n    async (token) => {\n      if (!token) return\n      // No need for setLoading(true) here unless it's a primary action\n      try {\n        const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token)\n        setFriendRequests(response.data || [])\n      } catch (error) {\n        console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error)\n        // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(\n    async (otherUserId, token) => {\n      console.log(`Creating/getting conversation with user: ${otherUserId}`)\n      if (!token || !otherUserId) {\n        throw new Error(\"Token or otherUserId missing for createOrGetConversation\")\n      }\n      try {\n        const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token)\n        if (response?.conversation?.conversationId) {\n          console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId)\n          return response.conversation.conversationId\n        } else {\n          throw new Error(\"Invalid response structure from conversation API\")\n        }\n      } catch (error) {\n        console.error(\"Error in createOrGetConversation:\", error)\n        if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n          throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\")\n        }\n        throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`) // Rethrow with context\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(\n    async (contactOrGroup) => {\n      if (!contactOrGroup || contactOrGroup.id === selectedContact?.id) {\n        console.log(\"Selection unchanged or invalid.\")\n        return // Avoid re-selecting the same contact/group\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        navigate(\"/login\")\n        return\n      }\n\n      console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id)\n\n      // Leave previous room\n      if (selectedContact) {\n        const roomToLeave =\n          selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId\n        if (roomToLeave) {\n          const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\"\n          socket.emit(eventName, roomToLeave)\n          console.log(`Left ${selectedContact.type} room:`, roomToLeave)\n        }\n      }\n\n      // Clear previous state\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n      setSelectedContact(contactOrGroup) // Set selected contact immediately for UI update\n\n      try {\n        setLoading(true) // Show loading for message fetch\n\n        if (contactOrGroup.type === \"group\") {\n          const groupId = contactOrGroup.groupId\n          // Sử dụng conversationId từ group object\n          const conversationId = contactOrGroup.conversationId || groupId\n          socket.emit(\"join_group\", groupId)\n          console.log(\"Joined group room:\", groupId)\n          console.log(\"Using conversationId for group:\", conversationId)\n          await fetchMessages(token, conversationId, true)\n        } else {\n          // Handle individual contact\n          let conversationId = contactOrGroup.conversationId\n\n          // If conversationId is missing, try to fetch/create it\n          if (!conversationId) {\n            console.log(\"Conversation ID missing, attempting to fetch/create...\")\n            try {\n              conversationId = await createOrGetConversation(contactOrGroup.id, token)\n              // Update the contact in the list and the selected contact state\n              const updatedContact = { ...contactOrGroup, conversationId }\n              setSelectedContact(updatedContact) // Update selected state with new ID\n              setContacts((prev) => prev.map((c) => (c.id === contactOrGroup.id ? updatedContact : c)))\n              // Optionally save updated contacts list to localStorage\n              const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n              const updatedContactsList = currentContacts.map((c) =>\n                c.id === contactOrGroup.id ? updatedContact : c,\n              )\n              localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList))\n            } catch (error) {\n              showError(error.message) // Show error from createOrGetConversation\n              setSelectedContact(null) // Deselect if conversation fails\n              setLoading(false)\n              return // Stop execution if conversation fails\n            }\n          }\n\n          if (conversationId) {\n            socket.emit(\"join_conversation\", conversationId)\n            console.log(\"Joined conversation room:\", conversationId)\n            await fetchMessages(token, conversationId, false)\n\n            // Mark conversation as read with proper request body\n            try {\n              await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, { read: true }, token)\n\n              // Update contacts list to remove unread badge\n              setContacts((prev) =>\n                prev.map((c) =>\n                  c.id === contactOrGroup.id ? { ...c, unreadCount: 0 } : c\n                )\n              )\n            } catch (readError) {\n              console.error(\"Error marking conversation as read:\", readError)\n              // Don't show error to user since this is a non-critical operation\n            }\n          } else {\n            // This case should ideally not be reached if createOrGetConversation throws errors\n            showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\")\n            setSelectedContact(null)\n          }\n        }\n      } catch (error) {\n        // Catch errors from fetchMessages or socket emits\n        console.error(\"Error in handleContactSelect processing:\", error)\n        showError(`Lỗi khi chọn liên hệ: ${error.message}`)\n        setSelectedContact(null) // Deselect on error\n      } finally {\n        setLoading(false) // Ensure loading is turned off\n      }\n    },\n    [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages],\n  )\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(\n    async (e) => {\n      e.preventDefault()\n      if (!newMessage.trim() || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      const tempMessageId = `temp-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: newMessage,\n        time: messageTime,\n        senderId: user.id,\n        isSending: true, // Indicate sending state\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      const messageToSend = newMessage // Store message before clearing\n      setNewMessage(\"\") // Clear input immediately\n      scrollToBottom() // Scroll after adding optimistic message\n\n      try {\n        let response\n        let messageDataForSocket\n\n        if (selectedContact.type === \"group\") {\n          const groupId = selectedContact.groupId\n          console.log(\"Attempting to send group message:\", {\n            groupId,\n            messageContent: messageToSend,\n            selectedContact\n          })\n\n          if (!groupId) {\n            throw new Error(\"GroupId is missing\")\n          }\n\n          // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n          if (!selectedContact.memberIds?.includes(user.id)) {\n            console.error(\"User not in group members:\", {\n              userId: user.id,\n              memberIds: selectedContact.memberIds,\n              members: selectedContact.members\n            })\n            throw new Error(\"Bạn không phải là thành viên của nhóm này\")\n          }\n\n          try {\n            response = await apiCall(\n              \"post\", \n              `/api/groups/${groupId}/messages`, \n              { content: messageToSend }, \n              token\n            )\n            \n            console.log(\"Group message API response:\", response)\n            \n            if (!response) {\n              throw new Error(\"No response from server\")\n            }\n\n            if (!response.messageData) {\n              console.error(\"Invalid response structure:\", response)\n              throw new Error(\"Invalid response structure from server\")\n            }\n            \n            const messageData = response.messageData\n            messageDataForSocket = {\n              messageId: messageData.messageId,\n              groupId: groupId,\n              senderId: user.id,\n              senderName: user.name,\n              content: messageToSend,\n              type: \"text\",\n              createdAt: messageData.createdAt || new Date().toISOString(),\n            }\n\n            console.log(\"Emitting socket event with data:\", messageDataForSocket)\n            socket.emit(\"group_message\", messageDataForSocket)\n\n            // Update optimistic message with real ID and remove sending state\n            setMessages((prev) =>\n              prev.map((msg) =>\n                msg.id === tempMessageId\n                  ? {\n                      ...msg,\n                      id: messageData.messageId,\n                      isSending: false,\n                      time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    }\n                  : msg\n              )\n            )\n          } catch (error) {\n            console.error(\"Error details:\", {\n              error,\n              groupId,\n              selectedContact,\n              user: { id: user.id, name: user.name }\n            })\n            \n            if (error.response?.status === 404) {\n              throw new Error(\"Không tìm thấy nhóm chat\")\n            } else if (error.response?.status === 403) {\n              throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\")\n            } else {\n              throw error\n            }\n          }\n        } else {\n          // Handle individual contact message sending\n          const conversationId = selectedContact.conversationId\n          if (!conversationId) {\n            throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\")\n          }\n          response = await apiCall(\n            \"post\",\n            \"/api/messages/send/text\",\n            { \n              conversationId: conversationId, \n              content: messageToSend,\n              tempMessageId: tempMessageId // Add tempMessageId to help match response\n            },\n            token\n          )\n          messageDataForSocket = {\n            messageId: response.messageData?.messageId || response.messageId,\n            tempMessageId: tempMessageId, // Include tempMessageId in socket event\n            conversationId: conversationId,\n            senderId: user.id,\n            senderName: user.name,\n            receiverId: selectedContact.id,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: response.messageData?.createdAt || new Date().toISOString(),\n            time: messageTime // Include original time for matching\n          }\n          socket.emit(\"new_message\", messageDataForSocket)\n        }\n      } catch (error) {\n        console.error(\"Error sending message:\", error)\n        showError(\"Không thể gửi tin nhắn: \" + error.message)\n        // Remove or mark optimistic message as failed\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n      }\n    },\n    [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(\n    async (file, fileType = \"file\") => {\n      // fileType can be 'file', 'image', 'video'\n      if (!file || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n      const maxSize = 50 * 1024 * 1024 // 50MB\n      if (file.size > maxSize) {\n        showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`)\n        return\n      }\n      if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n        showError(\"Chỉ chấp nhận file hình ảnh.\")\n        return\n      }\n      if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n        showError(\"Chỉ chấp nhận file video.\")\n        return\n      }\n\n      // Video duration check\n      let videoDuration = null\n      if (fileType === \"video\") {\n        try {\n          const duration = await getVideoDuration(file)\n          if (duration > 90) {\n            showError(\"Video không được dài quá 90 giây.\")\n            return\n          }\n          videoDuration = Math.round(duration)\n        } catch (err) {\n          showError(\"Không thể đọc thông tin video.\")\n          return\n        }\n      }\n\n      const tempMessageId = `temp-file-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      const tempUrl = URL.createObjectURL(file) // For optimistic UI\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: fileType === \"text\" ? file.name : tempUrl, // Use tempUrl for image/video\n        time: messageTime,\n        senderId: user.id,\n        isSending: true,\n        isFile: fileType === \"file\",\n        isImage: fileType === \"image\",\n        isVideo: fileType === \"video\",\n        fileName: file.name,\n        fileType: file.type,\n        duration: videoDuration,\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      scrollToBottom()\n\n      const formData = new FormData()\n      let apiUrl = \"\"\n      let apiKey = \"\" // Key for the file in FormData\n\n      if (selectedContact.type === \"group\") {\n        const groupId = selectedContact.groupId\n        formData.append(\"groupId\", groupId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = `/api/groups/${groupId}/images`\n            apiKey = \"image\" // Match backend key\n            break\n          case \"video\":\n            apiUrl = `/api/groups/${groupId}/videos`\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = `/api/groups/${groupId}/files`\n            apiKey = \"file\"\n            break\n        }\n      } else {\n        const conversationId = selectedContact.conversationId\n        if (!conversationId) {\n          showError(\"Không tìm thấy cuộc trò chuyện để gửi file\")\n          URL.revokeObjectURL(tempUrl)\n          setMessages((prev) => prev.filter((msg) => msg.id !== tempMessageId)) // Remove optimistic msg\n          return\n        }\n        formData.append(\"conversationId\", conversationId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = \"/api/messages/send/image\"\n            apiKey = \"images\" // Match backend key (plural for this endpoint)\n            break\n          case \"video\":\n            apiUrl = \"/api/messages/send/video\"\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = \"/api/messages/send/file\"\n            apiKey = \"file\"\n            break\n        }\n      }\n\n      formData.append(apiKey, file)\n\n      try {\n        const response = await apiCall(\"post\", apiUrl, formData, token)\n        const messageData = response.messageData || response // Adjust based on API response structure\n        const attachment = messageData.attachments?.[0]\n\n        if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n          throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\")\n        }\n\n        // Update optimistic message\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === tempMessageId\n              ? {\n                  ...msg,\n                  id: messageData.messageId,\n                  content: attachment.url, // Use final URL\n                  fileUrl: fileType === \"file\" ? attachment.url : null,\n                  isSending: false,\n                  time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                  }),\n                }\n              : msg,\n          ),\n        )\n\n        // Update media/documents list\n        const newItem = {\n          id: messageData.messageId,\n          type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n          url: attachment.url,\n          name: attachment.name || file.name,\n          date: new Date(messageData.createdAt).toLocaleDateString(),\n          size: attachment.size || file.size,\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        if (fileType === \"image\" || fileType === \"video\") {\n          setMediaFiles((prev) => [newItem, ...prev]) // Add to beginning (newest)\n        } else {\n          setDocuments((prev) => [newItem, ...prev])\n        }\n\n        // Emit socket event\n        const socketEventData = {\n          messageId: messageData.messageId,\n          conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n          groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n          type: fileType, // 'file', 'image', 'video'\n          content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null, // Content might be null for media\n          attachments: messageData.attachments,\n          createdAt: messageData.createdAt || new Date().toISOString(),\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\"\n        socket.emit(socketEventName, socketEventData)\n\n        URL.revokeObjectURL(tempUrl) // Clean up temp URL\n      } catch (error) {\n        console.error(`Error sending ${fileType}:`, error)\n        showError(`Không thể gửi ${fileType}: ${error.message}`)\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n        URL.revokeObjectURL(tempUrl)\n      }\n    },\n    [isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  const getVideoDuration = (file) => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\")\n      video.preload = \"metadata\"\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src)\n        resolve(video.duration)\n      }\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src)\n        reject(new Error(\"Không thể tải metadata video\"))\n      }\n      video.src = URL.createObjectURL(file)\n    })\n  }\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback((emoji) => {\n    setNewMessage((prev) => prev + emoji)\n    setShowEmojiPicker(false)\n  }, [])\n\n  const handleMessageAction = useCallback(\n    async (messageId, action) => {\n      if (action === \"delete\") {\n        const token = localStorage.getItem(\"token\")\n        if (!token || !selectedContact) return\n\n        // Optimistic UI update\n        const originalMessages = [...messages]\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === messageId ? { ...msg, content: \"Đang xóa...\", isUnsent: true, isDeleting: true } : msg,\n          ),\n        )\n\n        try {\n          if (selectedContact.type === \"group\") {\n            await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, undefined, token)\n          } else {\n            await apiCall(\"delete\", `/api/messages/${messageId}`, undefined, token)\n          }\n\n          // Confirm deletion in UI\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === messageId ? { ...msg, content: \"Tin nhắn đã bị xóa\", isDeleting: false } : msg,\n            ),\n          )\n\n          // Remove from media/documents lists\n          setMediaFiles((prev) => prev.filter((media) => media.id !== messageId))\n          setDocuments((prev) => prev.filter((doc) => doc.id !== messageId))\n\n          // TODO: Emit socket event for deletion if needed by backend/other clients\n        } catch (error) {\n          console.error(\"Error deleting message:\", error)\n          showError(\"Không thể xóa tin nhắn: \" + error.message)\n          // Revert optimistic update on error\n          setMessages(originalMessages)\n        }\n      }\n      // Handle other actions like 'recall' if implemented\n    },\n    [apiCall, selectedContact, showError, messages], // Include messages in dependency array\n  )\n\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true)\n    setShowFiles(false)\n  }, [])\n\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false)\n    setShowFiles(true)\n  }, [])\n\n  const handleTabChange = useCallback((tab) => {\n    setActiveTab(tab)\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchFriendRequests(token)\n      }\n    }\n  }, [fetchFriendRequests]) // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null,\n    })\n    setShowProfileModal(true)\n  }, [user.name, user.avatar]) // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false)\n  }, [])\n\n  const handleAvatarChange = useCallback(\n    async (file) => {\n      // File validation\n      if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n        showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\")\n        return\n      }\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const formData = new FormData()\n      formData.append(\"avatar\", file)\n\n      try {\n        setLoading(true) // Indicate loading\n        const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token)\n        // Update state optimistically/realistically\n        setProfileData((prev) => ({ ...prev, avatarUrl: response.avatarUrl }))\n        setUser((prev) => ({ ...prev, avatar: response.avatarUrl }))\n        // Update localStorage userProfile\n        const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n        userProfile.avatarUrl = response.avatarUrl\n        localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n        showError(\"Cập nhật ảnh đại diện thành công!\")\n      } catch (error) {\n        showError(\"Không thể tải avatar: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    try {\n      setLoading(true)\n      const response = await apiCall(\n        \"put\",\n        \"/api/users/profile\",\n        {\n          fullName: profileData.fullName,\n          // Ensure birthdate is sent correctly or omitted if empty\n          birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n          gender: profileData.gender || undefined, // Send undefined if empty to potentially clear it\n        },\n        token,\n      )\n      // Update user state\n      setUser((prev) => ({\n        ...prev,\n        name: response.fullName || prev.name,\n        // Avatar might not be in this response, keep existing one\n      }))\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      userProfile.fullName = response.fullName\n      userProfile.birthdate = response.birthdate\n      userProfile.gender = response.gender\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n\n      showError(\"Cập nhật hồ sơ thành công!\")\n      handleCloseProfileModal()\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message)\n    } finally {\n      setLoading(false)\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal])\n\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true)\n  }, [])\n\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false)\n    setFriendEmail(\"\") // Reset email field\n  }, [])\n\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\")\n      return\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\")\n      return\n    }\n\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    setLoading(true)\n    try {\n      // Search user first to get ID\n      const searchResult = await apiCall(\n        \"get\",\n        `/api/users/search?query=${encodeURIComponent(friendEmail)}`,\n        null,\n        token,\n      )\n      if (!searchResult?.data?.length) {\n        throw new Error(\"Không tìm thấy người dùng với email này\")\n      }\n      const receiverId = searchResult.data[0].userId\n\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\")\n      }\n\n      // Check if already friends\n      if (contacts.some((c) => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\")\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", { receiverId, message: `Kết bạn từ ${user.name}` }, token)\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`)\n      handleCloseAddFriendModal()\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`)\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`)\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`)\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`)\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false)\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts])\n\n  const handleRespondToFriendRequest = useCallback(\n    async (requestId, action) => {\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const request = friendRequests.find((req) => req.requestId === requestId)\n      if (!request) return\n\n      setLoading(true) // Indicate processing\n      // Optimistically remove from list\n      setFriendRequests((prev) => prev.filter((req) => req.requestId !== requestId))\n\n      try {\n        const response = await apiCall(\"post\", \"/api/friends/requests/respond\", { requestId, action }, token)\n        console.log(\"Friend request response:\", response)\n\n        if (action === \"accept\") {\n          showError(\"Đã chấp nhận lời mời kết bạn\")\n          const senderInfo = request.sender\n          if (!senderInfo || !senderInfo.userId) {\n            throw new Error(\"Thông tin người gửi không hợp lệ\")\n          }\n\n          // Get conversation ID (might be in response or need creation)\n          let conversationId = response.conversation?.conversationId\n          if (!conversationId) {\n            console.log(\"No conversationId in response, creating/getting...\")\n            conversationId = await createOrGetConversation(senderInfo.userId, token)\n          }\n\n          if (!conversationId) {\n            throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\")\n          }\n\n          // Create new contact object\n          const newContact = {\n            id: senderInfo.userId,\n            name: senderInfo.fullName || senderInfo.email?.split(\"@\")[0] || \"Unknown\",\n            avatar: senderInfo.avatarUrl || \"\",\n            type: \"contact\",\n            status: \"Bạn bè\",\n            conversationId: conversationId,\n          }\n\n          addOrUpdateContact(newContact) // Add/update contact list and localStorage\n\n          // Optionally select the new contact immediately\n          // handleContactSelect(newContact);\n\n          // Emit notification to the sender via socket\n          if (socket.connected) {\n            socket.emit(\"friend_request_accepted_notify\", {\n              accepter: { userId: user.id, fullName: user.name, avatarUrl: user.avatar },\n              senderId: senderInfo.userId, // Target the sender\n              conversationId: conversationId,\n            })\n            // Also tell sender to refresh their list\n            socket.emit(\"refresh_contacts_notify\", { targetUserId: senderInfo.userId })\n            console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\")\n          }\n        } else {\n          showError(\"Đã từ chối lời mời kết bạn\")\n          // Optionally notify sender of rejection via socket\n        }\n      } catch (error) {\n        console.error(\"Error responding to friend request:\", error)\n        showError(\"Không thể phản hồi lời mời: \" + error.message)\n        // Revert optimistic removal on error\n        setFriendRequests((prev) => [...prev, request])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user],\n  )\n\n  const handleRemoveFriend = useCallback(\n    async (friendId) => {\n      if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      console.log(`Attempting to remove friend with ID: ${friendId}`)\n      setLoading(true)\n\n      // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n      const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\")\n      if (!contactToRemove) {\n        showError(\"Không tìm thấy người dùng trong danh sách bạn bè\")\n        setLoading(false)\n        return\n      }\n\n      // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n      const currentContacts = [...contacts]\n\n      try {\n        // Cập nhật UI trước khi gọi API (optimistic update)\n        setContacts((prev) => prev.filter((contact) => contact.id !== friendId || contact.type !== \"contact\"))\n\n        // Cập nhật localStorage\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const updatedContacts = savedContacts.filter((c) => c.id !== friendId || c.type !== \"contact\")\n          localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts))\n        } catch (e) {\n          console.error(\"Error updating localStorage after friend removal\", e)\n        }\n\n        // Bỏ chọn nếu đang được chọn\n        if (selectedContact?.id === friendId && selectedContact?.type === \"contact\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        // Gọi API để xóa bạn bè\n        try {\n          console.log(`Calling API to remove friend: ${friendId}`)\n          const response = await apiCall(\"delete\", `/api/friends/${friendId}`, undefined, token)\n          console.log(\"Friend removal API response:\", response)\n\n          showError(\"Đã xóa bạn bè thành công\")\n\n          // Thông báo cho người bạn bị xóa qua socket\n          if (socket && socket.connected) {\n            socket.emit(\"friend_removed_notify\", { removerId: user.id, removedUserId: friendId })\n            console.log(\"Emitted friend_removed_notify\")\n\n            // Thông báo cập nhật danh sách bạn bè\n            socket.emit(\"friend_list_updated\")\n          }\n\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token)\n        } catch (apiError) {\n          console.error(\"API error removing friend:\", apiError)\n\n          // Kiểm tra lỗi cụ thể\n          if (apiError.response && apiError.response.status === 404) {\n            // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n            showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\")\n            // Cập nhật lại danh sách bạn bè từ server\n            fetchContactsAndGroups(token)\n          } else {\n            // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n            showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"))\n            // Khôi phục lại danh sách bạn bè\n            setContacts(currentContacts)\n\n            // Khôi phục localStorage\n            try {\n              localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n            } catch (e) {\n              console.error(\"Error restoring localStorage\", e)\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error in handleRemoveFriend:\", error)\n        showError(\"Không thể xóa bạn bè: \" + error.message)\n\n        // Khôi phục lại danh sách bạn bè\n        setContacts(currentContacts)\n\n        // Khôi phục localStorage\n        try {\n          localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n        } catch (e) {\n          console.error(\"Error restoring localStorage\", e)\n        }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups],\n  )\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true)\n  }, [])\n\n  const handleGroupCreated = useCallback(\n    (newGroupData) => {\n      console.log(\"Group created data:\", newGroupData)\n      const groupObject = {\n        groupId: newGroupData.groupId,\n        id: newGroupData.groupId, // Add id for consistency\n        name: newGroupData.name,\n        avatar: newGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: newGroupData.adminId,\n        memberCount: newGroupData.members?.length || 1, // At least admin is a member\n        conversationId: newGroupData.conversationId || newGroupData.groupId,\n        createdAt: newGroupData.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      setShowCreateGroupModal(false)\n      showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`)\n      // Automatically select the new group\n      handleContactSelect(groupObject)\n    },\n    [addOrUpdateGroup, showError, handleContactSelect],\n  )\n\n  const handleGroupInfo = useCallback(\n    (group) => {\n      // Fetch full group details if necessary before showing modal\n      setSelectedGroup(group) // Pass the basic group info for now\n      setShowGroupInfoModal(true)\n      // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n    },\n    [], // No dependencies needed to just show the modal\n  )\n\n  const handleGroupUpdated = useCallback(\n    (updatedGroupData) => {\n      console.log(\"Group updated data:\", updatedGroupData)\n      // Ensure the data structure matches what addOrUpdateGroup expects\n      const groupObject = {\n        groupId: updatedGroupData.groupId,\n        id: updatedGroupData.groupId,\n        name: updatedGroupData.name,\n        avatar: updatedGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: updatedGroupData.adminId,\n        memberCount: updatedGroupData.memberCount || updatedGroupData.members?.length || 0,\n        conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n        createdAt: updatedGroupData.createdAt,\n        // Include other relevant fields if needed\n      }\n      addOrUpdateGroup(groupObject)\n      // Update selected contact if it's the one being edited\n      if (selectedContact?.id === groupObject.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n      setShowGroupInfoModal(false) // Close modal on success\n      showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`)\n    },\n    [addOrUpdateGroup, selectedContact, showError],\n  )\n\n  const handleLeaveGroup = useCallback(\n    async (groupId) => {\n      console.log(\"Leaving group:\", groupId)\n\n      if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      setLoading(true)\n\n      try {\n        // Gọi API để rời nhóm\n        const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, undefined, token)\n        console.log(\"Leave group API response:\", response)\n\n        // Cập nhật UI sau khi API thành công\n        setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n\n        // Cập nhật localStorage\n        try {\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n          const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n        } catch (e) {\n          console.error(\"Error updating localStorage after leaving group\", e)\n        }\n\n        // Bỏ chọn nhóm nếu đang được chọn\n        if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        setShowGroupInfoModal(false) // Đóng modal\n        showError(\"Bạn đã rời khỏi nhóm thành công\")\n\n        // Thông báo qua socket nếu cần\n        if (socket.connected) {\n          socket.emit(\"left_group\", { groupId })\n        }\n      } catch (error) {\n        console.error(\"Error leaving group:\", error)\n        showError(\"Không thể rời khỏi nhóm: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [selectedContact, showError, apiCall],\n  )\n\n  const handleDeleteGroup = useCallback(\n    (groupId) => {\n      console.log(\"Deleting group:\", groupId)\n      setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch (e) {\n        console.error(\"Error updating localStorage after deleting group\", e)\n      }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n      setShowGroupInfoModal(false) // Close modal\n      showError(\"Đã xóa nhóm thành công\")\n      // API call to delete group should be handled within GroupInfoModal or here before state update\n    },\n    [selectedContact, showError],\n  )\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) {\n      navigate(\"/login\")\n      return\n    }\n\n    let isMounted = true // Flag to prevent state updates on unmounted component\n    let socketInitialized = false\n\n    const initializeApp = async () => {\n      try {\n        setLoading(true)\n        const userProfile = await fetchUserProfile(token)\n        if (!userProfile || !isMounted) return // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token)\n        if (!isMounted) return\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token)\n        if (!isMounted) return\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\")\n          \n          // Set socket auth and query params\n          socket.auth = { token }\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now(),\n          }\n\n          // Connect the socket\n          socket.connect()\n          socketInitialized = true\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error)\n      } finally {\n        if (isMounted) {\n          setLoading(false)\n        }\n      }\n    }\n\n    initializeApp()\n\n    // Cleanup function\n    return () => {\n      isMounted = false\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\")\n      socket.off(\"reconnect\")\n      socket.off(\"friend_request\")\n      socket.off(\"new_message\")\n      socket.off(\"receive_message\")\n      socket.off(\"group_message\")\n      socket.off(\"friend_request_accepted\")\n      socket.off(\"friend_removed\")\n      socket.off(\"refresh_contacts\")\n      socket.off(\"notification\")\n      socket.off(\"group_created\")\n      socket.off(\"group_updated\")\n      socket.off(\"group_deleted\")\n      socket.off(\"member_added\")\n      socket.off(\"member_removed\")\n    }\n  }, [navigate]) // Only depend on navigate\n\n  // Khi khởi tạo component, đọc cache từ localStorage\n  useEffect(() => {\n    // ... các logic khác\n    const cache = localStorage.getItem('cachedMessages')\n    if (cache) {\n      setCachedMessages(JSON.parse(cache))\n    }\n  }, [navigate])\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback((data) => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || (!data.messageId && !data.id)) {\n      console.error(\"Invalid message data received:\", data)\n      return\n    }\n\n    const messageTime = data.createdAt\n      ? new Date(data.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      : new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString()\n\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact?.type,\n      selectedContactGroupId: selectedContact?.groupId,\n      selectedContactConversationId: selectedContact?.conversationId\n    });\n\n    const isCurrentChat =\n      (selectedContact?.type === \"group\" && selectedContact.groupId === data.groupId) ||\n      (selectedContact?.type === \"contact\" && selectedContact.conversationId === data.conversationId)\n\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n      const newMessage = {\n        id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n        content:\n          data.isRecalled || data.isDeleted\n            ? \"Tin nhắn đã bị thu hồi/xóa\"\n            : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\"\n              ? data.content\n            : data.attachments?.[0]?.url || data.content || \"\",\n        time: messageTime,\n        senderId: data.senderId,\n        isImage: data.type === \"image\" || data.type === \"imageGroup\",\n        isVideo: data.type === \"video\",\n        isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n        isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n        fileUrl: data.type === \"file\" ? data.attachments?.[0]?.url : null,\n        fileName: data.type === \"file\" ? data.attachments?.[0]?.name : null,\n        fileType: data.type === \"file\" ? data.attachments?.[0]?.type : null,\n        duration: data.type === \"video\" ? data.attachments?.[0]?.duration || data.duration : null,\n        messageDate: messageDate,\n      }\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || []\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev\n        const updated = { ...prev, [data.conversationId]: [...prevList, newMessage] }\n        // Lưu vào localStorage\n        localStorage.setItem('cachedMessages', JSON.stringify(updated))\n        console.log('>>> Updated cachedMessages:', updated)\n        return updated\n      })\n    }\n\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id)\n        if (exists) return prev\n        return [...prev, newMessage]\n      })\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n            duration: newMessage.duration,\n          },\n          ...prev, // Add to beginning\n        ])\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n          },\n          ...prev, // Add to beginning\n        ])\n      }\n    } else {\n      // Notification for message in other chat\n      let senderName = \"Người dùng\"\n      let contactId = data.senderId // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find((g) => g.groupId === data.groupId)\n        senderName = `${data.senderName || \"Ai đó\"} (${group?.name || \"Nhóm\"})`\n      } else {\n        const contact = contacts.find((c) => c.id === data.senderId) // Tìm contact dựa trên senderId\n        senderName = contact?.name || data.senderName || \"Ai đó\"\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n\n      const preview =\n        data.type === \"text\"\n          ? data.content?.substring(0, 30) + (data.content?.length > 30 ? \"...\" : \"\")\n          : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`)\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview, // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(\n          c => c.conversationId === data.conversationId || c.id === data.senderId\n        )\n        if (foundContact) {\n          setSelectedContact(foundContact)\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || [])\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      const contactName = data.senderName || \"Người dùng\"\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: contacts.find((c) => c.id === data.senderId)?.avatar || groups.find(g => g.groupId === data.groupId)?.avatar || \"/favicon.ico\", // Optional icon\n      })\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages])\n\n  const handleFriendRequest = useCallback((data) => {\n    if (!data || !data.requestId || !data.sender) return\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab])\n\n  const handleFriendRequestAccepted = useCallback((data) => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\")\n      return\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user])\n\n  const handleFriendRemoved = useCallback((data) => {\n    if (!data || !data.removerId) return\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError])\n\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\")\n    if (token) {\n      fetchContactsAndGroups(token)\n    }\n  }, [fetchContactsAndGroups])\n\n  const handleSocketGroupCreated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_created event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.members?.length || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`)\n  }, [addOrUpdateGroup, showError])\n\n  const handleSocketGroupUpdated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_updated event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`)\n  }, [addOrUpdateGroup, selectedContact, showError])\n\n  const handleGroupDeleted = useCallback((data) => {\n    if (!data?.groupId) return\n    console.log(\"Received group_deleted event:\", data.groupId)\n    const groupName = groups.find(g => g.groupId === data.groupId)?.name || \"Một nhóm\"\n    setGroups((prev) => prev.filter((group) => group.groupId !== data.groupId))\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n      const updatedGroups = savedGroups.filter((g) => g.groupId !== data.groupId)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n    } catch (e) { console.error(\"Error updating localStorage after group delete\", e) }\n\n    if (selectedContact?.id === data.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(null)\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`)\n  }, [groups, selectedContact, showError])\n\n  const handleMemberAdded = useCallback((data) => {\n    if (!data?.group || !data?.member || !data?.addedBy) return\n    console.log(\"Received member_added event:\", data)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`)\n    }\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleMemberRemoved = useCallback((data) => {\n    if (!data?.group || !data?.memberId || !data?.removedBy) return\n    console.log(\"Received member_removed event:\", data)\n    const group = data.group\n    const groupId = group.groupId\n\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`)\n      setGroups((prev) => prev.filter((g) => g.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch(e) { console.error(\"Error updating localStorage after being removed from group\", e) }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n    } else {\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || group.members?.length || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      const memberName = data.member?.fullName || \"một thành viên\"\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`)\n      if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleNotification = useCallback((data) => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data)\n      return\n    }\n    if (data.type === \"success\") {\n      showError(data.message)\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\")\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\")\n    } else {\n      showError(data.message)\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchContactsAndGroups(token)\n      }\n    }\n  }, [showError, fetchContactsAndGroups])\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true\n\n    const handleConnect = () => {\n      if (!isMounted) return\n      console.log(\"Socket re-connected inside hook.\")\n      setIsConnected(true)\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId)\n      }\n    }\n\n    // Add handler for message_sent event\n    const handleMessageSent = (data) => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data)\n        return\n      }\n      console.log(\"Received message_sent_success event:\", data)\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n          // Match by tempMessageId if available\n          (data.tempMessageId && msg.id === data.tempMessageId) ||\n          // Or match by conversationId and content if tempMessageId not available\n          (data.conversationId && msg.conversationId === data.conversationId && \n           msg.content === data.content)\n        )) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          })\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          }\n        }\n        return msg\n      }))\n    }\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect)\n    socket.on(\"message_sent_success\", handleMessageSent) // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage)\n    socket.on(\"receive_message\", handleNewMessage)\n    socket.on(\"group_message\", handleNewMessage)\n    socket.on(\"friend_request\", handleFriendRequest)\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted)\n    socket.on(\"friend_removed\", handleFriendRemoved)\n    socket.on(\"refresh_contacts\", handleRefreshContacts)\n    socket.on(\"notification\", handleNotification)\n    socket.on(\"group_created\", handleSocketGroupCreated)\n    socket.on(\"group_updated\", handleSocketGroupUpdated)\n    socket.on(\"group_deleted\", handleGroupDeleted)\n    socket.on(\"member_added\", handleMemberAdded)\n    socket.on(\"member_removed\", handleMemberRemoved)\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false\n      socket.off(\"connect\", handleConnect)\n      socket.off(\"message_sent_success\", handleMessageSent) // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage)\n      socket.off(\"receive_message\", handleNewMessage)\n      socket.off(\"group_message\", handleNewMessage)\n      socket.off(\"friend_request\", handleFriendRequest)\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted)\n      socket.off(\"friend_removed\", handleFriendRemoved)\n      socket.off(\"refresh_contacts\", handleRefreshContacts)\n      socket.off(\"notification\", handleNotification)\n      socket.off(\"group_created\", handleSocketGroupCreated)\n      socket.off(\"group_updated\", handleSocketGroupUpdated)\n      socket.off(\"group_deleted\", handleGroupDeleted)\n      socket.off(\"member_added\", handleMemberAdded)\n      socket.off(\"member_removed\", handleMemberRemoved)\n    }\n  }, [\n    handleNewMessage,\n    handleFriendRequest,\n    handleFriendRequestAccepted,\n    handleFriendRemoved,\n    handleRefreshContacts,\n    handleNotification,\n    handleSocketGroupCreated,\n    handleSocketGroupUpdated,\n    handleGroupDeleted,\n    handleMemberAdded,\n    handleMemberRemoved,\n    selectedContact // Add selectedContact as dependency\n  ])\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages]) // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n        messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }, 100);\n  }\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(\n    (contact) => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n  const filteredGroups = groups.filter(\n    (group) => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"] // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts, // Return full contacts list if needed elsewhere\n    groups,   // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab, // Needed for friend request notification\n    setShowProfileModal, // Needed for closing modal from component\n    setProfileData, // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal, // Needed for closing modal from component\n    setFriendEmail, // Needed for form input\n    // setError, // Internal state\n    setShowToast, // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal, // Needed for closing modal from component\n    setShowGroupInfoModal, // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile, // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError, // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"), // Pass token for Modals\n  }\n}\n\nexport default useChat\n"],"mappings":";AAAA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAChE,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,OAAOC,KAAK,MAAM,OAAO;AACzB,SAASC,EAAE,QAAQ,kBAAkB;;AAErC;;AAEA;AACA,MAAMC,YAAY,GAAG,uBAAuB;;AAE5C;AACA,MAAMC,MAAM,GAAGF,EAAE,CAACC,YAAY,EAAE;EAC9BE,WAAW,EAAE,KAAK;EAAE;EACpBC,YAAY,EAAE,IAAI;EAClBC,oBAAoB,EAAEC,MAAM,CAACC,iBAAiB;EAC9CC,iBAAiB,EAAE,IAAI;EACvBC,oBAAoB,EAAE,IAAI;EAC1BC,OAAO,EAAE,KAAK;EACdC,UAAU,EAAE,CAAC,WAAW,CAAC;EACzBC,OAAO,EAAE,KAAK;EACdC,QAAQ,EAAE,KAAK;EAAE;EACjBC,KAAK,EAAE;IACLC,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;EACtB;AACF,CAAC,CAAC;;AAEF;AACAf,MAAM,CAACgB,EAAE,CAAC,SAAS,EAAE,MAAM;EACzBC,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAElB,MAAM,CAACmB,EAAE,CAAC;AAC9D,CAAC,CAAC;AAEFnB,MAAM,CAACgB,EAAE,CAAC,eAAe,EAAGI,GAAG,IAAK;EAClCH,OAAO,CAACI,KAAK,CAAC,0BAA0B,EAAED,GAAG,CAAC;AAChD,CAAC,CAAC;AAEFpB,MAAM,CAACgB,EAAE,CAAC,YAAY,EAAGM,MAAM,IAAK;EAClCL,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEI,MAAM,CAAC;AAC7C,CAAC,CAAC;AAEFtB,MAAM,CAACgB,EAAE,CAAC,OAAO,EAAGI,GAAG,IAAK;EAC1BH,OAAO,CAACI,KAAK,CAAC,eAAe,EAAED,GAAG,CAAC;AACrC,CAAC,CAAC;AAEFpB,MAAM,CAACgB,EAAE,CAAC,iBAAiB,EAAGI,GAAG,IAAK;EACpCH,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAED,GAAG,CAAC;AAClD,CAAC,CAAC;;AAEF;AACA,IAAI,OAAOG,MAAM,KAAK,WAAW,EAAE;EACjC,MAAMC,oBAAoB,GAAGP,OAAO,CAACI,KAAK;EAC1CJ,OAAO,CAACI,KAAK,GAAG,CAAC,GAAGI,IAAI,KAAK;IAC3B,IACEA,IAAI,CAAC,CAAC,CAAC,IACP,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,KAC1BA,IAAI,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,gCAAgC,CAAC,IAAID,IAAI,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,8BAA8B,CAAC,CAAC,EACxG;MACA;IACF;IACAF,oBAAoB,CAACG,KAAK,CAACV,OAAO,EAAEQ,IAAI,CAAC;EAC3C,CAAC;AACH;;AAEA;;AAEA,MAAMG,OAAO,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpB,MAAMC,QAAQ,GAAGlC,WAAW,CAAC,CAAC;;EAE9B;EACA,MAAM,CAACmC,IAAI,EAAEC,OAAO,CAAC,GAAGxC,QAAQ,CAAC;IAAE2B,EAAE,EAAE,EAAE;IAAEc,IAAI,EAAE,MAAM;IAAEC,MAAM,EAAE;EAAG,CAAC,CAAC;EACtE,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAG5C,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAAC6C,MAAM,EAAEC,SAAS,CAAC,GAAG9C,QAAQ,CAAC,EAAE,CAAC;EACxC,MAAM,CAAC+C,eAAe,EAAEC,kBAAkB,CAAC,GAAGhD,QAAQ,CAAC,IAAI,CAAC;EAC5D,MAAM,CAACiD,QAAQ,EAAEC,WAAW,CAAC,GAAGlD,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACmD,UAAU,EAAEC,aAAa,CAAC,GAAGpD,QAAQ,CAAC,EAAE,CAAC;EAChD,MAAM,CAACqD,WAAW,EAAEC,cAAc,CAAC,GAAGtD,QAAQ,CAACQ,MAAM,CAAC+C,SAAS,CAAC,EAAC;EACjE,MAAM,CAACC,eAAe,EAAEC,kBAAkB,CAAC,GAAGzD,QAAQ,CAAC,KAAK,CAAC;EAC7D,MAAM,CAAC0D,WAAW,EAAEC,cAAc,CAAC,GAAG3D,QAAQ,CAAC,EAAE,CAAC;EAClD,MAAM,CAAC4D,UAAU,EAAEC,aAAa,CAAC,GAAG7D,QAAQ,CAAC,EAAE,CAAC;EAChD,MAAM,CAAC8D,SAAS,EAAEC,YAAY,CAAC,GAAG/D,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAM,CAACgE,SAAS,EAAEC,YAAY,CAAC,GAAGjE,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACkE,SAAS,EAAEC,YAAY,CAAC,GAAGnE,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACoE,SAAS,EAAEC,YAAY,CAAC,GAAGrE,QAAQ,CAAC,MAAM,CAAC;EAClD,MAAM,CAACsE,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGvE,QAAQ,CAAC,KAAK,CAAC;EAC/D,MAAM,CAACwE,WAAW,EAAEC,cAAc,CAAC,GAAGzE,QAAQ,CAAC;IAC7C0E,QAAQ,EAAE,EAAE;IACZC,SAAS,EAAE,EAAE;IACbC,MAAM,EAAE,EAAE;IACVC,SAAS,EAAE;EACb,CAAC,CAAC;EACF,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAG/E,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACgF,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGjF,QAAQ,CAAC,KAAK,CAAC;EACnE,MAAM,CAACkF,WAAW,EAAEC,cAAc,CAAC,GAAGnF,QAAQ,CAAC,EAAE,CAAC;EAClD,MAAM,CAAC6B,KAAK,EAAEuD,QAAQ,CAAC,GAAGpF,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM,CAACqF,SAAS,EAAEC,YAAY,CAAC,GAAGtF,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACuF,cAAc,EAAEC,iBAAiB,CAAC,GAAGxF,QAAQ,CAAC,EAAE,CAAC;EACxD,MAAM,CAACyF,iBAAiB,EAAEC,oBAAoB,CAAC,GAAG1F,QAAQ,CAAC,EAAE,CAAC,EAAC;EAC/D,MAAM,CAAC2F,oBAAoB,EAAEC,uBAAuB,CAAC,GAAG5F,QAAQ,CAAC,KAAK,CAAC;EACvE,MAAM,CAAC6F,kBAAkB,EAAEC,qBAAqB,CAAC,GAAG9F,QAAQ,CAAC,KAAK,CAAC;EACnE,MAAM,CAAC+F,aAAa,EAAEC,gBAAgB,CAAC,GAAGhG,QAAQ,CAAC,IAAI,CAAC;EACxD;EACA,MAAM,CAACiG,cAAc,EAAEC,iBAAiB,CAAC,GAAGlG,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAExD;EACA,MAAMmG,cAAc,GAAGjG,MAAM,CAAC,IAAI,CAAC;EACnC,MAAMkG,YAAY,GAAGlG,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMmG,aAAa,GAAGnG,MAAM,CAAC,IAAI,CAAC;EAClC,MAAMoG,aAAa,GAAGpG,MAAM,CAAC,IAAI,CAAC;;EAElC;;EAEA,MAAMqG,SAAS,GAAGpG,WAAW,CAAEqG,OAAO,IAAK;IACzC/E,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAE8E,OAAO,CAAC;IACtCpB,QAAQ,CAACoB,OAAO,CAAC;IACjBlB,YAAY,CAAC,IAAI,CAAC;IAClB;IACA;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMmB,OAAO,GAAGtG,WAAW,CACzB,OAAOuG,MAAM,EAAEC,GAAG,EAAEC,IAAI,GAAG,IAAI,EAAEC,KAAK,KAAK;IACzC,IAAI;MACFpF,OAAO,CAACC,GAAG,CAAC,aAAagF,MAAM,CAACI,WAAW,CAAC,CAAC,IAAIH,GAAG,EAAE,CAAC;MACvD,IAAIC,IAAI,EAAE;QACRnF,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEkF,IAAI,YAAYG,QAAQ,GAAG,UAAU,GAAGH,IAAI,CAAC;MAC5E;MAEA,MAAMI,MAAM,GAAG;QACbN,MAAM;QACNC,GAAG,EAAE,GAAGpG,YAAY,GAAGoG,GAAG,EAAE;QAC5BM,OAAO,EAAE;UACPC,aAAa,EAAE,UAAUL,KAAK,EAAE;UAChC,eAAe,EAAE,UAAU;UAC3BM,MAAM,EAAE,UAAU;UAClB,eAAe,EAAE,EAAE,CAAE;QACvB,CAAC;QACDP;MACF,CAAC;MAED,IAAI,EAAEA,IAAI,YAAYG,QAAQ,CAAC,EAAE;QAC/BC,MAAM,CAACC,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;MACrD;MAEAxF,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE;QAC3BgF,MAAM,EAAEM,MAAM,CAACN,MAAM;QACrBC,GAAG,EAAEK,MAAM,CAACL,GAAG;QACfM,OAAO,EAAE;UAAE,GAAGD,MAAM,CAACC,OAAO;UAAEC,aAAa,EAAE;QAAkB;MACjE,CAAC,CAAC;MAEF,MAAME,QAAQ,GAAG,MAAM/G,KAAK,CAAC2G,MAAM,CAAC;MACpCvF,OAAO,CAACC,GAAG,CAAC,gBAAgBiF,GAAG,GAAG,EAAES,QAAQ,CAACC,MAAM,EAAED,QAAQ,CAACR,IAAI,CAAC;MACnE,OAAOQ,QAAQ,CAACR,IAAI;IACtB,CAAC,CAAC,OAAO/E,KAAK,EAAE;MAAA,IAAAyF,eAAA,EAAAC,gBAAA,EAAAC,qBAAA;MACd/F,OAAO,CAACI,KAAK,CAAC,aAAa8E,GAAG,GAAG,EAAE9E,KAAK,CAAC;MACzC,IAAIA,KAAK,CAACuF,QAAQ,EAAE;QAClB3F,OAAO,CAACI,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAACuF,QAAQ,CAACC,MAAM,CAAC;QACxD5F,OAAO,CAACI,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAACuF,QAAQ,CAACR,IAAI,CAAC;MACtD;MAEA,IAAI,EAAAU,eAAA,GAAAzF,KAAK,CAACuF,QAAQ,cAAAE,eAAA,uBAAdA,eAAA,CAAgBD,MAAM,MAAK,GAAG,EAAE;QAClCI,YAAY,CAACC,UAAU,CAAC,OAAO,CAAC;QAChCD,YAAY,CAACC,UAAU,CAAC,aAAa,CAAC,EAAC;QACvCpF,QAAQ,CAAC,QAAQ,CAAC;QAClB;QACAiE,SAAS,CAAC,kDAAkD,CAAC;QAC7D,MAAM,IAAIoB,KAAK,CAAC,0BAA0B,CAAC,EAAC;MAC9C;MAEA,MAAMC,YAAY,GAAG,EAAAL,gBAAA,GAAA1F,KAAK,CAACuF,QAAQ,cAAAG,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBX,IAAI,cAAAY,qBAAA,uBAApBA,qBAAA,CAAsBhB,OAAO,KAAI3E,KAAK,CAAC2E,OAAO,IAAI,8BAA8B;MACrG;MACA;MACA,MAAM,IAAImB,KAAK,CAACC,YAAY,CAAC;IAC/B;EACF,CAAC,EACD,CAACtF,QAAQ,EAAEiE,SAAS,CACtB,CAAC,EAAC;;EAEF;;EAEA,MAAMsB,kBAAkB,GAAG1H,WAAW,CAAE2H,UAAU,IAAK;IACrD,IAAI,CAACA,UAAU,IAAI,CAACA,UAAU,CAACnG,EAAE,EAAE;MACjCF,OAAO,CAACI,KAAK,CAAC,uBAAuB,EAAEiG,UAAU,CAAC;MAClD;IACF;IACArG,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEoG,UAAU,CAAC;IACtD,IAAI;MACF,MAAMC,aAAa,GAAGN,YAAY,CAACO,OAAO,CAAC,eAAe,CAAC;MAC3D,IAAIC,aAAa,GAAGF,aAAa,GAAGG,IAAI,CAACC,KAAK,CAACJ,aAAa,CAAC,GAAG,EAAE;MAClEE,aAAa,GAAGA,aAAa,CAACG,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAAC1G,EAAE,KAAKmG,UAAU,CAACnG,EAAE,CAAC;MACnEsG,aAAa,CAACK,IAAI,CAACR,UAAU,CAAC;MAC9BL,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAACP,aAAa,CAAC,CAAC;MACpExG,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEoG,UAAU,CAACnG,EAAE,CAAC;IAC9D,CAAC,CAAC,OAAO8G,YAAY,EAAE;MACrBhH,OAAO,CAACI,KAAK,CAAC,uCAAuC,EAAE4G,YAAY,CAAC;IACtE;IACA7F,WAAW,CAAE8F,IAAI,IAAK;MACpB,MAAMC,MAAM,GAAGD,IAAI,CAACE,IAAI,CAAEC,OAAO,IAAKA,OAAO,CAAClH,EAAE,KAAKmG,UAAU,CAACnG,EAAE,CAAC;MACnE,IAAIgH,MAAM,EAAE;QACV,OAAOD,IAAI,CAACI,GAAG,CAAED,OAAO,IAAMA,OAAO,CAAClH,EAAE,KAAKmG,UAAU,CAACnG,EAAE,GAAG;UAAE,GAAGkH,OAAO;UAAE,GAAGf;QAAW,CAAC,GAAGe,OAAQ,CAAC;MACxG;MACA,OAAO,CAAC,GAAGH,IAAI,EAAEZ,UAAU,CAAC;IAC9B,CAAC,CAAC;IACF;IACApC,oBAAoB,CAAEgD,IAAI,IAAK;MAC7B,MAAMC,MAAM,GAAGD,IAAI,CAACE,IAAI,CAAEC,OAAO,IAAKA,OAAO,CAAClH,EAAE,KAAKmG,UAAU,CAACnG,EAAE,CAAC;MACnE,IAAIgH,MAAM,EAAE;QACV,OAAOD,IAAI,CAACI,GAAG,CAAED,OAAO,IAAMA,OAAO,CAAClH,EAAE,KAAKmG,UAAU,CAACnG,EAAE,GAAG;UAAE,GAAGkH,OAAO;UAAE,GAAGf;QAAW,CAAC,GAAGe,OAAQ,CAAC;MACxG;MACA,OAAO,CAAC,GAAGH,IAAI,EAAEZ,UAAU,CAAC;IAC9B,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMiB,gBAAgB,GAAG5I,WAAW,CAAE6I,QAAQ,IAAK;IACjD,IAAI,CAACA,QAAQ,IAAI,CAACA,QAAQ,CAACC,OAAO,EAAE;MAClCxH,OAAO,CAACI,KAAK,CAAC,qBAAqB,EAAEmH,QAAQ,CAAC;MAC9C;IACF;IACAvH,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEsH,QAAQ,CAAC;IAClD,IAAI;MACF,MAAME,WAAW,GAAGzB,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC;MACvD,IAAImB,WAAW,GAAGD,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACe,WAAW,CAAC,GAAG,EAAE;MAC5DC,WAAW,GAAGA,WAAW,CAACf,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKD,QAAQ,CAACC,OAAO,CAAC;MACvEE,WAAW,CAACb,IAAI,CAACU,QAAQ,CAAC;MAC1BvB,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACW,WAAW,CAAC,CAAC;MAChE1H,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEsH,QAAQ,CAACC,OAAO,CAAC;IAC/D,CAAC,CAAC,OAAOR,YAAY,EAAE;MACrBhH,OAAO,CAACI,KAAK,CAAC,qCAAqC,EAAE4G,YAAY,CAAC;IACpE;IACA3F,SAAS,CAAE4F,IAAI,IAAK;MAClB,MAAMC,MAAM,GAAGD,IAAI,CAACE,IAAI,CAAES,KAAK,IAAKA,KAAK,CAACJ,OAAO,KAAKD,QAAQ,CAACC,OAAO,CAAC;MACvE,IAAIN,MAAM,EAAE;QACV,OAAOD,IAAI,CAACI,GAAG,CAAEO,KAAK,IAAMA,KAAK,CAACJ,OAAO,KAAKD,QAAQ,CAACC,OAAO,GAAG;UAAE,GAAGI,KAAK;UAAE,GAAGL;QAAS,CAAC,GAAGK,KAAM,CAAC;MACtG;MACA,OAAO,CAAC,GAAGX,IAAI,EAAEM,QAAQ,CAAC;IAC5B,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;;EAEN;;EAEA,MAAMM,gBAAgB,GAAGnJ,WAAW,CAClC,MAAO0G,KAAK,IAAK;IACf,IAAI;MACF,MAAMO,QAAQ,GAAG,MAAMX,OAAO,CAAC,KAAK,EAAE,oBAAoB,EAAE,IAAI,EAAEI,KAAK,CAAC;MACxE,MAAM0C,QAAQ,GAAG;QACf5H,EAAE,EAAEyF,QAAQ,CAACoC,MAAM;QACnB/G,IAAI,EAAE2E,QAAQ,CAAC1C,QAAQ,IAAI,MAAM;QACjChC,MAAM,EAAE0E,QAAQ,CAACvC,SAAS,IAAI;MAChC,CAAC;MACDrC,OAAO,CAAC+G,QAAQ,CAAC;MACjB9E,cAAc,CAAC;QACbC,QAAQ,EAAE0C,QAAQ,CAAC1C,QAAQ,IAAI,EAAE;QACjCC,SAAS,EAAEyC,QAAQ,CAACzC,SAAS,GAAG,IAAIrD,IAAI,CAAC8F,QAAQ,CAACzC,SAAS,CAAC,CAAC8E,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;QAC7F9E,MAAM,EAAEwC,QAAQ,CAACxC,MAAM,IAAI,EAAE;QAC7BC,SAAS,EAAEuC,QAAQ,CAACvC,SAAS,IAAI;MACnC,CAAC,CAAC;MACF;MACA4C,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACpB,QAAQ,CAAC,CAAC;MAC7D,OAAOA,QAAQ,EAAC;IAClB,CAAC,CAAC,OAAOvF,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD0E,SAAS,CAAC,sCAAsC,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;MACjE;MACA,OAAO,IAAI;IACb;EACF,CAAC,EACD,CAACC,OAAO,EAAEF,SAAS,CACrB,CAAC;EAED,MAAMoD,aAAa,GAAGxJ,WAAW,CAC/B,OAAO0G,KAAK,EAAE+C,cAAc,EAAEC,OAAO,GAAG,KAAK,KAAK;IAChD,IAAI,CAAChD,KAAK,IAAI,CAAC+C,cAAc,EAAE;MAC7BnI,OAAO,CAACqI,IAAI,CAAC,sDAAsD,CAAC;MACpE5G,WAAW,CAAC,EAAE,CAAC,EAAC;MAChBW,aAAa,CAAC,EAAE,CAAC;MACjBE,YAAY,CAAC,EAAE,CAAC;MAChB;IACF;IACAgB,UAAU,CAAC,IAAI,CAAC,EAAC;IACjB,IAAI;MACF,IAAIqC,QAAQ;MACZ;MACA,MAAM2C,QAAQ,GAAG,+BAA+BH,cAAc,WAAW;MAEzEnI,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEqI,QAAQ,CAAC;MACzD3C,QAAQ,GAAG,MAAMX,OAAO,CAAC,KAAK,EAAEsD,QAAQ,EAAE,IAAI,EAAElD,KAAK,CAAC;MACtDpF,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAE0F,QAAQ,CAAC;MAE/C,MAAM4C,YAAY,GAAGC,KAAK,CAACC,OAAO,CAAC9C,QAAQ,CAAC,GAAGA,QAAQ,GAAGA,QAAQ,CAACR,IAAI,IAAI,EAAE;MAE7E,MAAMuD,cAAc,GAAGH,YAAY,CAChClB,GAAG,CAAC,CAACsB,GAAG,EAAEC,KAAK;QAAA,IAAAC,gBAAA,EAAAC,iBAAA,EAAAC,iBAAA,EAAAC,kBAAA,EAAAC,iBAAA,EAAAC,kBAAA,EAAAC,iBAAA,EAAAC,kBAAA,EAAAC,iBAAA,EAAAC,kBAAA;QAAA,OAAM;UAClBpJ,EAAE,EAAEyI,GAAG,CAACY,SAAS,IAAI,QAAQ1J,IAAI,CAACC,GAAG,CAAC,CAAC,IAAI8I,KAAK,EAAE;UAClDY,MAAM,EAAEb,GAAG,CAACc,QAAQ,KAAK3I,IAAI,CAACZ,EAAE,GAAG,IAAI,GAAGyI,GAAG,CAACe,UAAU,IAAI,SAAS;UACrEC,OAAO,EACLhB,GAAG,CAACiB,UAAU,IAAIjB,GAAG,CAACkB,SAAS,GAC3B,4BAA4B,GAC5BlB,GAAG,CAACmB,IAAI,KAAK,MAAM,IAAInB,GAAG,CAACmB,IAAI,KAAK,OAAO,IAAInB,GAAG,CAACmB,IAAI,KAAK,QAAQ,GAClEnB,GAAG,CAACgB,OAAO,GACX,EAAAd,gBAAA,GAAAF,GAAG,CAACoB,WAAW,cAAAlB,gBAAA,wBAAAC,iBAAA,GAAfD,gBAAA,CAAkB,CAAC,CAAC,cAAAC,iBAAA,uBAApBA,iBAAA,CAAsB5D,GAAG,KAAIyD,GAAG,CAACgB,OAAO,IAAI,EAAE;UAAE;UAC1DK,IAAI,EAAE,IAAInK,IAAI,CAAC,CAAC,CAACoK,kBAAkB,CAAC,EAAE,EAAE;YAAEC,IAAI,EAAE,SAAS;YAAEC,MAAM,EAAE;UAAU,CAAC,CAAC;UAC7EV,QAAQ,EAAEd,GAAG,CAACc,QAAQ;UACtBW,OAAO,EAAEzB,GAAG,CAACmB,IAAI,KAAK,OAAO,IAAInB,GAAG,CAACmB,IAAI,KAAK,YAAY;UAC1DO,OAAO,EAAE1B,GAAG,CAACmB,IAAI,KAAK,OAAO;UAC7BQ,MAAM,EAAE3B,GAAG,CAACmB,IAAI,KAAK,MAAM;UAC3BS,QAAQ,EAAE5B,GAAG,CAACiB,UAAU,IAAIjB,GAAG,CAACkB,SAAS;UACzCW,eAAe,EAAE7B,GAAG,CAAC6B,eAAe,IAAI7B,GAAG,CAACc,QAAQ,KAAK,QAAQ;UACjEgB,OAAO,EAAE9B,GAAG,CAACmB,IAAI,KAAK,MAAM,IAAI,EAAAf,iBAAA,GAAAJ,GAAG,CAACoB,WAAW,cAAAhB,iBAAA,uBAAfA,iBAAA,CAAiB2B,MAAM,IAAG,CAAC,IAAA1B,kBAAA,GAAGL,GAAG,CAACoB,WAAW,CAAC,CAAC,CAAC,cAAAf,kBAAA,uBAAlBA,kBAAA,CAAoB9D,GAAG,GAAG,IAAI;UAC5FyF,QAAQ,EAAEhC,GAAG,CAACmB,IAAI,KAAK,MAAM,IAAI,EAAAb,iBAAA,GAAAN,GAAG,CAACoB,WAAW,cAAAd,iBAAA,uBAAfA,iBAAA,CAAiByB,MAAM,IAAG,CAAC,IAAAxB,kBAAA,GAAGP,GAAG,CAACoB,WAAW,CAAC,CAAC,CAAC,cAAAb,kBAAA,uBAAlBA,kBAAA,CAAoBlI,IAAI,GAAG,IAAI;UAC9F4J,QAAQ,EAAEjC,GAAG,CAACmB,IAAI,KAAK,MAAM,IAAI,EAAAX,iBAAA,GAAAR,GAAG,CAACoB,WAAW,cAAAZ,iBAAA,uBAAfA,iBAAA,CAAiBuB,MAAM,IAAG,CAAC,IAAAtB,kBAAA,GAAGT,GAAG,CAACoB,WAAW,CAAC,CAAC,CAAC,cAAAX,kBAAA,uBAAlBA,kBAAA,CAAoBU,IAAI,GAAG,IAAI;UAC9Fe,QAAQ,EAAElC,GAAG,CAACmB,IAAI,KAAK,OAAO,IAAI,EAAAT,iBAAA,GAAAV,GAAG,CAACoB,WAAW,cAAAV,iBAAA,uBAAfA,iBAAA,CAAiBqB,MAAM,IAAG,CAAC,IAAApB,kBAAA,GAAGX,GAAG,CAACoB,WAAW,CAAC,CAAC,CAAC,cAAAT,kBAAA,uBAAlBA,kBAAA,CAAoBuB,QAAQ,GAAG,IAAI;UACrGC,WAAW,EAAE,IAAIjL,IAAI,CAAC,CAAC,CAACkL,kBAAkB,CAAC,CAAC,CAAE;QAChD,CAAC;MAAA,CAAC,CAAC,CACFpE,MAAM,CAAEgC,GAAG,IAAKA,GAAG,CAACzI,EAAE,CAAC,EAAC;;MAE3B;MACA,IAAIwI,cAAc,CAACgC,MAAM,KAAK,CAAC,IAAI,CAAChC,cAAc,CAACvB,IAAI,CAAEwB,GAAG,IAAKA,GAAG,CAAC6B,eAAe,CAAC,EAAE;QACrF,MAAMQ,aAAa,GAAG5C,OAAO,GACzB,kCAAkC,GAClC,2DAA2D;QAC/DM,cAAc,CAACuC,OAAO,CAAC;UACrB/K,EAAE,EAAE,UAAUL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;UAC1B2J,QAAQ,EAAE,QAAQ;UAClBE,OAAO,EAAEqB,aAAa;UACtBhB,IAAI,EAAE,IAAInK,IAAI,CAAC,CAAC,CAACoK,kBAAkB,CAAC,EAAE,EAAE;YAAEC,IAAI,EAAE,SAAS;YAAEC,MAAM,EAAE;UAAU,CAAC,CAAC;UAC/EK,eAAe,EAAE;QACnB,CAAC,CAAC;MACJ;;MAEA;MACA,IAAIU,cAAc,GAAGxC,cAAc;MACnC;MACA,MAAMyC,gBAAgB,GAAG1E,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAAC;MACnF,MAAM6E,SAAS,GAAGD,gBAAgB,CAAChD,cAAc,CAAC,IAAI,EAAE;MACxDnI,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEmL,SAAS,CAAC;MACtD,MAAMC,YAAY,GAAGD,SAAS,CAACzE,MAAM,CACnC2E,QAAQ,IAAI,CAAC5C,cAAc,CAACvB,IAAI,CAACwB,GAAG,IAAIA,GAAG,CAACzI,EAAE,KAAKoL,QAAQ,CAACpL,EAAE,CAChE,CAAC;MACDgL,cAAc,GAAG,CAAC,GAAGxC,cAAc,EAAE,GAAG2C,YAAY,CAAC;MACrD;MACAH,cAAc,CAACK,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;QAC5B,MAAMC,KAAK,GAAG,IAAI7L,IAAI,CAAC2L,CAAC,CAACG,SAAS,IAAIH,CAAC,CAACxB,IAAI,IAAIwB,CAAC,CAACV,WAAW,CAAC;QAC9D,MAAMc,KAAK,GAAG,IAAI/L,IAAI,CAAC4L,CAAC,CAACE,SAAS,IAAIF,CAAC,CAACzB,IAAI,IAAIyB,CAAC,CAACX,WAAW,CAAC;QAC9D,OAAOY,KAAK,GAAGE,KAAK;MACtB,CAAC,CAAC;MACF5L,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAEiL,cAAc,CAAC;MACjEzJ,WAAW,CAACyJ,cAAc,CAAC;;MAE3B;MACA,MAAMW,KAAK,GAAGnD,cAAc,CACzB/B,MAAM,CAAEgC,GAAG,IAAK,CAACA,GAAG,CAACyB,OAAO,IAAIzB,GAAG,CAAC0B,OAAO,KAAK,CAAC1B,GAAG,CAAC4B,QAAQ,IAAI5B,GAAG,CAACgB,OAAO,CAAC,CAC7EtC,GAAG,CAAEsB,GAAG;QAAA,IAAAmD,iBAAA,EAAAC,kBAAA;QAAA,OAAM;UACb7L,EAAE,EAAEyI,GAAG,CAACzI,EAAE;UACV4J,IAAI,EAAEnB,GAAG,CAACyB,OAAO,GAAG,OAAO,GAAG,OAAO;UACrClF,GAAG,EAAEyD,GAAG,CAACgB,OAAO;UAChB3I,IAAI,EAAE2H,GAAG,CAACgC,QAAQ,KAAKhC,GAAG,CAACyB,OAAO,GAAG,WAAW,GAAG,WAAW,CAAC;UAC/D4B,IAAI,EAAErD,GAAG,CAACmC,WAAW;UACrBmB,IAAI,EAAE,EAAAH,iBAAA,GAAAnD,GAAG,CAACoB,WAAW,cAAA+B,iBAAA,wBAAAC,kBAAA,GAAfD,iBAAA,CAAkB,CAAC,CAAC,cAAAC,kBAAA,uBAApBA,kBAAA,CAAsBE,IAAI,KAAI,CAAC;UAAE;UACvCpB,QAAQ,EAAElC,GAAG,CAACkC;QAChB,CAAC;MAAA,CAAC,CAAC;MACLzI,aAAa,CAACyJ,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,EAAC;;MAE/B,MAAMC,KAAK,GAAGzD,cAAc,CACzB/B,MAAM,CAAEgC,GAAG,IAAKA,GAAG,CAAC2B,MAAM,IAAI,CAAC3B,GAAG,CAAC4B,QAAQ,IAAI5B,GAAG,CAAC8B,OAAO,CAAC,CAC3DpD,GAAG,CAAEsB,GAAG;QAAA,IAAAyD,aAAA,EAAAC,iBAAA,EAAAC,kBAAA;QAAA,OAAM;UACbpM,EAAE,EAAEyI,GAAG,CAACzI,EAAE;UACV4J,IAAI,EAAE,EAAAsC,aAAA,GAAAzD,GAAG,CAACgC,QAAQ,cAAAyB,aAAA,uBAAZA,aAAA,CAAcnE,KAAK,CAAC,GAAG,CAAC,CAACsE,GAAG,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,KAAI,MAAM;UAC5DtH,GAAG,EAAEyD,GAAG,CAAC8B,OAAO;UAChBzJ,IAAI,EAAE2H,GAAG,CAACgC,QAAQ;UAClBqB,IAAI,EAAErD,GAAG,CAACmC,WAAW;UACrBmB,IAAI,EAAE,EAAAI,iBAAA,GAAA1D,GAAG,CAACoB,WAAW,cAAAsC,iBAAA,wBAAAC,kBAAA,GAAfD,iBAAA,CAAkB,CAAC,CAAC,cAAAC,kBAAA,uBAApBA,kBAAA,CAAsBL,IAAI,KAAI;QACtC,CAAC;MAAA,CAAC,CAAC;MACL3J,YAAY,CAAC6J,KAAK,CAACD,OAAO,CAAC,CAAC,CAAC,EAAC;IAChC,CAAC,CAAC,OAAO9L,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD0E,SAAS,CAAC,0BAA0B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;MACrDtD,WAAW,CAAC,EAAE,CAAC,EAAC;MAChBW,aAAa,CAAC,EAAE,CAAC;MACjBE,YAAY,CAAC,EAAE,CAAC;IAClB,CAAC,SAAS;MACRgB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAC0B,OAAO,EAAEF,SAAS,EAAEhE,IAAI,CAACZ,EAAE,CAAC,CAAE;EACjC,CAAC;EAED,MAAMuM,sBAAsB,GAAG/N,WAAW,CACxC,MAAO0G,KAAK,IAAK;IACf,IAAI,CAACA,KAAK,EAAE,OAAO;MAAElE,QAAQ,EAAE,EAAE;MAAEE,MAAM,EAAE;IAAG,CAAC;IAC/CkC,UAAU,CAAC,IAAI,CAAC;IAChB,IAAIoJ,eAAe,GAAG,EAAE;IACxB,IAAIC,aAAa,GAAG,EAAE;IAEtB,IAAI;MACF;MACA3M,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;MAC9C,MAAM2M,eAAe,GAAG,MAAM5H,OAAO,CAAC,KAAK,EAAE,cAAc,EAAE,IAAI,EAAEI,KAAK,CAAC;MACzEpF,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAE2M,eAAe,CAAC;;MAErD;MACA;MACA,MAAMC,gBAAgB,GAAG,CAAAD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEE,OAAO,KAAI,EAAE;MACvD9M,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE4M,gBAAgB,CAAC;;MAEnD;MACA,MAAME,YAAY,GAAGF,gBAAgB,CAAClG,MAAM,CAACqG,MAAM,IACjDA,MAAM,IAAIA,MAAM,CAACjF,MAAM,IAAIiF,MAAM,CAACC,YACpC,CAAC;MAED,IAAIF,YAAY,CAACrC,MAAM,KAAKmC,gBAAgB,CAACnC,MAAM,EAAE;QACnD1K,OAAO,CAACC,GAAG,CAAC,gBAAgB4M,gBAAgB,CAACnC,MAAM,GAAGqC,YAAY,CAACrC,MAAM,kBAAkB,CAAC;MAC9F;MAEA,MAAMwC,aAAa,GAAGH,YAAY,CAAC1F,GAAG,CAAE2F,MAAM;QAAA,IAAAG,aAAA;QAAA,OAAM;UAClDjN,EAAE,EAAE8M,MAAM,CAACjF,MAAM;UACjB/G,IAAI,EAAEgM,MAAM,CAAC/J,QAAQ,MAAAkK,aAAA,GAAIH,MAAM,CAACI,KAAK,cAAAD,aAAA,uBAAZA,aAAA,CAAclF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAI,SAAS;UACjEhH,MAAM,EAAE+L,MAAM,CAAC5J,SAAS,IAAI,EAAE;UAC9B0G,IAAI,EAAE,SAAS;UACflE,MAAM,EAAE,QAAQ;UAAE;UAClBqH,YAAY,EAAED,MAAM,CAACC,YAAY;UAAE;UACnC9E,cAAc,EAAE,IAAI,CAAE;QACxB,CAAC;MAAA,CAAC,CAAC;;MAEH;MACAnI,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;MACxC,MAAMoN,YAAY,GAAG,MAAMrI,OAAO,CAAC,KAAK,EAAE,6BAA6B,EAAE,IAAI,EAAEI,KAAK,CAAC;MACrF,MAAMkI,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAAC;MAClC,IAAIF,YAAY,IAAI7E,KAAK,CAACC,OAAO,CAAC4E,YAAY,CAAC,EAAE;QAC/CA,YAAY,CAACG,OAAO,CAAEC,IAAI,IAAK;UAC7B,IAAIA,IAAI,CAACC,YAAY,IAAID,IAAI,CAACC,YAAY,CAAChD,MAAM,KAAK,CAAC,IAAI+C,IAAI,CAACtF,cAAc,EAAE;YAC9E,MAAMwF,WAAW,GAAGF,IAAI,CAACC,YAAY,CAACE,IAAI,CAAE1N,EAAE,IAAKA,EAAE,KAAKY,IAAI,CAACZ,EAAE,CAAC;YAClE,IAAIyN,WAAW,EAAE;cACfL,gBAAgB,CAACO,GAAG,CAACF,WAAW,EAAEF,IAAI,CAACtF,cAAc,CAAC;YACxD;UACF;QACF,CAAC,CAAC;MACJ;;MAEA;MACA+E,aAAa,CAACM,OAAO,CAAER,MAAM,IAAK;QAChC,IAAIM,gBAAgB,CAACQ,GAAG,CAACd,MAAM,CAAC9M,EAAE,CAAC,EAAE;UACnC8M,MAAM,CAAC7E,cAAc,GAAGmF,gBAAgB,CAACS,GAAG,CAACf,MAAM,CAAC9M,EAAE,CAAC;QACzD;MACF,CAAC,CAAC;;MAEF;MACA,MAAMoG,aAAa,GAAGG,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;;MAE/E;MACA,MAAMyH,mBAAmB,GAAG,IAAIT,GAAG,CAAC,CAAC;MACrCjH,aAAa,CAACkH,OAAO,CAACpG,OAAO,IAAI;QAC/B,IAAIA,OAAO,IAAIA,OAAO,CAAClH,EAAE,EAAE;UACzB8N,mBAAmB,CAACH,GAAG,CAACzG,OAAO,CAAClH,EAAE,EAAEkH,OAAO,CAAC;QAC9C;MACF,CAAC,CAAC;;MAEF;MACAsF,eAAe,GAAGQ,aAAa,CAAC7F,GAAG,CAAC2F,MAAM,IAAI;QAC5C,MAAMiB,eAAe,GAAGD,mBAAmB,CAACD,GAAG,CAACf,MAAM,CAAC9M,EAAE,CAAC;QAC1D,IAAI+N,eAAe,EAAE;UACnB;UACA,IAAI,CAACjB,MAAM,CAAC7E,cAAc,IAAI8F,eAAe,CAAC9F,cAAc,EAAE;YAC5D6E,MAAM,CAAC7E,cAAc,GAAG8F,eAAe,CAAC9F,cAAc;UACxD;UACA,OAAO;YAAE,GAAG8F,eAAe;YAAE,GAAGjB;UAAO,CAAC;QAC1C;QACA,OAAOA,MAAM;MACf,CAAC,CAAC;;MAEF;MACA7L,WAAW,CAACuL,eAAe,CAAC;MAC5B1G,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAAC2F,eAAe,CAAC,CAAC;MACtE1M,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEyM,eAAe,CAAChC,MAAM,CAAC;;MAEjE;MACA1K,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;MACjC,MAAMiO,cAAc,GAAG,MAAMlJ,OAAO,CAAC,KAAK,EAAE,aAAa,EAAE,IAAI,EAAEI,KAAK,CAAC;MACvEpF,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEiO,cAAc,CAAC;MAEnD,IAAIA,cAAc,IAAIA,cAAc,CAAC9M,MAAM,EAAE;QAC3C;QACA,MAAM+M,UAAU,GAAGD,cAAc,CAAC9M,MAAM,CAACuF,MAAM,CAC5CiB,KAAK,IAAKA,KAAK,CAACwG,OAAO,IAAIxG,KAAK,CAACwG,OAAO,CAACjH,IAAI,CAACkH,MAAM,IAAIA,MAAM,CAACtG,MAAM,KAAKjH,IAAI,CAACZ,EAAE,CACpF,CAAC;QACDF,OAAO,CAACC,GAAG,CAAC,yBAAyBkO,UAAU,CAACzD,MAAM,WAAWwD,cAAc,CAAC9M,MAAM,CAACsJ,MAAM,EAAE,CAAC;QAEhGiC,aAAa,GAAGwB,UAAU,CAAC9G,GAAG,CAAEO,KAAK;UAAA,IAAA0G,cAAA,EAAAC,eAAA;UAAA,OAAM;YACzC/G,OAAO,EAAEI,KAAK,CAACJ,OAAO;YACtBtH,EAAE,EAAE0H,KAAK,CAACJ,OAAO;YACjBxG,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;YAChBC,MAAM,EAAE2G,KAAK,CAACxE,SAAS,IAAI,EAAE;YAC7B0G,IAAI,EAAE,OAAO;YACb0E,OAAO,EAAE5G,KAAK,CAAC6G,KAAK;YACpBA,KAAK,EAAE7G,KAAK,CAAC6G,KAAK;YAClBL,OAAO,EAAExG,KAAK,CAACwG,OAAO,IAAI,EAAE;YAAE;YAC9BM,SAAS,EAAE,EAAAJ,cAAA,GAAA1G,KAAK,CAACwG,OAAO,cAAAE,cAAA,uBAAbA,cAAA,CAAejH,GAAG,CAACgH,MAAM,IAAIA,MAAM,CAACtG,MAAM,CAAC,KAAI,EAAE;YAAE;YAC9D4G,WAAW,EAAE/G,KAAK,CAAC+G,WAAW,MAAAJ,eAAA,GAAI3G,KAAK,CAACwG,OAAO,cAAAG,eAAA,uBAAbA,eAAA,CAAe7D,MAAM,KAAI,CAAC;YAC5DvC,cAAc,EAAEP,KAAK,CAACO,cAAc;YACpCwD,SAAS,EAAE/D,KAAK,CAAC+D;UACnB,CAAC;QAAA,CAAC,CAAC;QACHtK,SAAS,CAACsL,aAAa,CAAC;QACxB3G,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAAC4F,aAAa,CAAC,CAAC;QAClE3M,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE0M,aAAa,CAACjC,MAAM,CAAC;MAC/D;MAEA,OAAO;QAAExJ,QAAQ,EAAEwL,eAAe;QAAEtL,MAAM,EAAEuL;MAAc,CAAC;IAC7D,CAAC,CAAC,OAAOvM,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD0E,SAAS,CAAC,8BAA8B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;;MAEzD;MACA,IAAI;QACF,MAAMuB,aAAa,GAAGG,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;QAC/E,MAAMkB,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;QAE3E,IAAID,aAAa,CAACoE,MAAM,GAAG,CAAC,EAAE;UAC5B1K,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;UACzDkB,WAAW,CAACmF,aAAa,CAAC;UAC1BoG,eAAe,GAAGpG,aAAa;QACjC;QAEA,IAAImB,WAAW,CAACiD,MAAM,GAAG,CAAC,EAAE;UAC1B1K,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;UACvDoB,SAAS,CAACoG,WAAW,CAAC;UACtBkF,aAAa,GAAGlF,WAAW;QAC7B;MACF,CAAC,CAAC,OAAOmH,CAAC,EAAE;QACV5O,OAAO,CAACI,KAAK,CAAC,iDAAiD,EAAEwO,CAAC,CAAC;MACrE;MAEA,OAAO;QAAE1N,QAAQ,EAAEwL,eAAe;QAAEtL,MAAM,EAAEuL;MAAc,CAAC;IAC7D,CAAC,SAAS;MACRrJ,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAC0B,OAAO,EAAEF,SAAS,EAAEhE,IAAI,CAACZ,EAAE,CAAC,CAAE;EACjC,CAAC;EAED,MAAM2O,mBAAmB,GAAGnQ,WAAW,CACrC,MAAO0G,KAAK,IAAK;IACf,IAAI,CAACA,KAAK,EAAE;IACZ;IACA,IAAI;MACF,MAAMO,QAAQ,GAAG,MAAMX,OAAO,CAAC,KAAK,EAAE,gCAAgC,EAAE,IAAI,EAAEI,KAAK,CAAC;MACpFrB,iBAAiB,CAAC4B,QAAQ,CAACR,IAAI,IAAI,EAAE,CAAC;IACxC,CAAC,CAAC,OAAO/E,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChE;IACF;EACF,CAAC,EACD,CAAC4E,OAAO,CACV,CAAC;;EAED;;EAEA,MAAM8J,uBAAuB,GAAGpQ,WAAW,CACzC,OAAOiP,WAAW,EAAEvI,KAAK,KAAK;IAC5BpF,OAAO,CAACC,GAAG,CAAC,4CAA4C0N,WAAW,EAAE,CAAC;IACtE,IAAI,CAACvI,KAAK,IAAI,CAACuI,WAAW,EAAE;MAC1B,MAAM,IAAIzH,KAAK,CAAC,0DAA0D,CAAC;IAC7E;IACA,IAAI;MAAA,IAAA6I,qBAAA;MACF,MAAMpJ,QAAQ,GAAG,MAAMX,OAAO,CAAC,KAAK,EAAE,oCAAoC2I,WAAW,EAAE,EAAE,IAAI,EAAEvI,KAAK,CAAC;MACrG,IAAIO,QAAQ,aAARA,QAAQ,gBAAAoJ,qBAAA,GAARpJ,QAAQ,CAAEqJ,YAAY,cAAAD,qBAAA,eAAtBA,qBAAA,CAAwB5G,cAAc,EAAE;QAC1CnI,OAAO,CAACC,GAAG,CAAC,iDAAiD,EAAE0F,QAAQ,CAACqJ,YAAY,CAAC7G,cAAc,CAAC;QACpG,OAAOxC,QAAQ,CAACqJ,YAAY,CAAC7G,cAAc;MAC7C,CAAC,MAAM;QACL,MAAM,IAAIjC,KAAK,CAAC,kDAAkD,CAAC;MACrE;IACF,CAAC,CAAC,OAAO9F,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,IAAIA,KAAK,CAAC2E,OAAO,CAACtE,QAAQ,CAAC,KAAK,CAAC,IAAIL,KAAK,CAAC2E,OAAO,CAACtE,QAAQ,CAAC,wBAAwB,CAAC,EAAE;QACrF,MAAM,IAAIyF,KAAK,CAAC,oCAAoC,CAAC;MACvD;MACA,MAAM,IAAIA,KAAK,CAAC,sCAAsC9F,KAAK,CAAC2E,OAAO,EAAE,CAAC,EAAC;IACzE;EACF,CAAC,EACD,CAACC,OAAO,CACV,CAAC;;EAED;;EAEA,MAAMiK,mBAAmB,GAAGvQ,WAAW,CACrC,MAAOwQ,cAAc,IAAK;IACxB,IAAI,CAACA,cAAc,IAAIA,cAAc,CAAChP,EAAE,MAAKoB,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,GAAE;MAChEF,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;MAC9C,OAAM,CAAC;IACT;IAEA,MAAMmF,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;MACVN,SAAS,CAAC,yBAAyB,CAAC;MACpCjE,QAAQ,CAAC,QAAQ,CAAC;MAClB;IACF;IAEAb,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEiP,cAAc,CAACpF,IAAI,EAAEoF,cAAc,CAAClO,IAAI,EAAEkO,cAAc,CAAChP,EAAE,CAAC;;IAErF;IACA,IAAIoB,eAAe,EAAE;MACnB,MAAM6N,WAAW,GACf7N,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAGxI,eAAe,CAACkG,OAAO,GAAGlG,eAAe,CAAC6G,cAAc;MAC7F,IAAIgH,WAAW,EAAE;QACf,MAAMC,SAAS,GAAG9N,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAG,aAAa,GAAG,oBAAoB;QACzF/K,MAAM,CAACsQ,IAAI,CAACD,SAAS,EAAED,WAAW,CAAC;QACnCnP,OAAO,CAACC,GAAG,CAAC,QAAQqB,eAAe,CAACwI,IAAI,QAAQ,EAAEqF,WAAW,CAAC;MAChE;IACF;;IAEA;IACA1N,WAAW,CAAC,EAAE,CAAC;IACfW,aAAa,CAAC,EAAE,CAAC;IACjBE,YAAY,CAAC,EAAE,CAAC;IAChBf,kBAAkB,CAAC2N,cAAc,CAAC,EAAC;;IAEnC,IAAI;MACF5L,UAAU,CAAC,IAAI,CAAC,EAAC;;MAEjB,IAAI4L,cAAc,CAACpF,IAAI,KAAK,OAAO,EAAE;QACnC,MAAMtC,OAAO,GAAG0H,cAAc,CAAC1H,OAAO;QACtC;QACA,MAAMW,cAAc,GAAG+G,cAAc,CAAC/G,cAAc,IAAIX,OAAO;QAC/DzI,MAAM,CAACsQ,IAAI,CAAC,YAAY,EAAE7H,OAAO,CAAC;QAClCxH,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEuH,OAAO,CAAC;QAC1CxH,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEkI,cAAc,CAAC;QAC9D,MAAMD,aAAa,CAAC9C,KAAK,EAAE+C,cAAc,EAAE,IAAI,CAAC;MAClD,CAAC,MAAM;QACL;QACA,IAAIA,cAAc,GAAG+G,cAAc,CAAC/G,cAAc;;QAElD;QACA,IAAI,CAACA,cAAc,EAAE;UACnBnI,OAAO,CAACC,GAAG,CAAC,wDAAwD,CAAC;UACrE,IAAI;YACFkI,cAAc,GAAG,MAAM2G,uBAAuB,CAACI,cAAc,CAAChP,EAAE,EAAEkF,KAAK,CAAC;YACxE;YACA,MAAMkK,cAAc,GAAG;cAAE,GAAGJ,cAAc;cAAE/G;YAAe,CAAC;YAC5D5G,kBAAkB,CAAC+N,cAAc,CAAC,EAAC;YACnCnO,WAAW,CAAE8F,IAAI,IAAKA,IAAI,CAACI,GAAG,CAAET,CAAC,IAAMA,CAAC,CAAC1G,EAAE,KAAKgP,cAAc,CAAChP,EAAE,GAAGoP,cAAc,GAAG1I,CAAE,CAAC,CAAC;YACzF;YACA,MAAM2I,eAAe,GAAG9I,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;YACjF,MAAMiJ,mBAAmB,GAAGD,eAAe,CAAClI,GAAG,CAAET,CAAC,IAChDA,CAAC,CAAC1G,EAAE,KAAKgP,cAAc,CAAChP,EAAE,GAAGoP,cAAc,GAAG1I,CAChD,CAAC;YACDZ,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAACyI,mBAAmB,CAAC,CAAC;UAC5E,CAAC,CAAC,OAAOpP,KAAK,EAAE;YACd0E,SAAS,CAAC1E,KAAK,CAAC2E,OAAO,CAAC,EAAC;YACzBxD,kBAAkB,CAAC,IAAI,CAAC,EAAC;YACzB+B,UAAU,CAAC,KAAK,CAAC;YACjB,OAAM,CAAC;UACT;QACF;QAEA,IAAI6E,cAAc,EAAE;UAClBpJ,MAAM,CAACsQ,IAAI,CAAC,mBAAmB,EAAElH,cAAc,CAAC;UAChDnI,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEkI,cAAc,CAAC;UACxD,MAAMD,aAAa,CAAC9C,KAAK,EAAE+C,cAAc,EAAE,KAAK,CAAC;;UAEjD;UACA,IAAI;YACF,MAAMnD,OAAO,CAAC,KAAK,EAAE,+BAA+BmD,cAAc,OAAO,EAAE;cAAEsH,IAAI,EAAE;YAAK,CAAC,EAAErK,KAAK,CAAC;;YAEjG;YACAjE,WAAW,CAAE8F,IAAI,IACfA,IAAI,CAACI,GAAG,CAAET,CAAC,IACTA,CAAC,CAAC1G,EAAE,KAAKgP,cAAc,CAAChP,EAAE,GAAG;cAAE,GAAG0G,CAAC;cAAE8I,WAAW,EAAE;YAAE,CAAC,GAAG9I,CAC1D,CACF,CAAC;UACH,CAAC,CAAC,OAAO+I,SAAS,EAAE;YAClB3P,OAAO,CAACI,KAAK,CAAC,qCAAqC,EAAEuP,SAAS,CAAC;YAC/D;UACF;QACF,CAAC,MAAM;UACL;UACA7K,SAAS,CAAC,8CAA8C,CAAC;UACzDvD,kBAAkB,CAAC,IAAI,CAAC;QAC1B;MACF;IACF,CAAC,CAAC,OAAOnB,KAAK,EAAE;MACd;MACAJ,OAAO,CAACI,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChE0E,SAAS,CAAC,yBAAyB1E,KAAK,CAAC2E,OAAO,EAAE,CAAC;MACnDxD,kBAAkB,CAAC,IAAI,CAAC,EAAC;IAC3B,CAAC,SAAS;MACR+B,UAAU,CAAC,KAAK,CAAC,EAAC;IACpB;EACF,CAAC,EACD,CAAChC,eAAe,EAAE4G,aAAa,EAAE4G,uBAAuB,EAAEhK,SAAS,EAAEjE,QAAQ,EAAEmE,OAAO,EAAER,cAAc,CACxG,CAAC;;EAED;;EAEA,MAAMoL,iBAAiB,GAAGlR,WAAW,CACnC,MAAOkQ,CAAC,IAAK;IACXA,CAAC,CAACiB,cAAc,CAAC,CAAC;IAClB,IAAI,CAACnO,UAAU,CAACoO,IAAI,CAAC,CAAC,IAAI,CAAClO,WAAW,IAAI,CAACN,eAAe,EAAE;IAE5D,MAAM8D,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;MACVN,SAAS,CAAC,yBAAyB,CAAC;MACpC;IACF;IAEA,MAAMiL,aAAa,GAAG,QAAQlQ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IAC1C,MAAMkQ,WAAW,GAAG,IAAInQ,IAAI,CAAC,CAAC,CAACoK,kBAAkB,CAAC,EAAE,EAAE;MAAEC,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU,CAAC,CAAC;;IAE7F;IACA,MAAM8F,iBAAiB,GAAG;MACxB/P,EAAE,EAAE6P,aAAa;MACjBvG,MAAM,EAAE,IAAI;MACZG,OAAO,EAAEjI,UAAU;MACnBsI,IAAI,EAAEgG,WAAW;MACjBvG,QAAQ,EAAE3I,IAAI,CAACZ,EAAE;MACjBgQ,SAAS,EAAE,IAAI,CAAE;IACnB,CAAC;IACDzO,WAAW,CAAEwF,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAEgJ,iBAAiB,CAAC,CAAC;IACnD,MAAME,aAAa,GAAGzO,UAAU,EAAC;IACjCC,aAAa,CAAC,EAAE,CAAC,EAAC;IAClByO,cAAc,CAAC,CAAC,EAAC;;IAEjB,IAAI;MACF,IAAIzK,QAAQ;MACZ,IAAI0K,oBAAoB;MAExB,IAAI/O,eAAe,CAACwI,IAAI,KAAK,OAAO,EAAE;QAAA,IAAAwG,qBAAA;QACpC,MAAM9I,OAAO,GAAGlG,eAAe,CAACkG,OAAO;QACvCxH,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE;UAC/CuH,OAAO;UACP+I,cAAc,EAAEJ,aAAa;UAC7B7O;QACF,CAAC,CAAC;QAEF,IAAI,CAACkG,OAAO,EAAE;UACZ,MAAM,IAAItB,KAAK,CAAC,oBAAoB,CAAC;QACvC;;QAEA;QACA,IAAI,GAAAoK,qBAAA,GAAChP,eAAe,CAACoN,SAAS,cAAA4B,qBAAA,eAAzBA,qBAAA,CAA2B7P,QAAQ,CAACK,IAAI,CAACZ,EAAE,CAAC,GAAE;UACjDF,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAE;YAC1C2H,MAAM,EAAEjH,IAAI,CAACZ,EAAE;YACfwO,SAAS,EAAEpN,eAAe,CAACoN,SAAS;YACpCN,OAAO,EAAE9M,eAAe,CAAC8M;UAC3B,CAAC,CAAC;UACF,MAAM,IAAIlI,KAAK,CAAC,2CAA2C,CAAC;QAC9D;QAEA,IAAI;UACFP,QAAQ,GAAG,MAAMX,OAAO,CACtB,MAAM,EACN,eAAewC,OAAO,WAAW,EACjC;YAAEmC,OAAO,EAAEwG;UAAc,CAAC,EAC1B/K,KACF,CAAC;UAEDpF,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAE0F,QAAQ,CAAC;UAEpD,IAAI,CAACA,QAAQ,EAAE;YACb,MAAM,IAAIO,KAAK,CAAC,yBAAyB,CAAC;UAC5C;UAEA,IAAI,CAACP,QAAQ,CAAC6K,WAAW,EAAE;YACzBxQ,OAAO,CAACI,KAAK,CAAC,6BAA6B,EAAEuF,QAAQ,CAAC;YACtD,MAAM,IAAIO,KAAK,CAAC,wCAAwC,CAAC;UAC3D;UAEA,MAAMsK,WAAW,GAAG7K,QAAQ,CAAC6K,WAAW;UACxCH,oBAAoB,GAAG;YACrB9G,SAAS,EAAEiH,WAAW,CAACjH,SAAS;YAChC/B,OAAO,EAAEA,OAAO;YAChBiC,QAAQ,EAAE3I,IAAI,CAACZ,EAAE;YACjBwJ,UAAU,EAAE5I,IAAI,CAACE,IAAI;YACrB2I,OAAO,EAAEwG,aAAa;YACtBrG,IAAI,EAAE,MAAM;YACZ6B,SAAS,EAAE6E,WAAW,CAAC7E,SAAS,IAAI,IAAI9L,IAAI,CAAC,CAAC,CAACmI,WAAW,CAAC;UAC7D,CAAC;UAEDhI,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEoQ,oBAAoB,CAAC;UACrEtR,MAAM,CAACsQ,IAAI,CAAC,eAAe,EAAEgB,oBAAoB,CAAC;;UAElD;UACA5O,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IACXA,GAAG,CAACzI,EAAE,KAAK6P,aAAa,GACpB;YACE,GAAGpH,GAAG;YACNzI,EAAE,EAAEsQ,WAAW,CAACjH,SAAS;YACzB2G,SAAS,EAAE,KAAK;YAChBlG,IAAI,EAAE,IAAInK,IAAI,CAAC2Q,WAAW,CAAC7E,SAAS,CAAC,CAAC1B,kBAAkB,CAAC,EAAE,EAAE;cAC3DC,IAAI,EAAE,SAAS;cACfC,MAAM,EAAE;YACV,CAAC;UACH,CAAC,GACDxB,GACN,CACF,CAAC;QACH,CAAC,CAAC,OAAOvI,KAAK,EAAE;UAAA,IAAAqQ,gBAAA,EAAAC,gBAAA;UACd1Q,OAAO,CAACI,KAAK,CAAC,gBAAgB,EAAE;YAC9BA,KAAK;YACLoH,OAAO;YACPlG,eAAe;YACfR,IAAI,EAAE;cAAEZ,EAAE,EAAEY,IAAI,CAACZ,EAAE;cAAEc,IAAI,EAAEF,IAAI,CAACE;YAAK;UACvC,CAAC,CAAC;UAEF,IAAI,EAAAyP,gBAAA,GAAArQ,KAAK,CAACuF,QAAQ,cAAA8K,gBAAA,uBAAdA,gBAAA,CAAgB7K,MAAM,MAAK,GAAG,EAAE;YAClC,MAAM,IAAIM,KAAK,CAAC,0BAA0B,CAAC;UAC7C,CAAC,MAAM,IAAI,EAAAwK,gBAAA,GAAAtQ,KAAK,CAACuF,QAAQ,cAAA+K,gBAAA,uBAAdA,gBAAA,CAAgB9K,MAAM,MAAK,GAAG,EAAE;YACzC,MAAM,IAAIM,KAAK,CAAC,gDAAgD,CAAC;UACnE,CAAC,MAAM;YACL,MAAM9F,KAAK;UACb;QACF;MACF,CAAC,MAAM;QAAA,IAAAuQ,qBAAA,EAAAC,sBAAA;QACL;QACA,MAAMzI,cAAc,GAAG7G,eAAe,CAAC6G,cAAc;QACrD,IAAI,CAACA,cAAc,EAAE;UACnB,MAAM,IAAIjC,KAAK,CAAC,gDAAgD,CAAC;QACnE;QACAP,QAAQ,GAAG,MAAMX,OAAO,CACtB,MAAM,EACN,yBAAyB,EACzB;UACEmD,cAAc,EAAEA,cAAc;UAC9BwB,OAAO,EAAEwG,aAAa;UACtBJ,aAAa,EAAEA,aAAa,CAAC;QAC/B,CAAC,EACD3K,KACF,CAAC;QACDiL,oBAAoB,GAAG;UACrB9G,SAAS,EAAE,EAAAoH,qBAAA,GAAAhL,QAAQ,CAAC6K,WAAW,cAAAG,qBAAA,uBAApBA,qBAAA,CAAsBpH,SAAS,KAAI5D,QAAQ,CAAC4D,SAAS;UAChEwG,aAAa,EAAEA,aAAa;UAAE;UAC9B5H,cAAc,EAAEA,cAAc;UAC9BsB,QAAQ,EAAE3I,IAAI,CAACZ,EAAE;UACjBwJ,UAAU,EAAE5I,IAAI,CAACE,IAAI;UACrB6P,UAAU,EAAEvP,eAAe,CAACpB,EAAE;UAC9ByJ,OAAO,EAAEwG,aAAa;UACtBrG,IAAI,EAAE,MAAM;UACZ6B,SAAS,EAAE,EAAAiF,sBAAA,GAAAjL,QAAQ,CAAC6K,WAAW,cAAAI,sBAAA,uBAApBA,sBAAA,CAAsBjF,SAAS,KAAI,IAAI9L,IAAI,CAAC,CAAC,CAACmI,WAAW,CAAC,CAAC;UACtEgC,IAAI,EAAEgG,WAAW,CAAC;QACpB,CAAC;QACDjR,MAAM,CAACsQ,IAAI,CAAC,aAAa,EAAEgB,oBAAoB,CAAC;MAClD;IACF,CAAC,CAAC,OAAOjQ,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C0E,SAAS,CAAC,0BAA0B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;MACrD;MACAtD,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IAAMA,GAAG,CAACzI,EAAE,KAAK6P,aAAa,GAAG;QAAE,GAAGpH,GAAG;QAAEuH,SAAS,EAAE,KAAK;QAAEY,OAAO,EAAE;MAAK,CAAC,GAAGnI,GAAI,CAClG,CAAC;IACH;EACF,CAAC,EACD,CAACjH,UAAU,EAAEE,WAAW,EAAEN,eAAe,EAAE0D,OAAO,EAAEF,SAAS,EAAEhE,IAAI,CAACZ,EAAE,EAAEY,IAAI,CAACE,IAAI,CACnF,CAAC;;EAED;;EAEA,MAAM+P,cAAc,GAAGrS,WAAW,CAChC,OAAOsS,IAAI,EAAEpG,QAAQ,GAAG,MAAM,KAAK;IACjC;IACA,IAAI,CAACoG,IAAI,IAAI,CAACpP,WAAW,IAAI,CAACN,eAAe,EAAE;IAE/C,MAAM8D,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;MACVN,SAAS,CAAC,yBAAyB,CAAC;MACpC;IACF;;IAEA;IACA,MAAMmM,OAAO,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,EAAC;IACjC,IAAID,IAAI,CAAC/E,IAAI,GAAGgF,OAAO,EAAE;MACvBnM,SAAS,CAAC,wBAAwBmM,OAAO,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;MAC/D;IACF;IACA,IAAIrG,QAAQ,KAAK,OAAO,IAAI,CAACoG,IAAI,CAAClH,IAAI,CAACoH,UAAU,CAAC,QAAQ,CAAC,EAAE;MAC3DpM,SAAS,CAAC,8BAA8B,CAAC;MACzC;IACF;IACA,IAAI8F,QAAQ,KAAK,OAAO,IAAI,CAACoG,IAAI,CAAClH,IAAI,CAACoH,UAAU,CAAC,QAAQ,CAAC,EAAE;MAC3DpM,SAAS,CAAC,2BAA2B,CAAC;MACtC;IACF;;IAEA;IACA,IAAIqM,aAAa,GAAG,IAAI;IACxB,IAAIvG,QAAQ,KAAK,OAAO,EAAE;MACxB,IAAI;QACF,MAAMC,QAAQ,GAAG,MAAMuG,gBAAgB,CAACJ,IAAI,CAAC;QAC7C,IAAInG,QAAQ,GAAG,EAAE,EAAE;UACjB/F,SAAS,CAAC,mCAAmC,CAAC;UAC9C;QACF;QACAqM,aAAa,GAAGE,IAAI,CAACC,KAAK,CAACzG,QAAQ,CAAC;MACtC,CAAC,CAAC,OAAO1K,GAAG,EAAE;QACZ2E,SAAS,CAAC,gCAAgC,CAAC;QAC3C;MACF;IACF;IAEA,MAAMiL,aAAa,GAAG,aAAalQ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IAC/C,MAAMkQ,WAAW,GAAG,IAAInQ,IAAI,CAAC,CAAC,CAACoK,kBAAkB,CAAC,EAAE,EAAE;MAAEC,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU,CAAC,CAAC;IAC7F,MAAMoH,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACT,IAAI,CAAC,EAAC;;IAE1C;IACA,MAAMf,iBAAiB,GAAG;MACxB/P,EAAE,EAAE6P,aAAa;MACjBvG,MAAM,EAAE,IAAI;MACZG,OAAO,EAAEiB,QAAQ,KAAK,MAAM,GAAGoG,IAAI,CAAChQ,IAAI,GAAGuQ,OAAO;MAAE;MACpDvH,IAAI,EAAEgG,WAAW;MACjBvG,QAAQ,EAAE3I,IAAI,CAACZ,EAAE;MACjBgQ,SAAS,EAAE,IAAI;MACf5F,MAAM,EAAEM,QAAQ,KAAK,MAAM;MAC3BR,OAAO,EAAEQ,QAAQ,KAAK,OAAO;MAC7BP,OAAO,EAAEO,QAAQ,KAAK,OAAO;MAC7BD,QAAQ,EAAEqG,IAAI,CAAChQ,IAAI;MACnB4J,QAAQ,EAAEoG,IAAI,CAAClH,IAAI;MACnBe,QAAQ,EAAEsG;IACZ,CAAC;IACD1P,WAAW,CAAEwF,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAEgJ,iBAAiB,CAAC,CAAC;IACnDG,cAAc,CAAC,CAAC;IAEhB,MAAMsB,QAAQ,GAAG,IAAIpM,QAAQ,CAAC,CAAC;IAC/B,IAAIqM,MAAM,GAAG,EAAE;IACf,IAAIC,MAAM,GAAG,EAAE,EAAC;;IAEhB,IAAItQ,eAAe,CAACwI,IAAI,KAAK,OAAO,EAAE;MACpC,MAAMtC,OAAO,GAAGlG,eAAe,CAACkG,OAAO;MACvCkK,QAAQ,CAACG,MAAM,CAAC,SAAS,EAAErK,OAAO,CAAC;MACnC,QAAQoD,QAAQ;QACd,KAAK,OAAO;UACV+G,MAAM,GAAG,eAAenK,OAAO,SAAS;UACxCoK,MAAM,GAAG,OAAO,EAAC;UACjB;QACF,KAAK,OAAO;UACVD,MAAM,GAAG,eAAenK,OAAO,SAAS;UACxCoK,MAAM,GAAG,OAAO;UAChB;QACF;UAAS;UACPD,MAAM,GAAG,eAAenK,OAAO,QAAQ;UACvCoK,MAAM,GAAG,MAAM;UACf;MACJ;IACF,CAAC,MAAM;MACL,MAAMzJ,cAAc,GAAG7G,eAAe,CAAC6G,cAAc;MACrD,IAAI,CAACA,cAAc,EAAE;QACnBrD,SAAS,CAAC,4CAA4C,CAAC;QACvD0M,GAAG,CAACM,eAAe,CAACP,OAAO,CAAC;QAC5B9P,WAAW,CAAEwF,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEgC,GAAG,IAAKA,GAAG,CAACzI,EAAE,KAAK6P,aAAa,CAAC,CAAC,EAAC;QACtE;MACF;MACA2B,QAAQ,CAACG,MAAM,CAAC,gBAAgB,EAAE1J,cAAc,CAAC;MACjD,QAAQyC,QAAQ;QACd,KAAK,OAAO;UACV+G,MAAM,GAAG,0BAA0B;UACnCC,MAAM,GAAG,QAAQ,EAAC;UAClB;QACF,KAAK,OAAO;UACVD,MAAM,GAAG,0BAA0B;UACnCC,MAAM,GAAG,OAAO;UAChB;QACF;UAAS;UACPD,MAAM,GAAG,yBAAyB;UAClCC,MAAM,GAAG,MAAM;UACf;MACJ;IACF;IAEAF,QAAQ,CAACG,MAAM,CAACD,MAAM,EAAEZ,IAAI,CAAC;IAE7B,IAAI;MAAA,IAAAe,qBAAA;MACF,MAAMpM,QAAQ,GAAG,MAAMX,OAAO,CAAC,MAAM,EAAE2M,MAAM,EAAED,QAAQ,EAAEtM,KAAK,CAAC;MAC/D,MAAMoL,WAAW,GAAG7K,QAAQ,CAAC6K,WAAW,IAAI7K,QAAQ,EAAC;MACrD,MAAMqM,UAAU,IAAAD,qBAAA,GAAGvB,WAAW,CAACzG,WAAW,cAAAgI,qBAAA,uBAAvBA,qBAAA,CAA0B,CAAC,CAAC;MAE/C,IAAI,CAACvB,WAAW,IAAI,CAACA,WAAW,CAACjH,SAAS,IAAI,CAACyI,UAAU,IAAI,CAACA,UAAU,CAAC9M,GAAG,EAAE;QAC5E,MAAM,IAAIgB,KAAK,CAAC,6CAA6C,CAAC;MAChE;;MAEA;MACAzE,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IACXA,GAAG,CAACzI,EAAE,KAAK6P,aAAa,GACpB;QACE,GAAGpH,GAAG;QACNzI,EAAE,EAAEsQ,WAAW,CAACjH,SAAS;QACzBI,OAAO,EAAEqI,UAAU,CAAC9M,GAAG;QAAE;QACzBuF,OAAO,EAAEG,QAAQ,KAAK,MAAM,GAAGoH,UAAU,CAAC9M,GAAG,GAAG,IAAI;QACpDgL,SAAS,EAAE,KAAK;QAChBlG,IAAI,EAAE,IAAInK,IAAI,CAAC2Q,WAAW,CAAC7E,SAAS,CAAC,CAAC1B,kBAAkB,CAAC,EAAE,EAAE;UAC3DC,IAAI,EAAE,SAAS;UACfC,MAAM,EAAE;QACV,CAAC;MACH,CAAC,GACDxB,GACN,CACF,CAAC;;MAED;MACA,MAAMsJ,OAAO,GAAG;QACd/R,EAAE,EAAEsQ,WAAW,CAACjH,SAAS;QACzBO,IAAI,EAAEc,QAAQ,KAAK,MAAM,GAAGoG,IAAI,CAAChQ,IAAI,CAACiH,KAAK,CAAC,GAAG,CAAC,CAACsE,GAAG,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG5B,QAAQ;QAC/E1F,GAAG,EAAE8M,UAAU,CAAC9M,GAAG;QACnBlE,IAAI,EAAEgR,UAAU,CAAChR,IAAI,IAAIgQ,IAAI,CAAChQ,IAAI;QAClCgL,IAAI,EAAE,IAAInM,IAAI,CAAC2Q,WAAW,CAAC7E,SAAS,CAAC,CAACZ,kBAAkB,CAAC,CAAC;QAC1DkB,IAAI,EAAE+F,UAAU,CAAC/F,IAAI,IAAI+E,IAAI,CAAC/E,IAAI;QAClCpB,QAAQ,EAAED,QAAQ,KAAK,OAAO,GAAGuG,aAAa,IAAIa,UAAU,CAACnH,QAAQ,GAAG;MAC1E,CAAC;MACD,IAAID,QAAQ,KAAK,OAAO,IAAIA,QAAQ,KAAK,OAAO,EAAE;QAChDxI,aAAa,CAAE6E,IAAI,IAAK,CAACgL,OAAO,EAAE,GAAGhL,IAAI,CAAC,CAAC,EAAC;MAC9C,CAAC,MAAM;QACL3E,YAAY,CAAE2E,IAAI,IAAK,CAACgL,OAAO,EAAE,GAAGhL,IAAI,CAAC,CAAC;MAC5C;;MAEA;MACA,MAAMiL,eAAe,GAAG;QACtB3I,SAAS,EAAEiH,WAAW,CAACjH,SAAS;QAChCpB,cAAc,EAAE7G,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAG,IAAI,GAAGxI,eAAe,CAAC6G,cAAc;QACxFX,OAAO,EAAElG,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAGxI,eAAe,CAACkG,OAAO,GAAG,IAAI;QAC1EiC,QAAQ,EAAE3I,IAAI,CAACZ,EAAE;QACjBwJ,UAAU,EAAE5I,IAAI,CAACE,IAAI;QACrB6P,UAAU,EAAEvP,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAG,IAAI,GAAGxI,eAAe,CAACpB,EAAE;QACxE4J,IAAI,EAAEc,QAAQ;QAAE;QAChBjB,OAAO,EAAEiB,QAAQ,KAAK,MAAM,GAAG,SAASoH,UAAU,CAAChR,IAAI,IAAIgQ,IAAI,CAAChQ,IAAI,EAAE,GAAG,IAAI;QAAE;QAC/E+I,WAAW,EAAEyG,WAAW,CAACzG,WAAW;QACpC4B,SAAS,EAAE6E,WAAW,CAAC7E,SAAS,IAAI,IAAI9L,IAAI,CAAC,CAAC,CAACmI,WAAW,CAAC,CAAC;QAC5D6C,QAAQ,EAAED,QAAQ,KAAK,OAAO,GAAGuG,aAAa,IAAIa,UAAU,CAACnH,QAAQ,GAAG;MAC1E,CAAC;MACD,MAAMsH,eAAe,GAAG7Q,eAAe,CAACwI,IAAI,KAAK,OAAO,GAAG,eAAe,GAAG,aAAa;MAC1F/K,MAAM,CAACsQ,IAAI,CAAC8C,eAAe,EAAED,eAAe,CAAC;MAE7CV,GAAG,CAACM,eAAe,CAACP,OAAO,CAAC,EAAC;IAC/B,CAAC,CAAC,OAAOnR,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,iBAAiBwK,QAAQ,GAAG,EAAExK,KAAK,CAAC;MAClD0E,SAAS,CAAC,iBAAiB8F,QAAQ,KAAKxK,KAAK,CAAC2E,OAAO,EAAE,CAAC;MACxDtD,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IAAMA,GAAG,CAACzI,EAAE,KAAK6P,aAAa,GAAG;QAAE,GAAGpH,GAAG;QAAEuH,SAAS,EAAE,KAAK;QAAEY,OAAO,EAAE;MAAK,CAAC,GAAGnI,GAAI,CAClG,CAAC;MACD6I,GAAG,CAACM,eAAe,CAACP,OAAO,CAAC;IAC9B;EACF,CAAC,EACD,CAAC3P,WAAW,EAAEN,eAAe,EAAE0D,OAAO,EAAEF,SAAS,EAAEhE,IAAI,CAACZ,EAAE,EAAEY,IAAI,CAACE,IAAI,CACvE,CAAC;EAED,MAAMoQ,gBAAgB,GAAIJ,IAAI,IAAK;IACjC,OAAO,IAAIoB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,KAAK,GAAGC,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;MAC7CF,KAAK,CAACG,OAAO,GAAG,UAAU;MAC1BH,KAAK,CAACI,gBAAgB,GAAG,MAAM;QAC7BnB,GAAG,CAACM,eAAe,CAACS,KAAK,CAACK,GAAG,CAAC;QAC9BP,OAAO,CAACE,KAAK,CAAC1H,QAAQ,CAAC;MACzB,CAAC;MACD0H,KAAK,CAACM,OAAO,GAAG,MAAM;QACpBrB,GAAG,CAACM,eAAe,CAACS,KAAK,CAACK,GAAG,CAAC;QAC9BN,MAAM,CAAC,IAAIpM,KAAK,CAAC,8BAA8B,CAAC,CAAC;MACnD,CAAC;MACDqM,KAAK,CAACK,GAAG,GAAGpB,GAAG,CAACC,eAAe,CAACT,IAAI,CAAC;IACvC,CAAC,CAAC;EACJ,CAAC;;EAED;;EAEA,MAAM8B,iBAAiB,GAAGpU,WAAW,CAAEqU,KAAK,IAAK;IAC/CpR,aAAa,CAAEsF,IAAI,IAAKA,IAAI,GAAG8L,KAAK,CAAC;IACrC/Q,kBAAkB,CAAC,KAAK,CAAC;EAC3B,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMgR,mBAAmB,GAAGtU,WAAW,CACrC,OAAO6K,SAAS,EAAE0J,MAAM,KAAK;IAC3B,IAAIA,MAAM,KAAK,QAAQ,EAAE;MACvB,MAAM7N,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;MAC3C,IAAI,CAACnB,KAAK,IAAI,CAAC9D,eAAe,EAAE;;MAEhC;MACA,MAAM4R,gBAAgB,GAAG,CAAC,GAAG1R,QAAQ,CAAC;MACtCC,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IACXA,GAAG,CAACzI,EAAE,KAAKqJ,SAAS,GAAG;QAAE,GAAGZ,GAAG;QAAEgB,OAAO,EAAE,aAAa;QAAEY,QAAQ,EAAE,IAAI;QAAE4I,UAAU,EAAE;MAAK,CAAC,GAAGxK,GAChG,CACF,CAAC;MAED,IAAI;QACF,IAAIrH,eAAe,CAACwI,IAAI,KAAK,OAAO,EAAE;UACpC,MAAM9E,OAAO,CAAC,QAAQ,EAAE,eAAe1D,eAAe,CAACkG,OAAO,aAAa+B,SAAS,EAAE,EAAE6J,SAAS,EAAEhO,KAAK,CAAC;QAC3G,CAAC,MAAM;UACL,MAAMJ,OAAO,CAAC,QAAQ,EAAE,iBAAiBuE,SAAS,EAAE,EAAE6J,SAAS,EAAEhO,KAAK,CAAC;QACzE;;QAEA;QACA3D,WAAW,CAAEwF,IAAI,IACfA,IAAI,CAACI,GAAG,CAAEsB,GAAG,IACXA,GAAG,CAACzI,EAAE,KAAKqJ,SAAS,GAAG;UAAE,GAAGZ,GAAG;UAAEgB,OAAO,EAAE,oBAAoB;UAAEwJ,UAAU,EAAE;QAAM,CAAC,GAAGxK,GACxF,CACF,CAAC;;QAED;QACAvG,aAAa,CAAE6E,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEkF,KAAK,IAAKA,KAAK,CAAC3L,EAAE,KAAKqJ,SAAS,CAAC,CAAC;QACvEjH,YAAY,CAAE2E,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAE0M,GAAG,IAAKA,GAAG,CAACnT,EAAE,KAAKqJ,SAAS,CAAC,CAAC;;QAElE;MACF,CAAC,CAAC,OAAOnJ,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;QAC/C0E,SAAS,CAAC,0BAA0B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;QACrD;QACAtD,WAAW,CAACyR,gBAAgB,CAAC;MAC/B;IACF;IACA;EACF,CAAC,EACD,CAAClO,OAAO,EAAE1D,eAAe,EAAEwD,SAAS,EAAEtD,QAAQ,CAAC,CAAE;EACnD,CAAC;EAED,MAAM8R,eAAe,GAAG5U,WAAW,CAAC,MAAM;IACxC8D,YAAY,CAAC,IAAI,CAAC;IAClBE,YAAY,CAAC,KAAK,CAAC;EACrB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM6Q,eAAe,GAAG7U,WAAW,CAAC,MAAM;IACxC8D,YAAY,CAAC,KAAK,CAAC;IACnBE,YAAY,CAAC,IAAI,CAAC;EACpB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM8Q,eAAe,GAAG9U,WAAW,CAAE+U,GAAG,IAAK;IAC3C7Q,YAAY,CAAC6Q,GAAG,CAAC;IACjB;IACA,IAAIA,GAAG,KAAK,UAAU,EAAE;MACtB,MAAMrO,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;MAC3C,IAAInB,KAAK,EAAE;QACTyJ,mBAAmB,CAACzJ,KAAK,CAAC;MAC5B;IACF;EACF,CAAC,EAAE,CAACyJ,mBAAmB,CAAC,CAAC,EAAC;;EAE1B,MAAM6E,kBAAkB,GAAGhV,WAAW,CAAC,MAAM;IAC3C;IACA,MAAMiV,WAAW,GAAGlN,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;IAC3EvD,cAAc,CAAC;MACbC,QAAQ,EAAE0Q,WAAW,CAAC1Q,QAAQ,IAAInC,IAAI,CAACE,IAAI,IAAI,EAAE;MACjDkC,SAAS,EAAEyQ,WAAW,CAACzQ,SAAS,GAAG,IAAIrD,IAAI,CAAC8T,WAAW,CAACzQ,SAAS,CAAC,CAAC8E,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;MACnG9E,MAAM,EAAEwQ,WAAW,CAACxQ,MAAM,IAAI,EAAE;MAChCC,SAAS,EAAEuQ,WAAW,CAACvQ,SAAS,IAAItC,IAAI,CAACG,MAAM,IAAI;IACrD,CAAC,CAAC;IACF6B,mBAAmB,CAAC,IAAI,CAAC;EAC3B,CAAC,EAAE,CAAChC,IAAI,CAACE,IAAI,EAAEF,IAAI,CAACG,MAAM,CAAC,CAAC,EAAC;;EAE7B,MAAM2S,uBAAuB,GAAGlV,WAAW,CAAC,MAAM;IAChDoE,mBAAmB,CAAC,KAAK,CAAC;EAC5B,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM+Q,kBAAkB,GAAGnV,WAAW,CACpC,MAAOsS,IAAI,IAAK;IACd;IACA,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAAClH,IAAI,CAACoH,UAAU,CAAC,QAAQ,CAAC,IAAIF,IAAI,CAAC/E,IAAI,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,EAAE;MAC3EnH,SAAS,CAAC,yCAAyC,CAAC;MACpD;IACF;IACA,MAAMM,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZ,MAAMsM,QAAQ,GAAG,IAAIpM,QAAQ,CAAC,CAAC;IAC/BoM,QAAQ,CAACG,MAAM,CAAC,QAAQ,EAAEb,IAAI,CAAC;IAE/B,IAAI;MACF1N,UAAU,CAAC,IAAI,CAAC,EAAC;MACjB,MAAMqC,QAAQ,GAAG,MAAMX,OAAO,CAAC,MAAM,EAAE,mBAAmB,EAAE0M,QAAQ,EAAEtM,KAAK,CAAC;MAC5E;MACApC,cAAc,CAAEiE,IAAI,KAAM;QAAE,GAAGA,IAAI;QAAE7D,SAAS,EAAEuC,QAAQ,CAACvC;MAAU,CAAC,CAAC,CAAC;MACtErC,OAAO,CAAEkG,IAAI,KAAM;QAAE,GAAGA,IAAI;QAAEhG,MAAM,EAAE0E,QAAQ,CAACvC;MAAU,CAAC,CAAC,CAAC;MAC5D;MACA,MAAMuQ,WAAW,GAAGlN,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;MAC3EoN,WAAW,CAACvQ,SAAS,GAAGuC,QAAQ,CAACvC,SAAS;MAC1C4C,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAAC4M,WAAW,CAAC,CAAC;MAChE7O,SAAS,CAAC,mCAAmC,CAAC;IAChD,CAAC,CAAC,OAAO1E,KAAK,EAAE;MACd0E,SAAS,CAAC,wBAAwB,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;IACrD,CAAC,SAAS;MACRzB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAC0B,OAAO,EAAEF,SAAS,CACrB,CAAC;EAED,MAAMgP,mBAAmB,GAAGpV,WAAW,CAAC,YAAY;IAClD,MAAM0G,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZ,IAAI;MACF9B,UAAU,CAAC,IAAI,CAAC;MAChB,MAAMqC,QAAQ,GAAG,MAAMX,OAAO,CAC5B,KAAK,EACL,oBAAoB,EACpB;QACE/B,QAAQ,EAAEF,WAAW,CAACE,QAAQ;QAC9B;QACAC,SAAS,EAAEH,WAAW,CAACG,SAAS,GAAG,IAAIrD,IAAI,CAACkD,WAAW,CAACG,SAAS,CAAC,CAAC8E,WAAW,CAAC,CAAC,GAAGoL,SAAS;QAC5FjQ,MAAM,EAAEJ,WAAW,CAACI,MAAM,IAAIiQ,SAAS,CAAE;MAC3C,CAAC,EACDhO,KACF,CAAC;MACD;MACArE,OAAO,CAAEkG,IAAI,KAAM;QACjB,GAAGA,IAAI;QACPjG,IAAI,EAAE2E,QAAQ,CAAC1C,QAAQ,IAAIgE,IAAI,CAACjG;QAChC;MACF,CAAC,CAAC,CAAC;MACH;MACA,MAAM2S,WAAW,GAAGlN,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;MAC3EoN,WAAW,CAAC1Q,QAAQ,GAAG0C,QAAQ,CAAC1C,QAAQ;MACxC0Q,WAAW,CAACzQ,SAAS,GAAGyC,QAAQ,CAACzC,SAAS;MAC1CyQ,WAAW,CAACxQ,MAAM,GAAGwC,QAAQ,CAACxC,MAAM;MACpC6C,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAAC4M,WAAW,CAAC,CAAC;MAEhE7O,SAAS,CAAC,4BAA4B,CAAC;MACvC8O,uBAAuB,CAAC,CAAC;IAC3B,CAAC,CAAC,OAAOxT,KAAK,EAAE;MACd0E,SAAS,CAAC,4BAA4B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;IACzD,CAAC,SAAS;MACRzB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EAAE,CAAC0B,OAAO,EAAEjC,WAAW,EAAE+B,SAAS,EAAE8O,uBAAuB,CAAC,CAAC;EAE9D,MAAMG,eAAe,GAAGrV,WAAW,CAAC,MAAM;IACxC8E,qBAAqB,CAAC,IAAI,CAAC;EAC7B,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMwQ,yBAAyB,GAAGtV,WAAW,CAAC,MAAM;IAClD8E,qBAAqB,CAAC,KAAK,CAAC;IAC5BE,cAAc,CAAC,EAAE,CAAC,EAAC;EACrB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMuQ,qBAAqB,GAAGvV,WAAW,CAAC,YAAY;IACpD,IAAI,CAAC+E,WAAW,CAACqM,IAAI,CAAC,CAAC,EAAE;MACvBhL,SAAS,CAAC,qBAAqB,CAAC;MAChC;IACF;IACA,MAAMoP,UAAU,GAAG,4BAA4B;IAC/C,IAAI,CAACA,UAAU,CAACC,IAAI,CAAC1Q,WAAW,CAAC,EAAE;MACjCqB,SAAS,CAAC,qBAAqB,CAAC;MAChC;IACF;IAEA,MAAMM,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZ9B,UAAU,CAAC,IAAI,CAAC;IAChB,IAAI;MAAA,IAAA8Q,kBAAA;MACF;MACA,MAAMC,YAAY,GAAG,MAAMrP,OAAO,CAChC,KAAK,EACL,2BAA2BsP,kBAAkB,CAAC7Q,WAAW,CAAC,EAAE,EAC5D,IAAI,EACJ2B,KACF,CAAC;MACD,IAAI,EAACiP,YAAY,aAAZA,YAAY,gBAAAD,kBAAA,GAAZC,YAAY,CAAElP,IAAI,cAAAiP,kBAAA,eAAlBA,kBAAA,CAAoB1J,MAAM,GAAE;QAC/B,MAAM,IAAIxE,KAAK,CAAC,yCAAyC,CAAC;MAC5D;MACA,MAAM2K,UAAU,GAAGwD,YAAY,CAAClP,IAAI,CAAC,CAAC,CAAC,CAAC4C,MAAM;MAE9C,IAAI8I,UAAU,KAAK/P,IAAI,CAACZ,EAAE,EAAE;QAC1B,MAAM,IAAIgG,KAAK,CAAC,yCAAyC,CAAC;MAC5D;;MAEA;MACA,IAAIhF,QAAQ,CAACiG,IAAI,CAAEP,CAAC,IAAKA,CAAC,CAAC1G,EAAE,KAAK2Q,UAAU,CAAC,EAAE;QAC7C,MAAM,IAAI3K,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;MACA;MACA;MACA;MACA;;MAEA;MACA,MAAMlB,OAAO,CAAC,MAAM,EAAE,uBAAuB,EAAE;QAAE6L,UAAU;QAAE9L,OAAO,EAAE,cAAcjE,IAAI,CAACE,IAAI;MAAG,CAAC,EAAEoE,KAAK,CAAC;MACzGN,SAAS,CAAC,8BAA8BrB,WAAW,EAAE,CAAC;MACtDuQ,yBAAyB,CAAC,CAAC;IAC7B,CAAC,CAAC,OAAO5T,KAAK,EAAE;MACd;MACA,IAAIA,KAAK,CAAC2E,OAAO,CAACtE,QAAQ,CAAC,iBAAiB,CAAC,EAAE;QAC7CqE,SAAS,CAAC,UAAUrB,WAAW,gBAAgB,CAAC;MAClD,CAAC,MAAM,IAAIrD,KAAK,CAAC2E,OAAO,CAACtE,QAAQ,CAAC,sBAAsB,CAAC,EAAE;QACzDqE,SAAS,CAAC,kCAAkCrB,WAAW,YAAY,CAAC;MACtE,CAAC,MAAM,IAAIrD,KAAK,CAAC2E,OAAO,CAACtE,QAAQ,CAAC,gCAAgC,CAAC,EAAE;QACnEqE,SAAS,CAAC,GAAGrB,WAAW,6DAA6D,CAAC;MACxF,CAAC,MAAM;QACLqB,SAAS,CAAC,QAAQ1E,KAAK,CAAC2E,OAAO,IAAI,+BAA+B,EAAE,CAAC;MACvE;MACA;MACA;IACF,CAAC,SAAS;MACRzB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EAAE,CAACG,WAAW,EAAEuB,OAAO,EAAEF,SAAS,EAAEkP,yBAAyB,EAAElT,IAAI,CAACE,IAAI,EAAEF,IAAI,CAACZ,EAAE,EAAEgB,QAAQ,CAAC,CAAC;EAE9F,MAAMqT,4BAA4B,GAAG7V,WAAW,CAC9C,OAAO8V,SAAS,EAAEvB,MAAM,KAAK;IAC3B,MAAM7N,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZ,MAAMqP,OAAO,GAAG3Q,cAAc,CAAC8J,IAAI,CAAE8G,GAAG,IAAKA,GAAG,CAACF,SAAS,KAAKA,SAAS,CAAC;IACzE,IAAI,CAACC,OAAO,EAAE;IAEdnR,UAAU,CAAC,IAAI,CAAC,EAAC;IACjB;IACAS,iBAAiB,CAAEkD,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAE+N,GAAG,IAAKA,GAAG,CAACF,SAAS,KAAKA,SAAS,CAAC,CAAC;IAE9E,IAAI;MACF,MAAM7O,QAAQ,GAAG,MAAMX,OAAO,CAAC,MAAM,EAAE,+BAA+B,EAAE;QAAEwP,SAAS;QAAEvB;MAAO,CAAC,EAAE7N,KAAK,CAAC;MACrGpF,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE0F,QAAQ,CAAC;MAEjD,IAAIsN,MAAM,KAAK,QAAQ,EAAE;QAAA,IAAA0B,sBAAA,EAAAC,iBAAA;QACvB9P,SAAS,CAAC,8BAA8B,CAAC;QACzC,MAAM+P,UAAU,GAAGJ,OAAO,CAACjL,MAAM;QACjC,IAAI,CAACqL,UAAU,IAAI,CAACA,UAAU,CAAC9M,MAAM,EAAE;UACrC,MAAM,IAAI7B,KAAK,CAAC,kCAAkC,CAAC;QACrD;;QAEA;QACA,IAAIiC,cAAc,IAAAwM,sBAAA,GAAGhP,QAAQ,CAACqJ,YAAY,cAAA2F,sBAAA,uBAArBA,sBAAA,CAAuBxM,cAAc;QAC1D,IAAI,CAACA,cAAc,EAAE;UACnBnI,OAAO,CAACC,GAAG,CAAC,oDAAoD,CAAC;UACjEkI,cAAc,GAAG,MAAM2G,uBAAuB,CAAC+F,UAAU,CAAC9M,MAAM,EAAE3C,KAAK,CAAC;QAC1E;QAEA,IAAI,CAAC+C,cAAc,EAAE;UACnB,MAAM,IAAIjC,KAAK,CAAC,wCAAwC,CAAC;QAC3D;;QAEA;QACA,MAAMG,UAAU,GAAG;UACjBnG,EAAE,EAAE2U,UAAU,CAAC9M,MAAM;UACrB/G,IAAI,EAAE6T,UAAU,CAAC5R,QAAQ,MAAA2R,iBAAA,GAAIC,UAAU,CAACzH,KAAK,cAAAwH,iBAAA,uBAAhBA,iBAAA,CAAkB3M,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAI,SAAS;UACzEhH,MAAM,EAAE4T,UAAU,CAACzR,SAAS,IAAI,EAAE;UAClC0G,IAAI,EAAE,SAAS;UACflE,MAAM,EAAE,QAAQ;UAChBuC,cAAc,EAAEA;QAClB,CAAC;QAED/B,kBAAkB,CAACC,UAAU,CAAC,EAAC;;QAE/B;QACA;;QAEA;QACA,IAAItH,MAAM,CAAC+C,SAAS,EAAE;UACpB/C,MAAM,CAACsQ,IAAI,CAAC,gCAAgC,EAAE;YAC5CyF,QAAQ,EAAE;cAAE/M,MAAM,EAAEjH,IAAI,CAACZ,EAAE;cAAE+C,QAAQ,EAAEnC,IAAI,CAACE,IAAI;cAAEoC,SAAS,EAAEtC,IAAI,CAACG;YAAO,CAAC;YAC1EwI,QAAQ,EAAEoL,UAAU,CAAC9M,MAAM;YAAE;YAC7BI,cAAc,EAAEA;UAClB,CAAC,CAAC;UACF;UACApJ,MAAM,CAACsQ,IAAI,CAAC,yBAAyB,EAAE;YAAE0F,YAAY,EAAEF,UAAU,CAAC9M;UAAO,CAAC,CAAC;UAC3E/H,OAAO,CAACC,GAAG,CAAC,oEAAoE,CAAC;QACnF;MACF,CAAC,MAAM;QACL6E,SAAS,CAAC,4BAA4B,CAAC;QACvC;MACF;IACF,CAAC,CAAC,OAAO1E,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D0E,SAAS,CAAC,8BAA8B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;MACzD;MACAhB,iBAAiB,CAAEkD,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAEwN,OAAO,CAAC,CAAC;IACjD,CAAC,SAAS;MACRnR,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAC0B,OAAO,EAAElB,cAAc,EAAEgB,SAAS,EAAEgK,uBAAuB,EAAE1I,kBAAkB,EAAEtF,IAAI,CACxF,CAAC;EAED,MAAMkU,kBAAkB,GAAGtW,WAAW,CACpC,MAAOuW,QAAQ,IAAK;IAClB,IAAI,CAAC3U,MAAM,CAAC4U,OAAO,CAAC,6DAA6D,CAAC,EAAE;MAClF;IACF;IAEA,MAAM9P,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZpF,OAAO,CAACC,GAAG,CAAC,wCAAwCgV,QAAQ,EAAE,CAAC;IAC/D3R,UAAU,CAAC,IAAI,CAAC;;IAEhB;IACA,MAAM6R,eAAe,GAAGjU,QAAQ,CAAC0M,IAAI,CAACxG,OAAO,IAAIA,OAAO,CAAClH,EAAE,KAAK+U,QAAQ,IAAI7N,OAAO,CAAC0C,IAAI,KAAK,SAAS,CAAC;IACvG,IAAI,CAACqL,eAAe,EAAE;MACpBrQ,SAAS,CAAC,kDAAkD,CAAC;MAC7DxB,UAAU,CAAC,KAAK,CAAC;MACjB;IACF;;IAEA;IACA,MAAMiM,eAAe,GAAG,CAAC,GAAGrO,QAAQ,CAAC;IAErC,IAAI;MACF;MACAC,WAAW,CAAE8F,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAES,OAAO,IAAKA,OAAO,CAAClH,EAAE,KAAK+U,QAAQ,IAAI7N,OAAO,CAAC0C,IAAI,KAAK,SAAS,CAAC,CAAC;;MAEtG;MACA,IAAI;QACF,MAAMxD,aAAa,GAAGG,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;QAC/E,MAAM6O,eAAe,GAAG9O,aAAa,CAACK,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAAC1G,EAAE,KAAK+U,QAAQ,IAAIrO,CAAC,CAACkD,IAAI,KAAK,SAAS,CAAC;QAC9F9D,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAACqO,eAAe,CAAC,CAAC;MACxE,CAAC,CAAC,OAAOxG,CAAC,EAAE;QACV5O,OAAO,CAACI,KAAK,CAAC,kDAAkD,EAAEwO,CAAC,CAAC;MACtE;;MAEA;MACA,IAAI,CAAAtN,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAK+U,QAAQ,IAAI,CAAA3T,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,SAAS,EAAE;QAC3EvI,kBAAkB,CAAC,IAAI,CAAC;QACxBE,WAAW,CAAC,EAAE,CAAC;QACfW,aAAa,CAAC,EAAE,CAAC;QACjBE,YAAY,CAAC,EAAE,CAAC;MAClB;;MAEA;MACA,IAAI;QACFtC,OAAO,CAACC,GAAG,CAAC,iCAAiCgV,QAAQ,EAAE,CAAC;QACxD,MAAMtP,QAAQ,GAAG,MAAMX,OAAO,CAAC,QAAQ,EAAE,gBAAgBiQ,QAAQ,EAAE,EAAE7B,SAAS,EAAEhO,KAAK,CAAC;QACtFpF,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAE0F,QAAQ,CAAC;QAErDb,SAAS,CAAC,0BAA0B,CAAC;;QAErC;QACA,IAAI/F,MAAM,IAAIA,MAAM,CAAC+C,SAAS,EAAE;UAC9B/C,MAAM,CAACsQ,IAAI,CAAC,uBAAuB,EAAE;YAAEgG,SAAS,EAAEvU,IAAI,CAACZ,EAAE;YAAEoV,aAAa,EAAEL;UAAS,CAAC,CAAC;UACrFjV,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;;UAE5C;UACAlB,MAAM,CAACsQ,IAAI,CAAC,qBAAqB,CAAC;QACpC;;QAEA;QACA5C,sBAAsB,CAACrH,KAAK,CAAC;MAC/B,CAAC,CAAC,OAAOmQ,QAAQ,EAAE;QACjBvV,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAEmV,QAAQ,CAAC;;QAErD;QACA,IAAIA,QAAQ,CAAC5P,QAAQ,IAAI4P,QAAQ,CAAC5P,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;UACzD;UACAd,SAAS,CAAC,0DAA0D,CAAC;UACrE;UACA2H,sBAAsB,CAACrH,KAAK,CAAC;QAC/B,CAAC,MAAM;UACL;UACAN,SAAS,CAAC,sBAAsB,IAAIyQ,QAAQ,CAACxQ,OAAO,IAAI,oBAAoB,CAAC,CAAC;UAC9E;UACA5D,WAAW,CAACoO,eAAe,CAAC;;UAE5B;UACA,IAAI;YACFvJ,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAACwI,eAAe,CAAC,CAAC;UACxE,CAAC,CAAC,OAAOX,CAAC,EAAE;YACV5O,OAAO,CAACI,KAAK,CAAC,8BAA8B,EAAEwO,CAAC,CAAC;UAClD;QACF;MACF;IACF,CAAC,CAAC,OAAOxO,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD0E,SAAS,CAAC,wBAAwB,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;;MAEnD;MACA5D,WAAW,CAACoO,eAAe,CAAC;;MAE5B;MACA,IAAI;QACFvJ,YAAY,CAACc,OAAO,CAAC,eAAe,EAAEL,IAAI,CAACM,SAAS,CAACwI,eAAe,CAAC,CAAC;MACxE,CAAC,CAAC,OAAOX,CAAC,EAAE;QACV5O,OAAO,CAACI,KAAK,CAAC,8BAA8B,EAAEwO,CAAC,CAAC;MAClD;IACF,CAAC,SAAS;MACRtL,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAC0B,OAAO,EAAEF,SAAS,EAAExD,eAAe,EAAER,IAAI,CAACZ,EAAE,EAAEgB,QAAQ,EAAEuL,sBAAsB,CACjF,CAAC;;EAED;EACA,MAAM+I,iBAAiB,GAAG9W,WAAW,CAAC,MAAM;IAC1CyF,uBAAuB,CAAC,IAAI,CAAC;EAC/B,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMsR,kBAAkB,GAAG/W,WAAW,CACnCgX,YAAY,IAAK;IAAA,IAAAC,qBAAA;IAChB3V,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAEyV,YAAY,CAAC;IAChD,MAAME,WAAW,GAAG;MAClBpO,OAAO,EAAEkO,YAAY,CAAClO,OAAO;MAC7BtH,EAAE,EAAEwV,YAAY,CAAClO,OAAO;MAAE;MAC1BxG,IAAI,EAAE0U,YAAY,CAAC1U,IAAI;MACvBC,MAAM,EAAEyU,YAAY,CAACtS,SAAS,IAAI,EAAE;MACpC0G,IAAI,EAAE,OAAO;MACb0E,OAAO,EAAEkH,YAAY,CAAClH,OAAO;MAC7BG,WAAW,EAAE,EAAAgH,qBAAA,GAAAD,YAAY,CAACtH,OAAO,cAAAuH,qBAAA,uBAApBA,qBAAA,CAAsBjL,MAAM,KAAI,CAAC;MAAE;MAChDvC,cAAc,EAAEuN,YAAY,CAACvN,cAAc,IAAIuN,YAAY,CAAClO,OAAO;MACnEmE,SAAS,EAAE+J,YAAY,CAAC/J;IAC1B,CAAC;IACDrE,gBAAgB,CAACsO,WAAW,CAAC;IAC7BzR,uBAAuB,CAAC,KAAK,CAAC;IAC9BW,SAAS,CAAC,gBAAgB4Q,YAAY,CAAC1U,IAAI,cAAc,CAAC;IAC1D;IACAiO,mBAAmB,CAAC2G,WAAW,CAAC;EAClC,CAAC,EACD,CAACtO,gBAAgB,EAAExC,SAAS,EAAEmK,mBAAmB,CACnD,CAAC;EAED,MAAM4G,eAAe,GAAGnX,WAAW,CAChCkJ,KAAK,IAAK;IACT;IACArD,gBAAgB,CAACqD,KAAK,CAAC,EAAC;IACxBvD,qBAAqB,CAAC,IAAI,CAAC;IAC3B;EACF,CAAC,EACD,EAAE,CAAE;EACN,CAAC;EAED,MAAMyR,kBAAkB,GAAGpX,WAAW,CACnCqX,gBAAgB,IAAK;IAAA,IAAAC,qBAAA;IACpBhW,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE8V,gBAAgB,CAAC;IACpD;IACA,MAAMH,WAAW,GAAG;MAClBpO,OAAO,EAAEuO,gBAAgB,CAACvO,OAAO;MACjCtH,EAAE,EAAE6V,gBAAgB,CAACvO,OAAO;MAC5BxG,IAAI,EAAE+U,gBAAgB,CAAC/U,IAAI;MAC3BC,MAAM,EAAE8U,gBAAgB,CAAC3S,SAAS,IAAI,EAAE;MACxC0G,IAAI,EAAE,OAAO;MACb0E,OAAO,EAAEuH,gBAAgB,CAACvH,OAAO;MACjCG,WAAW,EAAEoH,gBAAgB,CAACpH,WAAW,MAAAqH,qBAAA,GAAID,gBAAgB,CAAC3H,OAAO,cAAA4H,qBAAA,uBAAxBA,qBAAA,CAA0BtL,MAAM,KAAI,CAAC;MAClFvC,cAAc,EAAE4N,gBAAgB,CAAC5N,cAAc,IAAI4N,gBAAgB,CAACvO,OAAO;MAC3EmE,SAAS,EAAEoK,gBAAgB,CAACpK;MAC5B;IACF,CAAC;IACDrE,gBAAgB,CAACsO,WAAW,CAAC;IAC7B;IACA,IAAI,CAAAtU,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAK0V,WAAW,CAACpO,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;MACpFvI,kBAAkB,CAACqU,WAAW,CAAC;IACjC;IACAvR,qBAAqB,CAAC,KAAK,CAAC,EAAC;IAC7BS,SAAS,CAAC,+BAA+B8Q,WAAW,CAAC5U,IAAI,GAAG,CAAC;EAC/D,CAAC,EACD,CAACsG,gBAAgB,EAAEhG,eAAe,EAAEwD,SAAS,CAC/C,CAAC;EAED,MAAMmR,gBAAgB,GAAGvX,WAAW,CAClC,MAAO8I,OAAO,IAAK;IACjBxH,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEuH,OAAO,CAAC;IAEtC,IAAI,CAAClH,MAAM,CAAC4U,OAAO,CAAC,2CAA2C,CAAC,EAAE;MAChE;IACF;IAEA,MAAM9P,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;IAEZ9B,UAAU,CAAC,IAAI,CAAC;IAEhB,IAAI;MACF;MACA,MAAMqC,QAAQ,GAAG,MAAMX,OAAO,CAAC,QAAQ,EAAE,eAAewC,OAAO,QAAQ,EAAE4L,SAAS,EAAEhO,KAAK,CAAC;MAC1FpF,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAE0F,QAAQ,CAAC;;MAElD;MACAtE,SAAS,CAAE4F,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEiB,KAAK,IAAKA,KAAK,CAACJ,OAAO,KAAKA,OAAO,CAAC,CAAC;;MAEtE;MACA,IAAI;QACF,MAAMC,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;QAC3E,MAAM2P,aAAa,GAAGzO,WAAW,CAACd,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKA,OAAO,CAAC;QACtExB,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACmP,aAAa,CAAC,CAAC;MACpE,CAAC,CAAC,OAAOtH,CAAC,EAAE;QACV5O,OAAO,CAACI,KAAK,CAAC,iDAAiD,EAAEwO,CAAC,CAAC;MACrE;;MAEA;MACA,IAAI,CAAAtN,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAKsH,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;QACxEvI,kBAAkB,CAAC,IAAI,CAAC;QACxBE,WAAW,CAAC,EAAE,CAAC;QACfW,aAAa,CAAC,EAAE,CAAC;QACjBE,YAAY,CAAC,EAAE,CAAC;MAClB;MAEA+B,qBAAqB,CAAC,KAAK,CAAC,EAAC;MAC7BS,SAAS,CAAC,iCAAiC,CAAC;;MAE5C;MACA,IAAI/F,MAAM,CAAC+C,SAAS,EAAE;QACpB/C,MAAM,CAACsQ,IAAI,CAAC,YAAY,EAAE;UAAE7H;QAAQ,CAAC,CAAC;MACxC;IACF,CAAC,CAAC,OAAOpH,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5C0E,SAAS,CAAC,2BAA2B,GAAG1E,KAAK,CAAC2E,OAAO,CAAC;IACxD,CAAC,SAAS;MACRzB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EACD,CAAChC,eAAe,EAAEwD,SAAS,EAAEE,OAAO,CACtC,CAAC;EAED,MAAMmR,iBAAiB,GAAGzX,WAAW,CAClC8I,OAAO,IAAK;IACXxH,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEuH,OAAO,CAAC;IACvCnG,SAAS,CAAE4F,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEiB,KAAK,IAAKA,KAAK,CAACJ,OAAO,KAAKA,OAAO,CAAC,CAAC;IACtE,IAAI;MACF,MAAMC,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;MAC3E,MAAM2P,aAAa,GAAGzO,WAAW,CAACd,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKA,OAAO,CAAC;MACtExB,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACmP,aAAa,CAAC,CAAC;IACpE,CAAC,CAAC,OAAOtH,CAAC,EAAE;MACV5O,OAAO,CAACI,KAAK,CAAC,kDAAkD,EAAEwO,CAAC,CAAC;IACtE;IACA,IAAI,CAAAtN,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAKsH,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;MACxEvI,kBAAkB,CAAC,IAAI,CAAC;MACxBE,WAAW,CAAC,EAAE,CAAC;MACfW,aAAa,CAAC,EAAE,CAAC;MACjBE,YAAY,CAAC,EAAE,CAAC;IAClB;IACA+B,qBAAqB,CAAC,KAAK,CAAC,EAAC;IAC7BS,SAAS,CAAC,wBAAwB,CAAC;IACnC;EACF,CAAC,EACD,CAACxD,eAAe,EAAEwD,SAAS,CAC7B,CAAC;;EAED;;EAEA;EACAtG,SAAS,CAAC,MAAM;IACd,MAAM4G,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACnB,KAAK,EAAE;MACVvE,QAAQ,CAAC,QAAQ,CAAC;MAClB;IACF;IAEA,IAAIuV,SAAS,GAAG,IAAI,EAAC;IACrB,IAAIC,iBAAiB,GAAG,KAAK;IAE7B,MAAMC,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,IAAI;QACFhT,UAAU,CAAC,IAAI,CAAC;QAChB,MAAMqQ,WAAW,GAAG,MAAM9L,gBAAgB,CAACzC,KAAK,CAAC;QACjD,IAAI,CAACuO,WAAW,IAAI,CAACyC,SAAS,EAAE,OAAM,CAAC;;QAEvC;QACA,MAAM3J,sBAAsB,CAACrH,KAAK,CAAC;QACnC,IAAI,CAACgR,SAAS,EAAE;;QAEhB;QACA,MAAMvH,mBAAmB,CAACzJ,KAAK,CAAC;QAChC,IAAI,CAACgR,SAAS,EAAE;;QAEhB;QACA,IAAI,CAACC,iBAAiB,IAAI1C,WAAW,CAAC5L,MAAM,IAAI,CAAChJ,MAAM,CAAC+C,SAAS,EAAE;UACjE9B,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;;UAEhD;UACAlB,MAAM,CAACwX,IAAI,GAAG;YAAEnR;UAAM,CAAC;UACvBrG,MAAM,CAACF,EAAE,CAAC2X,IAAI,CAAC7W,KAAK,GAAG;YACrBoI,MAAM,EAAE4L,WAAW,CAAC5L,MAAM;YAC1BnI,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;UACtB,CAAC;;UAED;UACAf,MAAM,CAAC0X,OAAO,CAAC,CAAC;UAChBJ,iBAAiB,GAAG,IAAI;QAC1B;MACF,CAAC,CAAC,OAAOjW,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC/C,CAAC,SAAS;QACR,IAAIgW,SAAS,EAAE;UACb9S,UAAU,CAAC,KAAK,CAAC;QACnB;MACF;IACF,CAAC;IAEDgT,aAAa,CAAC,CAAC;;IAEf;IACA,OAAO,MAAM;MACXF,SAAS,GAAG,KAAK;MACjB;MACA;MACArX,MAAM,CAAC2X,GAAG,CAAC,SAAS,CAAC;MACrB3X,MAAM,CAAC2X,GAAG,CAAC,WAAW,CAAC;MACvB3X,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,CAAC;MAC5B3X,MAAM,CAAC2X,GAAG,CAAC,aAAa,CAAC;MACzB3X,MAAM,CAAC2X,GAAG,CAAC,iBAAiB,CAAC;MAC7B3X,MAAM,CAAC2X,GAAG,CAAC,eAAe,CAAC;MAC3B3X,MAAM,CAAC2X,GAAG,CAAC,yBAAyB,CAAC;MACrC3X,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,CAAC;MAC5B3X,MAAM,CAAC2X,GAAG,CAAC,kBAAkB,CAAC;MAC9B3X,MAAM,CAAC2X,GAAG,CAAC,cAAc,CAAC;MAC1B3X,MAAM,CAAC2X,GAAG,CAAC,eAAe,CAAC;MAC3B3X,MAAM,CAAC2X,GAAG,CAAC,eAAe,CAAC;MAC3B3X,MAAM,CAAC2X,GAAG,CAAC,eAAe,CAAC;MAC3B3X,MAAM,CAAC2X,GAAG,CAAC,cAAc,CAAC;MAC1B3X,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,CAAC;IAC9B,CAAC;EACH,CAAC,EAAE,CAAC7V,QAAQ,CAAC,CAAC,EAAC;;EAEf;EACArC,SAAS,CAAC,MAAM;IACd;IACA,MAAMmY,KAAK,GAAG3Q,YAAY,CAACO,OAAO,CAAC,gBAAgB,CAAC;IACpD,IAAIoQ,KAAK,EAAE;MACTlS,iBAAiB,CAACgC,IAAI,CAACC,KAAK,CAACiQ,KAAK,CAAC,CAAC;IACtC;EACF,CAAC,EAAE,CAAC9V,QAAQ,CAAC,CAAC;;EAEd;EACA,MAAM+V,gBAAgB,GAAGlY,WAAW,CAAEyG,IAAI,IAAK;IAAA,IAAA0R,iBAAA,EAAAC,kBAAA,EAAAC,kBAAA,EAAAC,mBAAA,EAAAC,kBAAA,EAAAC,mBAAA,EAAAC,kBAAA,EAAAC,mBAAA,EAAAC,kBAAA,EAAAC,mBAAA;IAC7CtX,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEkF,IAAI,CAAC,CAAC,CAAC;;IAElD,IAAI,CAACA,IAAI,IAAK,CAACA,IAAI,CAACoE,SAAS,IAAI,CAACpE,IAAI,CAACjF,EAAG,EAAE;MAC1CF,OAAO,CAACI,KAAK,CAAC,gCAAgC,EAAE+E,IAAI,CAAC;MACrD;IACF;IAEA,MAAM6K,WAAW,GAAG7K,IAAI,CAACwG,SAAS,GAC9B,IAAI9L,IAAI,CAACsF,IAAI,CAACwG,SAAS,CAAC,CAAC1B,kBAAkB,CAAC,EAAE,EAAE;MAAEC,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU,CAAC,CAAC,GACvF,IAAItK,IAAI,CAAC,CAAC,CAACoK,kBAAkB,CAAC,EAAE,EAAE;MAAEC,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU,CAAC,CAAC;IAC7E,MAAMW,WAAW,GAAG3F,IAAI,CAACwG,SAAS,GAAG,IAAI9L,IAAI,CAACsF,IAAI,CAACwG,SAAS,CAAC,CAACZ,kBAAkB,CAAC,CAAC,GAAG,IAAIlL,IAAI,CAAC,CAAC,CAACkL,kBAAkB,CAAC,CAAC;IAEpH/K,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEqB,eAAe,CAAC,CAAC,CAAC;IAC3DtB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE;MAC3BuH,OAAO,EAAErC,IAAI,CAACqC,OAAO;MACrBW,cAAc,EAAEhD,IAAI,CAACgD,cAAc;MACnCoP,mBAAmB,EAAEjW,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI;MAC1C0N,sBAAsB,EAAElW,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEkG,OAAO;MAChDiQ,6BAA6B,EAAEnW,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE6G;IAClD,CAAC,CAAC;IAEF,MAAMuP,aAAa,GAChB,CAAApW,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,IAAIxI,eAAe,CAACkG,OAAO,KAAKrC,IAAI,CAACqC,OAAO,IAC7E,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,SAAS,IAAIxI,eAAe,CAAC6G,cAAc,KAAKhD,IAAI,CAACgD,cAAe;IAEjGnI,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEyX,aAAa,CAAC,CAAC,CAAC;;IAE9C,MAAMhW,UAAU,GAAG;MACjBxB,EAAE,EAAEiF,IAAI,CAACoE,SAAS,IAAIpE,IAAI,CAACjF,EAAE;MAC/BsJ,MAAM,EAAErE,IAAI,CAACsE,QAAQ,KAAK3I,IAAI,CAACZ,EAAE,GAAG,IAAI,GAAGiF,IAAI,CAACuE,UAAU,IAAI,YAAY;MACxEC,OAAO,EACLxE,IAAI,CAACyE,UAAU,IAAIzE,IAAI,CAAC0E,SAAS,GAC7B,4BAA4B,GAC5B1E,IAAI,CAAC2E,IAAI,KAAK,MAAM,IAAI3E,IAAI,CAAC2E,IAAI,KAAK,OAAO,IAAI3E,IAAI,CAAC2E,IAAI,KAAK,QAAQ,GACrE3E,IAAI,CAACwE,OAAO,GACd,EAAAkN,iBAAA,GAAA1R,IAAI,CAAC4E,WAAW,cAAA8M,iBAAA,wBAAAC,kBAAA,GAAhBD,iBAAA,CAAmB,CAAC,CAAC,cAAAC,kBAAA,uBAArBA,kBAAA,CAAuB5R,GAAG,KAAIC,IAAI,CAACwE,OAAO,IAAI,EAAE;MACtDK,IAAI,EAAEgG,WAAW;MACjBvG,QAAQ,EAAEtE,IAAI,CAACsE,QAAQ;MACvBW,OAAO,EAAEjF,IAAI,CAAC2E,IAAI,KAAK,OAAO,IAAI3E,IAAI,CAAC2E,IAAI,KAAK,YAAY;MAC5DO,OAAO,EAAElF,IAAI,CAAC2E,IAAI,KAAK,OAAO;MAC9BQ,MAAM,EAAEnF,IAAI,CAAC2E,IAAI,KAAK,MAAM;MAC9BS,QAAQ,EAAEpF,IAAI,CAACyE,UAAU,IAAIzE,IAAI,CAAC0E,SAAS;MACzCW,eAAe,EAAErF,IAAI,CAACqF,eAAe,IAAIrF,IAAI,CAACsE,QAAQ,KAAK,QAAQ;MACnEgB,OAAO,EAAEtF,IAAI,CAAC2E,IAAI,KAAK,MAAM,IAAAiN,kBAAA,GAAG5R,IAAI,CAAC4E,WAAW,cAAAgN,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuB9R,GAAG,GAAG,IAAI;MACjEyF,QAAQ,EAAExF,IAAI,CAAC2E,IAAI,KAAK,MAAM,IAAAmN,kBAAA,GAAG9R,IAAI,CAAC4E,WAAW,cAAAkN,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuBlW,IAAI,GAAG,IAAI;MACnE4J,QAAQ,EAAEzF,IAAI,CAAC2E,IAAI,KAAK,MAAM,IAAAqN,kBAAA,GAAGhS,IAAI,CAAC4E,WAAW,cAAAoN,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuBtN,IAAI,GAAG,IAAI;MACnEe,QAAQ,EAAE1F,IAAI,CAAC2E,IAAI,KAAK,OAAO,GAAG,EAAAuN,kBAAA,GAAAlS,IAAI,CAAC4E,WAAW,cAAAsN,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuBzM,QAAQ,KAAI1F,IAAI,CAAC0F,QAAQ,GAAG,IAAI;MACzFC,WAAW,EAAEA;IACf,CAAC;;IAEH;IACA,IAAI3F,IAAI,CAACgD,cAAc,EAAE;MACvB1D,iBAAiB,CAACwC,IAAI,IAAI;QACxB,MAAM0Q,QAAQ,GAAG1Q,IAAI,CAAC9B,IAAI,CAACgD,cAAc,CAAC,IAAI,EAAE;QAChD,IAAIwP,QAAQ,CAACxQ,IAAI,CAACwB,GAAG,IAAIA,GAAG,CAACzI,EAAE,KAAKwB,UAAU,CAACxB,EAAE,CAAC,EAAE,OAAO+G,IAAI;QAC/D,MAAM2Q,OAAO,GAAG;UAAE,GAAG3Q,IAAI;UAAE,CAAC9B,IAAI,CAACgD,cAAc,GAAG,CAAC,GAAGwP,QAAQ,EAAEjW,UAAU;QAAE,CAAC;QAC7E;QACAsE,YAAY,CAACc,OAAO,CAAC,gBAAgB,EAAEL,IAAI,CAACM,SAAS,CAAC6Q,OAAO,CAAC,CAAC;QAC/D5X,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAE2X,OAAO,CAAC;QACnD,OAAOA,OAAO;MAChB,CAAC,CAAC;IACJ;IAEA,IAAIF,aAAa,EAAE;MACjBjW,WAAW,CAACwF,IAAI,IAAI;QAClB,MAAMC,MAAM,GAAGD,IAAI,CAACE,IAAI,CAACwB,GAAG,IAAIA,GAAG,CAACzI,EAAE,KAAKwB,UAAU,CAACxB,EAAE,CAAC;QACzD,IAAIgH,MAAM,EAAE,OAAOD,IAAI;QACvB,OAAO,CAAC,GAAGA,IAAI,EAAEvF,UAAU,CAAC;MAC9B,CAAC,CAAC;MACF;MACA,IAAI,CAACA,UAAU,CAAC0I,OAAO,IAAI1I,UAAU,CAAC2I,OAAO,KAAK3I,UAAU,CAACiI,OAAO,EAAE;QACpEvH,aAAa,CAAE6E,IAAI;UAAA,IAAA4Q,kBAAA,EAAAC,mBAAA;UAAA,OAAK,CACtB;YACE5X,EAAE,EAAEwB,UAAU,CAACxB,EAAE;YACjB4J,IAAI,EAAEpI,UAAU,CAAC0I,OAAO,GAAG,OAAO,GAAG,OAAO;YAC5ClF,GAAG,EAAExD,UAAU,CAACiI,OAAO;YACvB3I,IAAI,EAAEU,UAAU,CAACiJ,QAAQ,KAAKjJ,UAAU,CAAC0I,OAAO,GAAG,WAAW,GAAG,WAAW,CAAC;YAC7E4B,IAAI,EAAEtK,UAAU,CAACoJ,WAAW;YAC5BmB,IAAI,EAAE,EAAA4L,kBAAA,GAAA1S,IAAI,CAAC4E,WAAW,cAAA8N,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuB7L,IAAI,KAAI,CAAC;YACtCpB,QAAQ,EAAEnJ,UAAU,CAACmJ;UACvB,CAAC,EACD,GAAG5D,IAAI,CAAE;UAAA,CACV;QAAA,EAAC;MACJ,CAAC,MAAM,IAAIvF,UAAU,CAAC4I,MAAM,IAAI5I,UAAU,CAAC+I,OAAO,EAAE;QAClDnI,YAAY,CAAE2E,IAAI;UAAA,IAAA8Q,oBAAA,EAAAC,kBAAA,EAAAC,mBAAA;UAAA,OAAK,CACrB;YACE/X,EAAE,EAAEwB,UAAU,CAACxB,EAAE;YACjB4J,IAAI,EAAE,EAAAiO,oBAAA,GAAArW,UAAU,CAACiJ,QAAQ,cAAAoN,oBAAA,uBAAnBA,oBAAA,CAAqB9P,KAAK,CAAC,GAAG,CAAC,CAACsE,GAAG,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,KAAI,MAAM;YACnEtH,GAAG,EAAExD,UAAU,CAAC+I,OAAO;YACvBzJ,IAAI,EAAEU,UAAU,CAACiJ,QAAQ;YACzBqB,IAAI,EAAEtK,UAAU,CAACoJ,WAAW;YAC5BmB,IAAI,EAAE,EAAA+L,kBAAA,GAAA7S,IAAI,CAAC4E,WAAW,cAAAiO,kBAAA,wBAAAC,mBAAA,GAAhBD,kBAAA,CAAmB,CAAC,CAAC,cAAAC,mBAAA,uBAArBA,mBAAA,CAAuBhM,IAAI,KAAI;UACvC,CAAC,EACD,GAAGhF,IAAI,CAAE;UAAA,CACV;QAAA,EAAC;MACJ;IACF,CAAC,MAAM;MAAA,IAAAiR,aAAA,EAAAC,cAAA;MACL;MACA,IAAIzO,UAAU,GAAG,YAAY;MAC7B,IAAI0O,SAAS,GAAGjT,IAAI,CAACsE,QAAQ,EAAC;MAC9B,IAAI4O,QAAQ,GAAGlT,IAAI,CAACsE,QAAQ,CAAC,CAAC;MAC9B,IAAI6O,cAAc,GAAG,CAAC,CAACnT,IAAI,CAACqC,OAAO;MAEnC,IAAI8Q,cAAc,EAAE;QAClBD,QAAQ,GAAGlT,IAAI,CAACqC,OAAO,CAAC,CAAC;QACzB,MAAMI,KAAK,GAAGxG,MAAM,CAACwM,IAAI,CAAEjG,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKrC,IAAI,CAACqC,OAAO,CAAC;QAC5DkC,UAAU,GAAG,GAAGvE,IAAI,CAACuE,UAAU,IAAI,OAAO,KAAK,CAAA9B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAE5G,IAAI,KAAI,MAAM,GAAG;MACzE,CAAC,MAAM;QACL,MAAMoG,OAAO,GAAGlG,QAAQ,CAAC0M,IAAI,CAAEhH,CAAC,IAAKA,CAAC,CAAC1G,EAAE,KAAKiF,IAAI,CAACsE,QAAQ,CAAC,EAAC;QAC7DC,UAAU,GAAG,CAAAtC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEpG,IAAI,KAAImE,IAAI,CAACuE,UAAU,IAAI,OAAO;QACxD0O,SAAS,GAAGjT,IAAI,CAACsE,QAAQ,CAAC,CAAC;MAC7B;MAEA,MAAM8O,OAAO,GACXpT,IAAI,CAAC2E,IAAI,KAAK,MAAM,GAChB,EAAAoO,aAAA,GAAA/S,IAAI,CAACwE,OAAO,cAAAuO,aAAA,uBAAZA,aAAA,CAAcM,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,KAAI,EAAAL,cAAA,GAAAhT,IAAI,CAACwE,OAAO,cAAAwO,cAAA,uBAAZA,cAAA,CAAczN,MAAM,IAAG,EAAE,GAAG,KAAK,GAAG,EAAE,CAAC,GACzE,IAAIvF,IAAI,CAAC2E,IAAI,KAAK,OAAO,GAAG,UAAU,GAAG3E,IAAI,CAAC2E,IAAI,KAAK,OAAO,GAAG,OAAO,GAAG,KAAK,GAAG;MACzFhF,SAAS,CAAC,mBAAmB4E,UAAU,KAAK6O,OAAO,EAAE,CAAC;;MAEtD;MACApX,WAAW,CAAC8F,IAAI,IAAIA,IAAI,CAACI,GAAG,CAACoR,IAAI,IAAI;QACnC;QACA,MAAMC,aAAa,GAAGD,IAAI,CAAC3O,IAAI,KAAK,OAAO,GAAG2O,IAAI,CAACjR,OAAO,GAAGiR,IAAI,CAACvY,EAAE;QACpE,IAAIwY,aAAa,KAAKL,QAAQ,EAAE;UAC9BrY,OAAO,CAACC,GAAG,CAAC,8CAA8CwY,IAAI,CAAC3O,IAAI,KAAK2O,IAAI,CAACzX,IAAI,IAAIyX,IAAI,CAACvY,EAAE,EAAE,CAAC;UAC/F;UACA,OAAO;YACL,GAAGuY,IAAI;YACP/I,WAAW,EAAE,CAAC+I,IAAI,CAAC/I,WAAW,IAAI,CAAC,IAAI,CAAC;YACxCiJ,WAAW,EAAE;cACXhP,OAAO,EAAExE,IAAI,CAAC2E,IAAI,KAAK,MAAM,GAAG3E,IAAI,CAACwE,OAAO,GAAG4O,OAAO;cAAE;cACxDzO,IAAI,EAAE3E,IAAI,CAAC2E,IAAI;cACfL,QAAQ,EAAEtE,IAAI,CAACsE,QAAQ;cACvBkC,SAAS,EAAExG,IAAI,CAACwG,SAAS,IAAI,IAAI9L,IAAI,CAAC,CAAC,CAACmI,WAAW,CAAC;YACtD,CAAC;YACD4Q,aAAa,EAAEzT,IAAI,CAACwG,SAAS,IAAI,IAAI9L,IAAI,CAAC,CAAC,CAACmI,WAAW,CAAC;UAC1D,CAAC;QACH;QACA,OAAOyQ,IAAI;MACb,CAAC,CAAC,CAAC;;MAEH;MACA;;MAEA;MACA,IAAI,CAACnX,eAAe,IAAI6D,IAAI,CAACgD,cAAc,EAAE;QAC3C;QACA,IAAI0Q,YAAY,GAAG3X,QAAQ,CAAC0M,IAAI,CAC9BhH,CAAC,IAAIA,CAAC,CAACuB,cAAc,KAAKhD,IAAI,CAACgD,cAAc,IAAIvB,CAAC,CAAC1G,EAAE,KAAKiF,IAAI,CAACsE,QACjE,CAAC;QACD,IAAIoP,YAAY,EAAE;UAChBtX,kBAAkB,CAACsX,YAAY,CAAC;UAChC;UACApX,WAAW,CAAC+C,cAAc,CAACW,IAAI,CAACgD,cAAc,CAAC,IAAI,EAAE,CAAC;QACxD;MACF;IACF;;IAEA;IACA,IAAIqK,QAAQ,CAACsG,MAAM,IAAI,cAAc,IAAIxY,MAAM,IAAIyY,YAAY,CAACC,UAAU,KAAK,SAAS,EAAE;MAAA,IAAAC,cAAA,EAAAC,YAAA;MACxF,MAAMC,WAAW,GAAGhU,IAAI,CAACuE,UAAU,IAAI,YAAY;MACnD,IAAIqP,YAAY,CAACI,WAAW,EAAE;QAC5BC,IAAI,EAAEjU,IAAI,CAAC2E,IAAI,KAAK,MAAM,GAAG3E,IAAI,CAACwE,OAAO,GAAG,cAAcxE,IAAI,CAAC2E,IAAI,EAAE;QACrEuP,IAAI,EAAE,EAAAJ,cAAA,GAAA/X,QAAQ,CAAC0M,IAAI,CAAEhH,CAAC,IAAKA,CAAC,CAAC1G,EAAE,KAAKiF,IAAI,CAACsE,QAAQ,CAAC,cAAAwP,cAAA,uBAA5CA,cAAA,CAA8ChY,MAAM,OAAAiY,YAAA,GAAI9X,MAAM,CAACwM,IAAI,CAACjG,CAAC,IAAIA,CAAC,CAACH,OAAO,KAAKrC,IAAI,CAACqC,OAAO,CAAC,cAAA0R,YAAA,uBAA5CA,YAAA,CAA8CjY,MAAM,KAAI,cAAc,CAAE;MACxI,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAACH,IAAI,CAACZ,EAAE,EAAEgB,QAAQ,EAAEE,MAAM,EAAEE,eAAe,EAAEwD,SAAS,EAAEN,cAAc,CAAC,CAAC;EAE3E,MAAM8U,mBAAmB,GAAG5a,WAAW,CAAEyG,IAAI,IAAK;IAChD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACqP,SAAS,IAAI,CAACrP,IAAI,CAACqE,MAAM,EAAE;IAC9C;EACF,CAAC,EAAE,CAAC1E,SAAS,EAAE+J,mBAAmB,EAAEjM,YAAY,CAAC,CAAC;EAElD,MAAM2W,2BAA2B,GAAG7a,WAAW,CAAEyG,IAAI,IAAK;IACxD,IAAI,CAACA,IAAI,EAAE;MACTnF,OAAO,CAACI,KAAK,CAAC,4CAA4C,CAAC;MAC3D;IACF;IACA;EACF,CAAC,EAAE,CAAC0E,SAAS,EAAEgK,uBAAuB,EAAE1I,kBAAkB,EAAEtF,IAAI,CAAC,CAAC;EAElE,MAAM0Y,mBAAmB,GAAG9a,WAAW,CAAEyG,IAAI,IAAK;IAChD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACkQ,SAAS,EAAE;IAC9B;EACF,CAAC,EAAE,CAACnU,QAAQ,EAAEI,eAAe,EAAEwD,SAAS,CAAC,CAAC;EAE1C,MAAM2U,qBAAqB,GAAG/a,WAAW,CAAC,MAAM;IAC9C,MAAM0G,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAInB,KAAK,EAAE;MACTqH,sBAAsB,CAACrH,KAAK,CAAC;IAC/B;EACF,CAAC,EAAE,CAACqH,sBAAsB,CAAC,CAAC;EAE5B,MAAMiN,wBAAwB,GAAGhb,WAAW,CAAEyG,IAAI,IAAK;IAAA,IAAAwU,eAAA;IACrD,IAAI,EAACxU,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEyC,KAAK,GAAE;IAClB5H,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEkF,IAAI,CAACyC,KAAK,CAAC;IACxD,MAAMA,KAAK,GAAGzC,IAAI,CAACyC,KAAK;IACxB,MAAMgO,WAAW,GAAG;MAClBpO,OAAO,EAAEI,KAAK,CAACJ,OAAO;MACtBtH,EAAE,EAAE0H,KAAK,CAACJ,OAAO;MACjBxG,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;MAChBC,MAAM,EAAE2G,KAAK,CAACxE,SAAS,IAAI,EAAE;MAC7B0G,IAAI,EAAE,OAAO;MACb0E,OAAO,EAAE5G,KAAK,CAAC4G,OAAO;MACtBG,WAAW,EAAE,EAAAgL,eAAA,GAAA/R,KAAK,CAACwG,OAAO,cAAAuL,eAAA,uBAAbA,eAAA,CAAejP,MAAM,KAAI,CAAC;MACvCvC,cAAc,EAAEP,KAAK,CAACO,cAAc,IAAIP,KAAK,CAACJ,OAAO;MACrDmE,SAAS,EAAE/D,KAAK,CAAC+D;IACnB,CAAC;IACDrE,gBAAgB,CAACsO,WAAW,CAAC;IAC7B9Q,SAAS,CAAC,8BAA8B8C,KAAK,CAAC5G,IAAI,GAAG,CAAC;EACxD,CAAC,EAAE,CAACsG,gBAAgB,EAAExC,SAAS,CAAC,CAAC;EAEjC,MAAM8U,wBAAwB,GAAGlb,WAAW,CAAEyG,IAAI,IAAK;IAAA,IAAA0U,eAAA;IACrD,IAAI,EAAC1U,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEyC,KAAK,GAAE;IAClB5H,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEkF,IAAI,CAACyC,KAAK,CAAC;IACxD,MAAMA,KAAK,GAAGzC,IAAI,CAACyC,KAAK;IACxB,MAAMgO,WAAW,GAAG;MAClBpO,OAAO,EAAEI,KAAK,CAACJ,OAAO;MACtBtH,EAAE,EAAE0H,KAAK,CAACJ,OAAO;MACjBxG,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;MAChBC,MAAM,EAAE2G,KAAK,CAACxE,SAAS,IAAI,EAAE;MAC7B0G,IAAI,EAAE,OAAO;MACb0E,OAAO,EAAE5G,KAAK,CAAC4G,OAAO;MACtBG,WAAW,EAAE/G,KAAK,CAAC+G,WAAW,MAAAkL,eAAA,GAAIjS,KAAK,CAACwG,OAAO,cAAAyL,eAAA,uBAAbA,eAAA,CAAenP,MAAM,KAAI,CAAC;MAC5DvC,cAAc,EAAEP,KAAK,CAACO,cAAc,IAAIP,KAAK,CAACJ,OAAO;MACrDmE,SAAS,EAAE/D,KAAK,CAAC+D;IACnB,CAAC;IACDrE,gBAAgB,CAACsO,WAAW,CAAC;IAC7B,IAAI,CAAAtU,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAK0H,KAAK,CAACJ,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;MAC9EvI,kBAAkB,CAACqU,WAAW,CAAC;IACjC;IACA9Q,SAAS,CAAC,SAAS8C,KAAK,CAAC5G,IAAI,oBAAoB,CAAC;EACpD,CAAC,EAAE,CAACsG,gBAAgB,EAAEhG,eAAe,EAAEwD,SAAS,CAAC,CAAC;EAElD,MAAMgV,kBAAkB,GAAGpb,WAAW,CAAEyG,IAAI,IAAK;IAAA,IAAA4U,aAAA;IAC/C,IAAI,EAAC5U,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEqC,OAAO,GAAE;IACpBxH,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEkF,IAAI,CAACqC,OAAO,CAAC;IAC1D,MAAMwS,SAAS,GAAG,EAAAD,aAAA,GAAA3Y,MAAM,CAACwM,IAAI,CAACjG,CAAC,IAAIA,CAAC,CAACH,OAAO,KAAKrC,IAAI,CAACqC,OAAO,CAAC,cAAAuS,aAAA,uBAA5CA,aAAA,CAA8C/Y,IAAI,KAAI,UAAU;IAClFK,SAAS,CAAE4F,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEiB,KAAK,IAAKA,KAAK,CAACJ,OAAO,KAAKrC,IAAI,CAACqC,OAAO,CAAC,CAAC;IAC3E,IAAI;MACF,MAAMC,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;MAC3E,MAAM2P,aAAa,GAAGzO,WAAW,CAACd,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKrC,IAAI,CAACqC,OAAO,CAAC;MAC3ExB,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACmP,aAAa,CAAC,CAAC;IACpE,CAAC,CAAC,OAAOtH,CAAC,EAAE;MAAE5O,OAAO,CAACI,KAAK,CAAC,gDAAgD,EAAEwO,CAAC,CAAC;IAAC;IAEjF,IAAI,CAAAtN,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAKiF,IAAI,CAACqC,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;MAC7EvI,kBAAkB,CAAC,IAAI,CAAC;MACxBE,WAAW,CAAC,EAAE,CAAC;MACfW,aAAa,CAAC,EAAE,CAAC;MACjBE,YAAY,CAAC,EAAE,CAAC;IAClB;IACAwC,SAAS,CAAC,SAASkV,SAAS,aAAa,CAAC;EAC5C,CAAC,EAAE,CAAC5Y,MAAM,EAAEE,eAAe,EAAEwD,SAAS,CAAC,CAAC;EAExC,MAAMmV,iBAAiB,GAAGvb,WAAW,CAAEyG,IAAI,IAAK;IAAA,IAAA+U,eAAA;IAC9C,IAAI,EAAC/U,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEyC,KAAK,KAAI,EAACzC,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEkJ,MAAM,KAAI,EAAClJ,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEgV,OAAO,GAAE;IACrDna,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEkF,IAAI,CAAC;IACjD,MAAMyC,KAAK,GAAGzC,IAAI,CAACyC,KAAK;IACxB,MAAMgO,WAAW,GAAG;MAClBpO,OAAO,EAAEI,KAAK,CAACJ,OAAO;MACtBtH,EAAE,EAAE0H,KAAK,CAACJ,OAAO;MACjBxG,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;MAChBC,MAAM,EAAE2G,KAAK,CAACxE,SAAS,IAAI,EAAE;MAC7B0G,IAAI,EAAE,OAAO;MACb0E,OAAO,EAAE5G,KAAK,CAAC4G,OAAO;MACtBG,WAAW,EAAE/G,KAAK,CAAC+G,WAAW,MAAAuL,eAAA,GAAItS,KAAK,CAACwG,OAAO,cAAA8L,eAAA,uBAAbA,eAAA,CAAexP,MAAM,KAAI,CAAC;MAC5DvC,cAAc,EAAEP,KAAK,CAACO,cAAc,IAAIP,KAAK,CAACJ,OAAO;MACrDmE,SAAS,EAAE/D,KAAK,CAAC+D;IACnB,CAAC;IACDrE,gBAAgB,CAACsO,WAAW,CAAC;IAC7B,IAAIzQ,IAAI,CAACkJ,MAAM,CAACtG,MAAM,KAAKjH,IAAI,CAACZ,EAAE,EAAE;MAClC4E,SAAS,CAAC,GAAGK,IAAI,CAACgV,OAAO,CAAClX,QAAQ,IAAI,OAAO,YAAYkC,IAAI,CAACkJ,MAAM,CAACpL,QAAQ,IAAI,gBAAgB,cAAc2E,KAAK,CAAC5G,IAAI,GAAG,CAAC;IAC/H;IACA,IAAI,CAAAM,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAK0H,KAAK,CAACJ,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;MAC9EvI,kBAAkB,CAACqU,WAAW,CAAC;IACjC;EACF,CAAC,EAAE,CAAC9U,IAAI,CAACZ,EAAE,EAAEoH,gBAAgB,EAAEhG,eAAe,EAAEwD,SAAS,CAAC,CAAC;EAE3D,MAAMsV,mBAAmB,GAAG1b,WAAW,CAAEyG,IAAI,IAAK;IAChD,IAAI,EAACA,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEyC,KAAK,KAAI,EAACzC,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEkV,QAAQ,KAAI,EAAClV,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEmV,SAAS,GAAE;IACzDta,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEkF,IAAI,CAAC;IACnD,MAAMyC,KAAK,GAAGzC,IAAI,CAACyC,KAAK;IACxB,MAAMJ,OAAO,GAAGI,KAAK,CAACJ,OAAO;IAE7B,IAAIrC,IAAI,CAACkV,QAAQ,KAAKvZ,IAAI,CAACZ,EAAE,EAAE;MAC7B4E,SAAS,CAAC,4BAA4B8C,KAAK,CAAC5G,IAAI,GAAG,CAAC;MACpDK,SAAS,CAAE4F,IAAI,IAAKA,IAAI,CAACN,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKA,OAAO,CAAC,CAAC;MAC9D,IAAI;QACF,MAAMC,WAAW,GAAGhB,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;QAC3E,MAAM2P,aAAa,GAAGzO,WAAW,CAACd,MAAM,CAAEgB,CAAC,IAAKA,CAAC,CAACH,OAAO,KAAKA,OAAO,CAAC;QACtExB,YAAY,CAACc,OAAO,CAAC,aAAa,EAAEL,IAAI,CAACM,SAAS,CAACmP,aAAa,CAAC,CAAC;MACpE,CAAC,CAAC,OAAMtH,CAAC,EAAE;QAAE5O,OAAO,CAACI,KAAK,CAAC,4DAA4D,EAAEwO,CAAC,CAAC;MAAC;MAC5F,IAAI,CAAAtN,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAKsH,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;QACxEvI,kBAAkB,CAAC,IAAI,CAAC;QACxBE,WAAW,CAAC,EAAE,CAAC;QACfW,aAAa,CAAC,EAAE,CAAC;QACjBE,YAAY,CAAC,EAAE,CAAC;MAClB;IACF,CAAC,MAAM;MAAA,IAAAiY,eAAA,EAAAC,YAAA;MACL,MAAM5E,WAAW,GAAG;QAClBpO,OAAO,EAAEI,KAAK,CAACJ,OAAO;QACtBtH,EAAE,EAAE0H,KAAK,CAACJ,OAAO;QACjBxG,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;QAChBC,MAAM,EAAE2G,KAAK,CAACxE,SAAS,IAAI,EAAE;QAC7B0G,IAAI,EAAE,OAAO;QACb0E,OAAO,EAAE5G,KAAK,CAAC4G,OAAO;QACtBG,WAAW,EAAE/G,KAAK,CAAC+G,WAAW,MAAA4L,eAAA,GAAI3S,KAAK,CAACwG,OAAO,cAAAmM,eAAA,uBAAbA,eAAA,CAAe7P,MAAM,KAAI,CAAC;QAC5DvC,cAAc,EAAEP,KAAK,CAACO,cAAc,IAAIP,KAAK,CAACJ,OAAO;QACrDmE,SAAS,EAAE/D,KAAK,CAAC+D;MACnB,CAAC;MACDrE,gBAAgB,CAACsO,WAAW,CAAC;MAC7B,MAAM6E,UAAU,GAAG,EAAAD,YAAA,GAAArV,IAAI,CAACkJ,MAAM,cAAAmM,YAAA,uBAAXA,YAAA,CAAavX,QAAQ,KAAI,gBAAgB;MAC5D6B,SAAS,CAAC,GAAGK,IAAI,CAACmV,SAAS,CAACrX,QAAQ,IAAI,OAAO,WAAWwX,UAAU,eAAe7S,KAAK,CAAC5G,IAAI,GAAG,CAAC;MACjG,IAAI,CAAAM,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEpB,EAAE,MAAK0H,KAAK,CAACJ,OAAO,IAAI,CAAAlG,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEwI,IAAI,MAAK,OAAO,EAAE;QAC9EvI,kBAAkB,CAACqU,WAAW,CAAC;MACjC;IACF;EACF,CAAC,EAAE,CAAC9U,IAAI,CAACZ,EAAE,EAAEoH,gBAAgB,EAAEhG,eAAe,EAAEwD,SAAS,CAAC,CAAC;EAE3D,MAAM4V,kBAAkB,GAAGhc,WAAW,CAAEyG,IAAI,IAAK;IAC/C,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACJ,OAAO,EAAE;MAC1B/E,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAE+E,IAAI,CAAC;MACjD;IACF;IACA,IAAIA,IAAI,CAAC2E,IAAI,KAAK,SAAS,EAAE;MAC3BhF,SAAS,CAACK,IAAI,CAACJ,OAAO,CAAC;IACzB,CAAC,MAAM,IAAII,IAAI,CAAC2E,IAAI,KAAK,OAAO,EAAE;MAChChF,SAAS,CAACK,IAAI,CAACJ,OAAO,EAAE,OAAO,CAAC;IAClC,CAAC,MAAM,IAAII,IAAI,CAAC2E,IAAI,KAAK,SAAS,EAAE;MAClChF,SAAS,CAACK,IAAI,CAACJ,OAAO,EAAE,SAAS,CAAC;IACpC,CAAC,MAAM;MACLD,SAAS,CAACK,IAAI,CAACJ,OAAO,CAAC;IACzB;IACA,IAAII,IAAI,CAACwV,eAAe,EAAE;MACxB,MAAMvV,KAAK,GAAGY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC;MAC3C,IAAInB,KAAK,EAAE;QACTqH,sBAAsB,CAACrH,KAAK,CAAC;MAC/B;IACF;EACF,CAAC,EAAE,CAACN,SAAS,EAAE2H,sBAAsB,CAAC,CAAC;;EAEvC;EACAjO,SAAS,CAAC,MAAM;IACd,IAAI4X,SAAS,GAAG,IAAI;IAEpB,MAAMwE,aAAa,GAAGA,CAAA,KAAM;MAC1B,IAAI,CAACxE,SAAS,EAAE;MAChBpW,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;MAC/C4B,cAAc,CAAC,IAAI,CAAC;MACpB,MAAM8R,WAAW,GAAGlN,IAAI,CAACC,KAAK,CAACV,YAAY,CAACO,OAAO,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC;MAC3E,IAAIoN,WAAW,CAAC5L,MAAM,EAAE;QACtBhJ,MAAM,CAACsQ,IAAI,CAAC,gBAAgB,EAAEsE,WAAW,CAAC5L,MAAM,CAAC;MACnD;IACF,CAAC;;IAED;IACA,MAAM8S,iBAAiB,GAAI1V,IAAI,IAAK;MAClC,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACoE,SAAS,EAAE;QAC5BvJ,OAAO,CAACI,KAAK,CAAC,oCAAoC,EAAE+E,IAAI,CAAC;QACzD;MACF;MACAnF,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAEkF,IAAI,CAAC;;MAEzD;MACA1D,WAAW,CAACqZ,YAAY,IAAIA,YAAY,CAACzT,GAAG,CAACsB,GAAG,IAAI;QAClD;QACA,IAAIA,GAAG,CAACuH,SAAS;QACf;QACC/K,IAAI,CAAC4K,aAAa,IAAIpH,GAAG,CAACzI,EAAE,KAAKiF,IAAI,CAAC4K,aAAa;QACpD;QACC5K,IAAI,CAACgD,cAAc,IAAIQ,GAAG,CAACR,cAAc,KAAKhD,IAAI,CAACgD,cAAc,IACjEQ,GAAG,CAACgB,OAAO,KAAKxE,IAAI,CAACwE,OAAQ,CAC/B,EAAE;UACD3J,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE;YACtC8a,KAAK,EAAEpS,GAAG,CAACzI,EAAE;YACb8a,KAAK,EAAE7V,IAAI,CAACoE,SAAS;YACrBI,OAAO,EAAEhB,GAAG,CAACgB;UACf,CAAC,CAAC;UACF,OAAO;YACL,GAAGhB,GAAG;YACNzI,EAAE,EAAEiF,IAAI,CAACoE,SAAS;YAClBA,SAAS,EAAEpE,IAAI,CAACoE,SAAS;YACzB2G,SAAS,EAAE,KAAK;YAChBvE,SAAS,EAAExG,IAAI,CAACwG,SAAS,IAAIhD,GAAG,CAACgD;UACnC,CAAC;QACH;QACA,OAAOhD,GAAG;MACZ,CAAC,CAAC,CAAC;IACL,CAAC;;IAED;IACA5J,MAAM,CAACgB,EAAE,CAAC,SAAS,EAAE6a,aAAa,CAAC;IACnC7b,MAAM,CAACgB,EAAE,CAAC,sBAAsB,EAAE8a,iBAAiB,CAAC,EAAC;IACrD9b,MAAM,CAACgB,EAAE,CAAC,aAAa,EAAE6W,gBAAgB,CAAC;IAC1C7X,MAAM,CAACgB,EAAE,CAAC,iBAAiB,EAAE6W,gBAAgB,CAAC;IAC9C7X,MAAM,CAACgB,EAAE,CAAC,eAAe,EAAE6W,gBAAgB,CAAC;IAC5C7X,MAAM,CAACgB,EAAE,CAAC,gBAAgB,EAAEuZ,mBAAmB,CAAC;IAChDva,MAAM,CAACgB,EAAE,CAAC,yBAAyB,EAAEwZ,2BAA2B,CAAC;IACjExa,MAAM,CAACgB,EAAE,CAAC,gBAAgB,EAAEyZ,mBAAmB,CAAC;IAChDza,MAAM,CAACgB,EAAE,CAAC,kBAAkB,EAAE0Z,qBAAqB,CAAC;IACpD1a,MAAM,CAACgB,EAAE,CAAC,cAAc,EAAE2a,kBAAkB,CAAC;IAC7C3b,MAAM,CAACgB,EAAE,CAAC,eAAe,EAAE2Z,wBAAwB,CAAC;IACpD3a,MAAM,CAACgB,EAAE,CAAC,eAAe,EAAE6Z,wBAAwB,CAAC;IACpD7a,MAAM,CAACgB,EAAE,CAAC,eAAe,EAAE+Z,kBAAkB,CAAC;IAC9C/a,MAAM,CAACgB,EAAE,CAAC,cAAc,EAAEka,iBAAiB,CAAC;IAC5Clb,MAAM,CAACgB,EAAE,CAAC,gBAAgB,EAAEqa,mBAAmB,CAAC;;IAEhD;IACA,OAAO,MAAM;MACXhE,SAAS,GAAG,KAAK;MACjBrX,MAAM,CAAC2X,GAAG,CAAC,SAAS,EAAEkE,aAAa,CAAC;MACpC7b,MAAM,CAAC2X,GAAG,CAAC,sBAAsB,EAAEmE,iBAAiB,CAAC,EAAC;MACtD9b,MAAM,CAAC2X,GAAG,CAAC,aAAa,EAAEE,gBAAgB,CAAC;MAC3C7X,MAAM,CAAC2X,GAAG,CAAC,iBAAiB,EAAEE,gBAAgB,CAAC;MAC/C7X,MAAM,CAAC2X,GAAG,CAAC,eAAe,EAAEE,gBAAgB,CAAC;MAC7C7X,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,EAAE4C,mBAAmB,CAAC;MACjDva,MAAM,CAAC2X,GAAG,CAAC,yBAAyB,EAAE6C,2BAA2B,CAAC;MAClExa,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,EAAE8C,mBAAmB,CAAC;MACjDza,MAAM,CAAC2X,GAAG,CAAC,kBAAkB,EAAE+C,qBAAqB,CAAC;MACrD1a,MAAM,CAAC2X,GAAG,CAAC,cAAc,EAAEgE,kBAAkB,CAAC;MAC9C3b,MAAM,CAAC2X,GAAG,CAAC,eAAe,EAAEgD,wBAAwB,CAAC;MACrD3a,MAAM,CAAC2X,GAAG,CAAC,eAAe,EAAEkD,wBAAwB,CAAC;MACrD7a,MAAM,CAAC2X,GAAG,CAAC,eAAe,EAAEoD,kBAAkB,CAAC;MAC/C/a,MAAM,CAAC2X,GAAG,CAAC,cAAc,EAAEuD,iBAAiB,CAAC;MAC7Clb,MAAM,CAAC2X,GAAG,CAAC,gBAAgB,EAAE0D,mBAAmB,CAAC;IACnD,CAAC;EACH,CAAC,EAAE,CACDxD,gBAAgB,EAChB0C,mBAAmB,EACnBC,2BAA2B,EAC3BC,mBAAmB,EACnBC,qBAAqB,EACrBiB,kBAAkB,EAClBhB,wBAAwB,EACxBE,wBAAwB,EACxBE,kBAAkB,EAClBG,iBAAiB,EACjBG,mBAAmB,EACnB9Y,eAAe,CAAC;EAAA,CACjB,CAAC;;EAEF;EACA9C,SAAS,CAAC,MAAM;IACd4R,cAAc,CAAC,CAAC;EAClB,CAAC,EAAE,CAAC5O,QAAQ,CAAC,CAAC,EAAC;;EAEf;EACA,MAAM4O,cAAc,GAAGA,CAAA,KAAM;IAC3B;IACA6K,UAAU,CAAC,MAAM;MAAA,IAAAC,qBAAA;MACb,CAAAA,qBAAA,GAAAxW,cAAc,CAACyW,OAAO,cAAAD,qBAAA,uBAAtBA,qBAAA,CAAwBE,cAAc,CAAC;QAAEC,QAAQ,EAAE,QAAQ;QAAEC,KAAK,EAAE;MAAM,CAAC,CAAC;IAChF,CAAC,EAAE,GAAG,CAAC;EACT,CAAC;;EAED;EACA,MAAMC,gBAAgB,GAAGra,QAAQ,CAACyF,MAAM,CACrCS,OAAO,IAAKA,OAAO,CAAC0C,IAAI,KAAK,SAAS,IAAI1C,OAAO,CAACpG,IAAI,CAACwL,WAAW,CAAC,CAAC,CAAC/L,QAAQ,CAACwB,WAAW,CAACuK,WAAW,CAAC,CAAC,CAC1G,CAAC;EACD,MAAMgP,cAAc,GAAGpa,MAAM,CAACuF,MAAM,CACjCiB,KAAK,IAAKA,KAAK,CAACkC,IAAI,KAAK,OAAO,IAAIlC,KAAK,CAAC5G,IAAI,CAACwL,WAAW,CAAC,CAAC,CAAC/L,QAAQ,CAACwB,WAAW,CAACuK,WAAW,CAAC,CAAC,CAClG,CAAC;EAED,MAAMiP,MAAM,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAC;;EAE5E;EACA,OAAO;IACL;IACA3a,IAAI;IACJI,QAAQ;IAAE;IACVE,MAAM;IAAI;IACVE,eAAe;IACfE,QAAQ;IACRE,UAAU;IACVE,WAAW;IACXG,eAAe;IACfE,WAAW;IACXE,UAAU;IACVE,SAAS;IACTE,SAAS;IACTE,SAAS;IACTE,SAAS;IACTE,gBAAgB;IAChBE,WAAW;IACXM,OAAO;IACPE,kBAAkB;IAClBE,WAAW;IACXrD,KAAK;IACLwD,SAAS;IACTE,cAAc;IACdI,oBAAoB;IACpBE,kBAAkB;IAClBE,aAAa;IAEb;IACA3C,aAAa;IACbK,kBAAkB;IAClBE,cAAc;IACd;IACA;IACAU,YAAY;IAAE;IACdE,mBAAmB;IAAE;IACrBE,cAAc;IAAE;IAChB;IACAQ,qBAAqB;IAAE;IACvBE,cAAc;IAAE;IAChB;IACAG,YAAY;IAAE;IACd;IACAM,uBAAuB;IAAE;IACzBE,qBAAqB;IAAE;IACvB;;IAEA;IACAK,cAAc;IACdC,YAAY;IACZC,aAAa;IACbC,aAAa;IAEb;IACAoK,mBAAmB;IACnBW,iBAAiB;IACjBmB,cAAc;IAAE;IAChB+B,iBAAiB;IACjBE,mBAAmB;IACnBM,eAAe;IACfC,eAAe;IACfC,eAAe;IACfE,kBAAkB;IAClBE,uBAAuB;IACvBC,kBAAkB;IAClBC,mBAAmB;IACnBC,eAAe;IACfC,yBAAyB;IACzBC,qBAAqB;IACrBM,4BAA4B;IAC5BS,kBAAkB;IAClBQ,iBAAiB;IACjBC,kBAAkB;IAClBI,eAAe;IACfC,kBAAkB;IAClBG,gBAAgB;IAChBE,iBAAiB;IACjBrR,SAAS;IAAE;;IAEX;IACAyW,gBAAgB;IAChBC,cAAc;IACdC,MAAM;IACNrW,KAAK,EAAEY,YAAY,CAACO,OAAO,CAAC,OAAO,CAAC,CAAE;EACxC,CAAC;AACH,CAAC;AAAA3F,EAAA,CA7oEKD,OAAO;EAAA,QACMhC,WAAW;AAAA;AA8oE9B,eAAegC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}