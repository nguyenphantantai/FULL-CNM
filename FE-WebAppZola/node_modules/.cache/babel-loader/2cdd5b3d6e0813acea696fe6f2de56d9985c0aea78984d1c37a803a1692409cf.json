{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport axios from \"axios\";\nimport { io } from \"socket.io-client\";\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\";\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false,\n  // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false,\n  // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now()\n  }\n});\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id);\n});\nsocket.on(\"connect_error\", err => {\n  console.error(\"Socket connection error:\", err);\n});\nsocket.on(\"disconnect\", reason => {\n  console.log(\"Socket disconnected:\", reason);\n});\nsocket.on(\"error\", err => {\n  console.error(\"Socket error:\", err);\n});\nsocket.on(\"reconnect_error\", err => {\n  console.error(\"Socket reconnection error:\", err);\n});\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error;\n  console.error = (...args) => {\n    if (args[0] && typeof args[0] === \"string\" && (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))) {\n      return;\n    }\n    originalConsoleError.apply(console, args);\n  };\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  _s();\n  const navigate = useNavigate();\n\n  // State Management\n  const [user, setUser] = useState({\n    id: \"\",\n    name: \"User\",\n    avatar: \"\"\n  });\n  const [contacts, setContacts] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [selectedContact, setSelectedContact] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(socket.connected); // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [mediaFiles, setMediaFiles] = useState([]);\n  const [documents, setDocuments] = useState([]);\n  const [showMedia, setShowMedia] = useState(true);\n  const [showFiles, setShowFiles] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"chat\");\n  const [showProfileModal, setShowProfileModal] = useState(false);\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null\n  });\n  const [loading, setLoading] = useState(false);\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false);\n  const [friendEmail, setFriendEmail] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [showToast, setShowToast] = useState(false);\n  const [friendRequests, setFriendRequests] = useState([]);\n  const [recoveredContacts, setRecoveredContacts] = useState([]); // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({});\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageInputRef = useRef(null);\n  const videoInputRef = useRef(null);\n\n  // --- Utility Functions ---\n\n  const showError = useCallback(message => {\n    console.log(\"Showing Toast:\", message);\n    setError(message);\n    setShowToast(true);\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, []);\n  const apiCall = useCallback(async (method, url, data = null, token) => {\n    try {\n      console.log(`API Call: ${method.toUpperCase()} ${url}`);\n      if (data) {\n        console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data);\n      }\n      const config = {\n        method,\n        url: `${API_BASE_URL}${url}`,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n          \"If-None-Match\": \"\" // Prevent 304 responses\n        },\n        data\n      };\n      if (!(data instanceof FormData)) {\n        config.headers[\"Content-Type\"] = \"application/json\";\n      }\n      console.log(\"Using config:\", {\n        method: config.method,\n        url: config.url,\n        headers: {\n          ...config.headers,\n          Authorization: \"Bearer [HIDDEN]\"\n        }\n      });\n      const response = await axios(config);\n      console.log(`API Response ${url}:`, response.status, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error(`API Error ${url}:`, error);\n      if (error.response) {\n        console.error(\"Response status:\", error.response.status);\n        console.error(\"Response data:\", error.response.data);\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"userProfile\"); // Clear profile too\n        navigate(\"/login\");\n        // Use showError for consistency\n        showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\");\n        throw new Error(\"Phiên đăng nhập hết hạn.\"); // Throw to stop further execution\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || \"Đã xảy ra lỗi không xác định\";\n      // Don't automatically show toast here, let the calling function decide\n      // showError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [navigate, showError]); // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback(newContact => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact);\n      return;\n    }\n    console.log(\"Adding or updating contact:\", newContact);\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\");\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : [];\n      contactsArray = contactsArray.filter(c => c.id !== newContact.id);\n      contactsArray.push(newContact);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray));\n      console.log(\"Saved contact to localStorage:\", newContact.id);\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError);\n    }\n    setContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n  }, []);\n  const addOrUpdateGroup = useCallback(newGroup => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup);\n      return;\n    }\n    console.log(\"Adding or updating group:\", newGroup);\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\");\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : [];\n      groupsArray = groupsArray.filter(g => g.groupId !== newGroup.groupId);\n      groupsArray.push(newGroup);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray));\n      console.log(\"Saved group to localStorage:\", newGroup.groupId);\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError);\n    }\n    setGroups(prev => {\n      const exists = prev.some(group => group.groupId === newGroup.groupId);\n      if (exists) {\n        return prev.map(group => group.groupId === newGroup.groupId ? {\n          ...group,\n          ...newGroup\n        } : group);\n      }\n      return [...prev, newGroup];\n    });\n  }, []);\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(async token => {\n    try {\n      const response = await apiCall(\"get\", \"/api/users/profile\", null, token);\n      const userData = {\n        id: response.userId,\n        name: response.fullName || \"User\",\n        avatar: response.avatarUrl || \"\"\n      };\n      setUser(userData);\n      setProfileData({\n        fullName: response.fullName || \"\",\n        birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n        gender: response.gender || \"\",\n        avatarUrl: response.avatarUrl || null\n      });\n      // Save profile to localStorage after fetching\n      localStorage.setItem(\"userProfile\", JSON.stringify(response));\n      return response; // Return the full profile\n    } catch (error) {\n      console.error(\"Error fetching user profile:\", error);\n      showError(\"Không thể lấy thông tin người dùng: \" + error.message);\n      // No need to navigate here, apiCall handles 401\n      return null;\n    }\n  }, [apiCall, showError]);\n  const fetchMessages = useCallback(async (token, conversationId, isGroup = false) => {\n    if (!token || !conversationId) {\n      console.warn(\"fetchMessages called without token or conversationId\");\n      setMessages([]); // Clear messages if no ID\n      setMediaFiles([]);\n      setDocuments([]);\n      return;\n    }\n    setLoading(true); // Indicate loading messages\n    try {\n      let response;\n      // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n      const endpoint = `/api/messages/conversations/${conversationId}/messages`;\n      console.log(\"Fetching messages from endpoint:\", endpoint);\n      response = await apiCall(\"get\", endpoint, null, token);\n      console.log(\"Messages API response:\", response);\n      const messagesData = Array.isArray(response) ? response : response.data || [];\n      const mappedMessages = messagesData.map((msg, index) => {\n        var _msg$attachments, _msg$attachments$, _msg$attachments2, _msg$attachments$2, _msg$attachments3, _msg$attachments$3, _msg$attachments4, _msg$attachments$4, _msg$attachments5, _msg$attachments$5;\n        return {\n          id: msg.messageId || `temp-${Date.now()}-${index}`,\n          sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n          content: msg.isRecalled || msg.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\" ? msg.content : ((_msg$attachments = msg.attachments) === null || _msg$attachments === void 0 ? void 0 : (_msg$attachments$ = _msg$attachments[0]) === null || _msg$attachments$ === void 0 ? void 0 : _msg$attachments$.url) || msg.content || \"\",\n          // Ensure content exists\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          senderId: msg.senderId,\n          isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n          isVideo: msg.type === \"video\",\n          isFile: msg.type === \"file\",\n          isUnsent: msg.isRecalled || msg.isDeleted,\n          isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n          fileUrl: msg.type === \"file\" && ((_msg$attachments2 = msg.attachments) === null || _msg$attachments2 === void 0 ? void 0 : _msg$attachments2.length) > 0 ? (_msg$attachments$2 = msg.attachments[0]) === null || _msg$attachments$2 === void 0 ? void 0 : _msg$attachments$2.url : null,\n          fileName: msg.type === \"file\" && ((_msg$attachments3 = msg.attachments) === null || _msg$attachments3 === void 0 ? void 0 : _msg$attachments3.length) > 0 ? (_msg$attachments$3 = msg.attachments[0]) === null || _msg$attachments$3 === void 0 ? void 0 : _msg$attachments$3.name : null,\n          fileType: msg.type === \"file\" && ((_msg$attachments4 = msg.attachments) === null || _msg$attachments4 === void 0 ? void 0 : _msg$attachments4.length) > 0 ? (_msg$attachments$4 = msg.attachments[0]) === null || _msg$attachments$4 === void 0 ? void 0 : _msg$attachments$4.type : null,\n          duration: msg.type === \"video\" && ((_msg$attachments5 = msg.attachments) === null || _msg$attachments5 === void 0 ? void 0 : _msg$attachments5.length) > 0 ? (_msg$attachments$5 = msg.attachments[0]) === null || _msg$attachments$5 === void 0 ? void 0 : _msg$attachments$5.duration : null,\n          messageDate: new Date().toLocaleDateString() // Used for media/files list\n        };\n      }).filter(msg => msg.id); // Filter out messages without an ID\n\n      // Add system message if needed\n      if (mappedMessages.length === 0 || !mappedMessages.some(msg => msg.isSystemMessage)) {\n        const systemMessage = isGroup ? \"Chào mừng bạn đến với nhóm chat!\" : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\";\n        mappedMessages.unshift({\n          id: `system-${Date.now()}`,\n          senderId: \"system\",\n          content: systemMessage,\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          isSystemMessage: true\n        });\n      }\n\n      // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n      let mergedMessages = mappedMessages;\n      if (cachedMessages[conversationId]) {\n        const cacheList = cachedMessages[conversationId];\n        // Lọc ra các tin nhắn cache chưa có trong mappedMessages\n        const newFromCache = cacheList.filter(cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id));\n        mergedMessages = [...mappedMessages, ...newFromCache];\n      }\n      setMessages(mergedMessages);\n\n      // Update Media and Documents\n      const media = mappedMessages.filter(msg => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content).map(msg => {\n        var _msg$attachments6, _msg$attachments6$;\n        return {\n          id: msg.id,\n          type: msg.isImage ? \"image\" : \"video\",\n          url: msg.content,\n          name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n          date: msg.messageDate,\n          size: ((_msg$attachments6 = msg.attachments) === null || _msg$attachments6 === void 0 ? void 0 : (_msg$attachments6$ = _msg$attachments6[0]) === null || _msg$attachments6$ === void 0 ? void 0 : _msg$attachments6$.size) || 0,\n          // Might not be available, default to 0\n          duration: msg.duration\n        };\n      });\n      setMediaFiles(media.reverse()); // Show newest first\n\n      const files = mappedMessages.filter(msg => msg.isFile && !msg.isUnsent && msg.fileUrl).map(msg => {\n        var _msg$fileName, _msg$attachments7, _msg$attachments7$;\n        return {\n          id: msg.id,\n          type: ((_msg$fileName = msg.fileName) === null || _msg$fileName === void 0 ? void 0 : _msg$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n          url: msg.fileUrl,\n          name: msg.fileName,\n          date: msg.messageDate,\n          size: ((_msg$attachments7 = msg.attachments) === null || _msg$attachments7 === void 0 ? void 0 : (_msg$attachments7$ = _msg$attachments7[0]) === null || _msg$attachments7$ === void 0 ? void 0 : _msg$attachments7$.size) || 0\n        };\n      });\n      setDocuments(files.reverse()); // Show newest first\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      showError(\"Không thể tải tin nhắn: \" + error.message);\n      setMessages([]); // Clear messages on error\n      setMediaFiles([]);\n      setDocuments([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id to compare sender\n  );\n  const fetchContactsAndGroups = useCallback(async token => {\n    if (!token) return {\n      contacts: [],\n      groups: []\n    };\n    setLoading(true);\n    let fetchedContacts = [];\n    let fetchedGroups = [];\n    try {\n      // Fetch Friends (Contacts) from server first\n      console.log(\"Fetching friends from server...\");\n      const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token);\n      console.log(\"Friends API response:\", friendsResponse);\n\n      // Lọc ra những người bạn đã được xác nhận\n      // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n      const confirmedFriends = (friendsResponse === null || friendsResponse === void 0 ? void 0 : friendsResponse.friends) || [];\n      console.log(\"Confirmed friends:\", confirmedFriends);\n\n      // Kiểm tra xem danh sách bạn bè có hợp lệ không\n      const validFriends = confirmedFriends.filter(friend => friend && friend.userId && friend.friendshipId);\n      if (validFriends.length !== confirmedFriends.length) {\n        console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`);\n      }\n      const mappedFriends = validFriends.map(friend => {\n        var _friend$email;\n        return {\n          id: friend.userId,\n          name: friend.fullName || ((_friend$email = friend.email) === null || _friend$email === void 0 ? void 0 : _friend$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          // Trạng thái mặc định\n          friendshipId: friend.friendshipId,\n          // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null // Will be populated later\n        };\n      });\n\n      // Fetch Conversations to get conversation IDs\n      console.log(\"Fetching conversations...\");\n      const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token);\n      const conversationsMap = new Map();\n      if (convResponse && Array.isArray(convResponse)) {\n        convResponse.forEach(conv => {\n          if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n            const otherUserId = conv.participants.find(id => id !== user.id);\n            if (otherUserId) {\n              conversationsMap.set(otherUserId, conv.conversationId);\n            }\n          }\n        });\n      }\n\n      // Update conversationId for mapped friends\n      mappedFriends.forEach(friend => {\n        if (conversationsMap.has(friend.id)) {\n          friend.conversationId = conversationsMap.get(friend.id);\n        }\n      });\n\n      // Merge with existing contacts to preserve any additional data\n      const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n\n      // Create a map of existing contacts for quick lookup\n      const existingContactsMap = new Map();\n      savedContacts.forEach(contact => {\n        if (contact && contact.id) {\n          existingContactsMap.set(contact.id, contact);\n        }\n      });\n\n      // Merge server data with existing data, prioritizing server data\n      fetchedContacts = mappedFriends.map(friend => {\n        const existingContact = existingContactsMap.get(friend.id);\n        if (existingContact) {\n          // Preserve conversationId if it exists in saved contact but not in server data\n          if (!friend.conversationId && existingContact.conversationId) {\n            friend.conversationId = existingContact.conversationId;\n          }\n          return {\n            ...existingContact,\n            ...friend\n          };\n        }\n        return friend;\n      });\n\n      // Update state and localStorage\n      setContacts(fetchedContacts);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts));\n      console.log(\"Updated contacts from API:\", fetchedContacts.length);\n\n      // Fetch Groups\n      console.log(\"Fetching groups...\");\n      const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token);\n      console.log(\"Groups API response:\", groupsResponse);\n      if (groupsResponse && groupsResponse.groups) {\n        // Lọc các nhóm mà người dùng là thành viên\n        const userGroups = groupsResponse.groups.filter(group => group.members && group.members.some(member => member.userId === user.id));\n        console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`);\n        fetchedGroups = userGroups.map(group => {\n          var _group$members, _group$members2;\n          return {\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [],\n            // Lưu toàn bộ thông tin thành viên\n            memberIds: ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.map(member => member.userId)) || [],\n            // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || ((_group$members2 = group.members) === null || _group$members2 === void 0 ? void 0 : _group$members2.length) || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt\n          };\n        });\n        setGroups(fetchedGroups);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups));\n        console.log(\"Updated groups from API:\", fetchedGroups.length);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } catch (error) {\n      console.error(\"Error fetching contacts/groups:\", error);\n      showError(\"Không thể tải danh bạ/nhóm: \" + error.message);\n\n      // Fallback to localStorage only if server fetch fails\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        if (savedContacts.length > 0) {\n          console.log(\"Falling back to contacts from localStorage\");\n          setContacts(savedContacts);\n          fetchedContacts = savedContacts;\n        }\n        if (savedGroups.length > 0) {\n          console.log(\"Falling back to groups from localStorage\");\n          setGroups(savedGroups);\n          fetchedGroups = savedGroups;\n        }\n      } catch (e) {\n        console.error(\"Error reading contacts/groups from localStorage\", e);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id for conversation mapping\n  );\n  const fetchFriendRequests = useCallback(async token => {\n    if (!token) return;\n    // No need for setLoading(true) here unless it's a primary action\n    try {\n      const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token);\n      setFriendRequests(response.data || []);\n    } catch (error) {\n      console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error);\n      // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n    }\n  }, [apiCall]);\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(async (otherUserId, token) => {\n    console.log(`Creating/getting conversation with user: ${otherUserId}`);\n    if (!token || !otherUserId) {\n      throw new Error(\"Token or otherUserId missing for createOrGetConversation\");\n    }\n    try {\n      var _response$conversatio;\n      const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token);\n      if (response !== null && response !== void 0 && (_response$conversatio = response.conversation) !== null && _response$conversatio !== void 0 && _response$conversatio.conversationId) {\n        console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId);\n        return response.conversation.conversationId;\n      } else {\n        throw new Error(\"Invalid response structure from conversation API\");\n      }\n    } catch (error) {\n      console.error(\"Error in createOrGetConversation:\", error);\n      if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n        throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\");\n      }\n      throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`); // Rethrow with context\n    }\n  }, [apiCall]);\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(async contactOrGroup => {\n    if (!contactOrGroup || contactOrGroup.id === (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id)) {\n      console.log(\"Selection unchanged or invalid.\");\n      return; // Avoid re-selecting the same contact/group\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      navigate(\"/login\");\n      return;\n    }\n    console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id);\n\n    // Leave previous room\n    if (selectedContact) {\n      const roomToLeave = selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId;\n      if (roomToLeave) {\n        const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\";\n        socket.emit(eventName, roomToLeave);\n        console.log(`Left ${selectedContact.type} room:`, roomToLeave);\n      }\n    }\n\n    // Clear previous state\n    setMessages([]);\n    setMediaFiles([]);\n    setDocuments([]);\n    setSelectedContact(contactOrGroup); // Set selected contact immediately for UI update\n\n    try {\n      setLoading(true); // Show loading for message fetch\n\n      if (contactOrGroup.type === \"group\") {\n        const groupId = contactOrGroup.groupId;\n        // Sử dụng conversationId từ group object\n        const conversationId = contactOrGroup.conversationId || groupId;\n        socket.emit(\"join_group\", groupId);\n        console.log(\"Joined group room:\", groupId);\n        console.log(\"Using conversationId for group:\", conversationId);\n        await fetchMessages(token, conversationId, true);\n      } else {\n        // Handle individual contact\n        let conversationId = contactOrGroup.conversationId;\n\n        // If conversationId is missing, try to fetch/create it\n        if (!conversationId) {\n          console.log(\"Conversation ID missing, attempting to fetch/create...\");\n          try {\n            conversationId = await createOrGetConversation(contactOrGroup.id, token);\n            // Update the contact in the list and the selected contact state\n            const updatedContact = {\n              ...contactOrGroup,\n              conversationId\n            };\n            setSelectedContact(updatedContact); // Update selected state with new ID\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? updatedContact : c));\n            // Optionally save updated contacts list to localStorage\n            const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n            const updatedContactsList = currentContacts.map(c => c.id === contactOrGroup.id ? updatedContact : c);\n            localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList));\n          } catch (error) {\n            showError(error.message); // Show error from createOrGetConversation\n            setSelectedContact(null); // Deselect if conversation fails\n            setLoading(false);\n            return; // Stop execution if conversation fails\n          }\n        }\n        if (conversationId) {\n          socket.emit(\"join_conversation\", conversationId);\n          console.log(\"Joined conversation room:\", conversationId);\n          await fetchMessages(token, conversationId, false);\n\n          // Mark conversation as read with proper request body\n          try {\n            await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, {\n              read: true\n            }, token);\n\n            // Update contacts list to remove unread badge\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? {\n              ...c,\n              unreadCount: 0\n            } : c));\n          } catch (readError) {\n            console.error(\"Error marking conversation as read:\", readError);\n            // Don't show error to user since this is a non-critical operation\n          }\n        } else {\n          // This case should ideally not be reached if createOrGetConversation throws errors\n          showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\");\n          setSelectedContact(null);\n        }\n      }\n    } catch (error) {\n      // Catch errors from fetchMessages or socket emits\n      console.error(\"Error in handleContactSelect processing:\", error);\n      showError(`Lỗi khi chọn liên hệ: ${error.message}`);\n      setSelectedContact(null); // Deselect on error\n    } finally {\n      setLoading(false); // Ensure loading is turned off\n    }\n  }, [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages]);\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(async e => {\n    e.preventDefault();\n    if (!newMessage.trim() || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n    const tempMessageId = `temp-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: newMessage,\n      time: messageTime,\n      senderId: user.id,\n      isSending: true // Indicate sending state\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    const messageToSend = newMessage; // Store message before clearing\n    setNewMessage(\"\"); // Clear input immediately\n    scrollToBottom(); // Scroll after adding optimistic message\n\n    try {\n      let response;\n      let messageDataForSocket;\n      if (selectedContact.type === \"group\") {\n        var _selectedContact$memb;\n        const groupId = selectedContact.groupId;\n        console.log(\"Attempting to send group message:\", {\n          groupId,\n          messageContent: messageToSend,\n          selectedContact\n        });\n        if (!groupId) {\n          throw new Error(\"GroupId is missing\");\n        }\n\n        // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n        if (!((_selectedContact$memb = selectedContact.memberIds) !== null && _selectedContact$memb !== void 0 && _selectedContact$memb.includes(user.id))) {\n          console.error(\"User not in group members:\", {\n            userId: user.id,\n            memberIds: selectedContact.memberIds,\n            members: selectedContact.members\n          });\n          throw new Error(\"Bạn không phải là thành viên của nhóm này\");\n        }\n        try {\n          response = await apiCall(\"post\", `/api/groups/${groupId}/messages`, {\n            content: messageToSend\n          }, token);\n          console.log(\"Group message API response:\", response);\n          if (!response) {\n            throw new Error(\"No response from server\");\n          }\n          if (!response.messageData) {\n            console.error(\"Invalid response structure:\", response);\n            throw new Error(\"Invalid response structure from server\");\n          }\n          const messageData = response.messageData;\n          messageDataForSocket = {\n            messageId: messageData.messageId,\n            groupId: groupId,\n            senderId: user.id,\n            senderName: user.name,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: messageData.createdAt || new Date().toISOString()\n          };\n          console.log(\"Emitting socket event with data:\", messageDataForSocket);\n          socket.emit(\"group_message\", messageDataForSocket);\n\n          // Update optimistic message with real ID and remove sending state\n          setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n            ...msg,\n            id: messageData.messageId,\n            isSending: false,\n            time: new Date(messageData.createdAt).toLocaleTimeString([], {\n              hour: \"2-digit\",\n              minute: \"2-digit\"\n            })\n          } : msg));\n        } catch (error) {\n          var _error$response3, _error$response4;\n          console.error(\"Error details:\", {\n            error,\n            groupId,\n            selectedContact,\n            user: {\n              id: user.id,\n              name: user.name\n            }\n          });\n          if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n            throw new Error(\"Không tìm thấy nhóm chat\");\n          } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403) {\n            throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\");\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        var _response$messageData, _response$messageData2;\n        // Handle individual contact message sending\n        const conversationId = selectedContact.conversationId;\n        if (!conversationId) {\n          throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\");\n        }\n        response = await apiCall(\"post\", \"/api/messages/send/text\", {\n          conversationId: conversationId,\n          content: messageToSend,\n          tempMessageId: tempMessageId // Add tempMessageId to help match response\n        }, token);\n        messageDataForSocket = {\n          messageId: ((_response$messageData = response.messageData) === null || _response$messageData === void 0 ? void 0 : _response$messageData.messageId) || response.messageId,\n          tempMessageId: tempMessageId,\n          // Include tempMessageId in socket event\n          conversationId: conversationId,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.id,\n          content: messageToSend,\n          type: \"text\",\n          createdAt: ((_response$messageData2 = response.messageData) === null || _response$messageData2 === void 0 ? void 0 : _response$messageData2.createdAt) || new Date().toISOString(),\n          time: messageTime // Include original time for matching\n        };\n        socket.emit(\"new_message\", messageDataForSocket);\n      }\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      showError(\"Không thể gửi tin nhắn: \" + error.message);\n      // Remove or mark optimistic message as failed\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n    }\n  }, [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(async (file, fileType = \"file\") => {\n    // fileType can be 'file', 'image', 'video'\n    if (!file || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n\n    // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`);\n      return;\n    }\n    if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n      showError(\"Chỉ chấp nhận file hình ảnh.\");\n      return;\n    }\n    if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n      showError(\"Chỉ chấp nhận file video.\");\n      return;\n    }\n\n    // Video duration check\n    let videoDuration = null;\n    if (fileType === \"video\") {\n      try {\n        const duration = await getVideoDuration(file);\n        if (duration > 90) {\n          showError(\"Video không được dài quá 90 giây.\");\n          return;\n        }\n        videoDuration = Math.round(duration);\n      } catch (err) {\n        showError(\"Không thể đọc thông tin video.\");\n        return;\n      }\n    }\n    const tempMessageId = `temp-file-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const tempUrl = URL.createObjectURL(file); // For optimistic UI\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: fileType === \"text\" ? file.name : tempUrl,\n      // Use tempUrl for image/video\n      time: messageTime,\n      senderId: user.id,\n      isSending: true,\n      isFile: fileType === \"file\",\n      isImage: fileType === \"image\",\n      isVideo: fileType === \"video\",\n      fileName: file.name,\n      fileType: file.type,\n      duration: videoDuration\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    scrollToBottom();\n    const formData = new FormData();\n    let apiUrl = \"\";\n    let apiKey = \"\"; // Key for the file in FormData\n\n    if (selectedContact.type === \"group\") {\n      const groupId = selectedContact.groupId;\n      formData.append(\"groupId\", groupId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = `/api/groups/${groupId}/images`;\n          apiKey = \"image\"; // Match backend key\n          break;\n        case \"video\":\n          apiUrl = `/api/groups/${groupId}/videos`;\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = `/api/groups/${groupId}/files`;\n          apiKey = \"file\";\n          break;\n      }\n    } else {\n      const conversationId = selectedContact.conversationId;\n      if (!conversationId) {\n        showError(\"Không tìm thấy cuộc trò chuyện để gửi file\");\n        URL.revokeObjectURL(tempUrl);\n        setMessages(prev => prev.filter(msg => msg.id !== tempMessageId)); // Remove optimistic msg\n        return;\n      }\n      formData.append(\"conversationId\", conversationId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = \"/api/messages/send/image\";\n          apiKey = \"images\"; // Match backend key (plural for this endpoint)\n          break;\n        case \"video\":\n          apiUrl = \"/api/messages/send/video\";\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = \"/api/messages/send/file\";\n          apiKey = \"file\";\n          break;\n      }\n    }\n    formData.append(apiKey, file);\n    try {\n      var _messageData$attachme;\n      const response = await apiCall(\"post\", apiUrl, formData, token);\n      const messageData = response.messageData || response; // Adjust based on API response structure\n      const attachment = (_messageData$attachme = messageData.attachments) === null || _messageData$attachme === void 0 ? void 0 : _messageData$attachme[0];\n      if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n        throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\");\n      }\n\n      // Update optimistic message\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        id: messageData.messageId,\n        content: attachment.url,\n        // Use final URL\n        fileUrl: fileType === \"file\" ? attachment.url : null,\n        isSending: false,\n        time: new Date(messageData.createdAt).toLocaleTimeString([], {\n          hour: \"2-digit\",\n          minute: \"2-digit\"\n        })\n      } : msg));\n\n      // Update media/documents list\n      const newItem = {\n        id: messageData.messageId,\n        type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n        url: attachment.url,\n        name: attachment.name || file.name,\n        date: new Date(messageData.createdAt).toLocaleDateString(),\n        size: attachment.size || file.size,\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      if (fileType === \"image\" || fileType === \"video\") {\n        setMediaFiles(prev => [newItem, ...prev]); // Add to beginning (newest)\n      } else {\n        setDocuments(prev => [newItem, ...prev]);\n      }\n\n      // Emit socket event\n      const socketEventData = {\n        messageId: messageData.messageId,\n        conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n        groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n        senderId: user.id,\n        senderName: user.name,\n        receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n        type: fileType,\n        // 'file', 'image', 'video'\n        content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null,\n        // Content might be null for media\n        attachments: messageData.attachments,\n        createdAt: messageData.createdAt || new Date().toISOString(),\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\";\n      socket.emit(socketEventName, socketEventData);\n      URL.revokeObjectURL(tempUrl); // Clean up temp URL\n    } catch (error) {\n      console.error(`Error sending ${fileType}:`, error);\n      showError(`Không thể gửi ${fileType}: ${error.message}`);\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n      URL.revokeObjectURL(tempUrl);\n    }\n  }, [isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n  const getVideoDuration = file => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\");\n      video.preload = \"metadata\";\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src);\n        resolve(video.duration);\n      };\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src);\n        reject(new Error(\"Không thể tải metadata video\"));\n      };\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback(emoji => {\n    setNewMessage(prev => prev + emoji);\n    setShowEmojiPicker(false);\n  }, []);\n  const handleMessageAction = useCallback(async (messageId, action) => {\n    if (action === \"delete\") {\n      const token = localStorage.getItem(\"token\");\n      if (!token || !selectedContact) return;\n\n      // Optimistic UI update\n      const originalMessages = [...messages];\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        content: \"Đang xóa...\",\n        isUnsent: true,\n        isDeleting: true\n      } : msg));\n      try {\n        if (selectedContact.type === \"group\") {\n          await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token);\n        } else {\n          await apiCall(\"delete\", `/api/messages/${messageId}`, null, token);\n        }\n\n        // Confirm deletion in UI\n        setMessages(prev => prev.map(msg => msg.id === messageId ? {\n          ...msg,\n          content: \"Tin nhắn đã bị xóa\",\n          isDeleting: false\n        } : msg));\n\n        // Remove from media/documents lists\n        setMediaFiles(prev => prev.filter(media => media.id !== messageId));\n        setDocuments(prev => prev.filter(doc => doc.id !== messageId));\n\n        // TODO: Emit socket event for deletion if needed by backend/other clients\n      } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        showError(\"Không thể xóa tin nhắn: \" + error.message);\n        // Revert optimistic update on error\n        setMessages(originalMessages);\n      }\n    }\n    // Handle other actions like 'recall' if implemented\n  }, [apiCall, selectedContact, showError, messages] // Include messages in dependency array\n  );\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true);\n    setShowFiles(false);\n  }, []);\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false);\n    setShowFiles(true);\n  }, []);\n  const handleTabChange = useCallback(tab => {\n    setActiveTab(tab);\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchFriendRequests(token);\n      }\n    }\n  }, [fetchFriendRequests]); // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null\n    });\n    setShowProfileModal(true);\n  }, [user.name, user.avatar]); // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false);\n  }, []);\n  const handleAvatarChange = useCallback(async file => {\n    // File validation\n    if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n      showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const formData = new FormData();\n    formData.append(\"avatar\", file);\n    try {\n      setLoading(true); // Indicate loading\n      const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token);\n      // Update state optimistically/realistically\n      setProfileData(prev => ({\n        ...prev,\n        avatarUrl: response.avatarUrl\n      }));\n      setUser(prev => ({\n        ...prev,\n        avatar: response.avatarUrl\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.avatarUrl = response.avatarUrl;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật ảnh đại diện thành công!\");\n    } catch (error) {\n      showError(\"Không thể tải avatar: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError]);\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    try {\n      setLoading(true);\n      const response = await apiCall(\"put\", \"/api/users/profile\", {\n        fullName: profileData.fullName,\n        // Ensure birthdate is sent correctly or omitted if empty\n        birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n        gender: profileData.gender || undefined // Send undefined if empty to potentially clear it\n      }, token);\n      // Update user state\n      setUser(prev => ({\n        ...prev,\n        name: response.fullName || prev.name\n        // Avatar might not be in this response, keep existing one\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.fullName = response.fullName;\n      userProfile.birthdate = response.birthdate;\n      userProfile.gender = response.gender;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật hồ sơ thành công!\");\n      handleCloseProfileModal();\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal]);\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true);\n  }, []);\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false);\n    setFriendEmail(\"\"); // Reset email field\n  }, []);\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\");\n      return;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      var _searchResult$data;\n      // Search user first to get ID\n      const searchResult = await apiCall(\"get\", `/api/users/search?query=${encodeURIComponent(friendEmail)}`, null, token);\n      if (!(searchResult !== null && searchResult !== void 0 && (_searchResult$data = searchResult.data) !== null && _searchResult$data !== void 0 && _searchResult$data.length)) {\n        throw new Error(\"Không tìm thấy người dùng với email này\");\n      }\n      const receiverId = searchResult.data[0].userId;\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\");\n      }\n\n      // Check if already friends\n      if (contacts.some(c => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\");\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", {\n        receiverId,\n        message: `Kết bạn từ ${user.name}`\n      }, token);\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`);\n      handleCloseAddFriendModal();\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`);\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`);\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`);\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`);\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false);\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts]);\n  const handleRespondToFriendRequest = useCallback(async (requestId, action) => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const request = friendRequests.find(req => req.requestId === requestId);\n    if (!request) return;\n    setLoading(true); // Indicate processing\n    // Optimistically remove from list\n    setFriendRequests(prev => prev.filter(req => req.requestId !== requestId));\n    try {\n      const response = await apiCall(\"post\", \"/api/friends/requests/respond\", {\n        requestId,\n        action\n      }, token);\n      console.log(\"Friend request response:\", response);\n      if (action === \"accept\") {\n        var _response$conversatio2, _senderInfo$email;\n        showError(\"Đã chấp nhận lời mời kết bạn\");\n        const senderInfo = request.sender;\n        if (!senderInfo || !senderInfo.userId) {\n          throw new Error(\"Thông tin người gửi không hợp lệ\");\n        }\n\n        // Get conversation ID (might be in response or need creation)\n        let conversationId = (_response$conversatio2 = response.conversation) === null || _response$conversatio2 === void 0 ? void 0 : _response$conversatio2.conversationId;\n        if (!conversationId) {\n          console.log(\"No conversationId in response, creating/getting...\");\n          conversationId = await createOrGetConversation(senderInfo.userId, token);\n        }\n        if (!conversationId) {\n          throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\");\n        }\n\n        // Create new contact object\n        const newContact = {\n          id: senderInfo.userId,\n          name: senderInfo.fullName || ((_senderInfo$email = senderInfo.email) === null || _senderInfo$email === void 0 ? void 0 : _senderInfo$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: senderInfo.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          conversationId: conversationId\n        };\n        addOrUpdateContact(newContact); // Add/update contact list and localStorage\n\n        // Optionally select the new contact immediately\n        // handleContactSelect(newContact);\n\n        // Emit notification to the sender via socket\n        if (socket.connected) {\n          socket.emit(\"friend_request_accepted_notify\", {\n            accepter: {\n              userId: user.id,\n              fullName: user.name,\n              avatarUrl: user.avatar\n            },\n            senderId: senderInfo.userId,\n            // Target the sender\n            conversationId: conversationId\n          });\n          // Also tell sender to refresh their list\n          socket.emit(\"refresh_contacts_notify\", {\n            targetUserId: senderInfo.userId\n          });\n          console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\");\n        }\n      } else {\n        showError(\"Đã từ chối lời mời kết bạn\");\n        // Optionally notify sender of rejection via socket\n      }\n    } catch (error) {\n      console.error(\"Error responding to friend request:\", error);\n      showError(\"Không thể phản hồi lời mời: \" + error.message);\n      // Revert optimistic removal on error\n      setFriendRequests(prev => [...prev, request]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleRemoveFriend = useCallback(async friendId => {\n    if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    console.log(`Attempting to remove friend with ID: ${friendId}`);\n    setLoading(true);\n\n    // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n    const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\");\n    if (!contactToRemove) {\n      showError(\"Không tìm thấy người dùng trong danh sách bạn bè\");\n      setLoading(false);\n      return;\n    }\n\n    // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n    const currentContacts = [...contacts];\n    try {\n      // Cập nhật UI trước khi gọi API (optimistic update)\n      setContacts(prev => prev.filter(contact => contact.id !== friendId || contact.type !== \"contact\"));\n\n      // Cập nhật localStorage\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const updatedContacts = savedContacts.filter(c => c.id !== friendId || c.type !== \"contact\");\n        localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts));\n      } catch (e) {\n        console.error(\"Error updating localStorage after friend removal\", e);\n      }\n\n      // Bỏ chọn nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === friendId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n\n      // Gọi API để xóa bạn bè\n      try {\n        console.log(`Calling API to remove friend: ${friendId}`);\n        const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token);\n        console.log(\"Friend removal API response:\", response);\n        showError(\"Đã xóa bạn bè thành công\");\n\n        // Thông báo cho người bạn bị xóa qua socket\n        if (socket && socket.connected) {\n          socket.emit(\"friend_removed_notify\", {\n            removerId: user.id,\n            removedUserId: friendId\n          });\n          console.log(\"Emitted friend_removed_notify\");\n\n          // Thông báo cập nhật danh sách bạn bè\n          socket.emit(\"friend_list_updated\");\n        }\n\n        // Cập nhật lại danh sách bạn bè từ server\n        fetchContactsAndGroups(token);\n      } catch (apiError) {\n        console.error(\"API error removing friend:\", apiError);\n\n        // Kiểm tra lỗi cụ thể\n        if (apiError.response && apiError.response.status === 404) {\n          // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n          showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\");\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token);\n        } else {\n          // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n          showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"));\n          // Khôi phục lại danh sách bạn bè\n          setContacts(currentContacts);\n\n          // Khôi phục localStorage\n          try {\n            localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n          } catch (e) {\n            console.error(\"Error restoring localStorage\", e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in handleRemoveFriend:\", error);\n      showError(\"Không thể xóa bạn bè: \" + error.message);\n\n      // Khôi phục lại danh sách bạn bè\n      setContacts(currentContacts);\n\n      // Khôi phục localStorage\n      try {\n        localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n      } catch (e) {\n        console.error(\"Error restoring localStorage\", e);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups]);\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true);\n  }, []);\n  const handleGroupCreated = useCallback(newGroupData => {\n    var _newGroupData$members;\n    console.log(\"Group created data:\", newGroupData);\n    const groupObject = {\n      groupId: newGroupData.groupId,\n      id: newGroupData.groupId,\n      // Add id for consistency\n      name: newGroupData.name,\n      avatar: newGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: newGroupData.adminId,\n      memberCount: ((_newGroupData$members = newGroupData.members) === null || _newGroupData$members === void 0 ? void 0 : _newGroupData$members.length) || 1,\n      // At least admin is a member\n      conversationId: newGroupData.conversationId || newGroupData.groupId,\n      createdAt: newGroupData.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    setShowCreateGroupModal(false);\n    showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`);\n    // Automatically select the new group\n    handleContactSelect(groupObject);\n  }, [addOrUpdateGroup, showError, handleContactSelect]);\n  const handleGroupInfo = useCallback(group => {\n    // Fetch full group details if necessary before showing modal\n    setSelectedGroup(group); // Pass the basic group info for now\n    setShowGroupInfoModal(true);\n    // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n  }, [] // No dependencies needed to just show the modal\n  );\n  const handleGroupUpdated = useCallback(updatedGroupData => {\n    var _updatedGroupData$mem;\n    console.log(\"Group updated data:\", updatedGroupData);\n    // Ensure the data structure matches what addOrUpdateGroup expects\n    const groupObject = {\n      groupId: updatedGroupData.groupId,\n      id: updatedGroupData.groupId,\n      name: updatedGroupData.name,\n      avatar: updatedGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: updatedGroupData.adminId,\n      memberCount: updatedGroupData.memberCount || ((_updatedGroupData$mem = updatedGroupData.members) === null || _updatedGroupData$mem === void 0 ? void 0 : _updatedGroupData$mem.length) || 0,\n      conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n      createdAt: updatedGroupData.createdAt\n      // Include other relevant fields if needed\n    };\n    addOrUpdateGroup(groupObject);\n    // Update selected contact if it's the one being edited\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupObject.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    setShowGroupInfoModal(false); // Close modal on success\n    showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleLeaveGroup = useCallback(async groupId => {\n    console.log(\"Leaving group:\", groupId);\n    if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      // Gọi API để rời nhóm\n      const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token);\n      console.log(\"Leave group API response:\", response);\n\n      // Cập nhật UI sau khi API thành công\n      setGroups(prev => prev.filter(group => group.groupId !== groupId));\n\n      // Cập nhật localStorage\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after leaving group\", e);\n      }\n\n      // Bỏ chọn nhóm nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n      setShowGroupInfoModal(false); // Đóng modal\n      showError(\"Bạn đã rời khỏi nhóm thành công\");\n\n      // Thông báo qua socket nếu cần\n      if (socket.connected) {\n        socket.emit(\"left_group\", {\n          groupId\n        });\n      }\n    } catch (error) {\n      console.error(\"Error leaving group:\", error);\n      showError(\"Không thể rời khỏi nhóm: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedContact, showError, apiCall]);\n  const handleDeleteGroup = useCallback(groupId => {\n    console.log(\"Deleting group:\", groupId);\n    setGroups(prev => prev.filter(group => group.groupId !== groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after deleting group\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    setShowGroupInfoModal(false); // Close modal\n    showError(\"Đã xóa nhóm thành công\");\n    // API call to delete group should be handled within GroupInfoModal or here before state update\n  }, [selectedContact, showError]);\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      navigate(\"/login\");\n      return;\n    }\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    let socketInitialized = false;\n    const initializeApp = async () => {\n      try {\n        setLoading(true);\n        const userProfile = await fetchUserProfile(token);\n        if (!userProfile || !isMounted) return; // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token);\n        if (!isMounted) return;\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token);\n        if (!isMounted) return;\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\");\n\n          // Set socket auth and query params\n          socket.auth = {\n            token\n          };\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now()\n          };\n\n          // Connect the socket\n          socket.connect();\n          socketInitialized = true;\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\");\n      socket.off(\"reconnect\");\n      socket.off(\"friend_request\");\n      socket.off(\"new_message\");\n      socket.off(\"receive_message\");\n      socket.off(\"group_message\");\n      socket.off(\"friend_request_accepted\");\n      socket.off(\"friend_removed\");\n      socket.off(\"refresh_contacts\");\n      socket.off(\"notification\");\n      socket.off(\"group_created\");\n      socket.off(\"group_updated\");\n      socket.off(\"group_deleted\");\n      socket.off(\"member_added\");\n      socket.off(\"member_removed\");\n    };\n  }, [navigate]); // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback(data => {\n    var _data$attachments, _data$attachments$, _data$attachments2, _data$attachments2$, _data$attachments3, _data$attachments3$, _data$attachments4, _data$attachments4$, _data$attachments5, _data$attachments5$;\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || !data.messageId && !data.id) {\n      console.error(\"Invalid message data received:\", data);\n      return;\n    }\n    const messageTime = data.createdAt ? new Date(data.createdAt).toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }) : new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString();\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type,\n      selectedContactGroupId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.groupId,\n      selectedContactConversationId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.conversationId\n    });\n    const isCurrentChat = (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\" && selectedContact.groupId === data.groupId || (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\" && selectedContact.conversationId === data.conversationId;\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content: data.isRecalled || data.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\" ? data.content : ((_data$attachments = data.attachments) === null || _data$attachments === void 0 ? void 0 : (_data$attachments$ = _data$attachments[0]) === null || _data$attachments$ === void 0 ? void 0 : _data$attachments$.url) || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: data.type === \"image\" || data.type === \"imageGroup\",\n      isVideo: data.type === \"video\",\n      isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: data.type === \"file\" ? (_data$attachments2 = data.attachments) === null || _data$attachments2 === void 0 ? void 0 : (_data$attachments2$ = _data$attachments2[0]) === null || _data$attachments2$ === void 0 ? void 0 : _data$attachments2$.url : null,\n      fileName: data.type === \"file\" ? (_data$attachments3 = data.attachments) === null || _data$attachments3 === void 0 ? void 0 : (_data$attachments3$ = _data$attachments3[0]) === null || _data$attachments3$ === void 0 ? void 0 : _data$attachments3$.name : null,\n      fileType: data.type === \"file\" ? (_data$attachments4 = data.attachments) === null || _data$attachments4 === void 0 ? void 0 : (_data$attachments4$ = _data$attachments4[0]) === null || _data$attachments4$ === void 0 ? void 0 : _data$attachments4$.type : null,\n      duration: data.type === \"video\" ? ((_data$attachments5 = data.attachments) === null || _data$attachments5 === void 0 ? void 0 : (_data$attachments5$ = _data$attachments5[0]) === null || _data$attachments5$ === void 0 ? void 0 : _data$attachments5$.duration) || data.duration : null,\n      messageDate: messageDate\n    };\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || [];\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev;\n        return {\n          ...prev,\n          [data.conversationId]: [...prevList, newMessage]\n        };\n      });\n    }\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        if (exists) return prev;\n        return [...prev, newMessage];\n      });\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles(prev => {\n          var _data$attachments6, _data$attachments6$;\n          return [{\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: ((_data$attachments6 = data.attachments) === null || _data$attachments6 === void 0 ? void 0 : (_data$attachments6$ = _data$attachments6[0]) === null || _data$attachments6$ === void 0 ? void 0 : _data$attachments6$.size) || 0,\n            duration: newMessage.duration\n          }, ...prev // Add to beginning\n          ];\n        });\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments(prev => {\n          var _newMessage$fileName, _data$attachments7, _data$attachments7$;\n          return [{\n            id: newMessage.id,\n            type: ((_newMessage$fileName = newMessage.fileName) === null || _newMessage$fileName === void 0 ? void 0 : _newMessage$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: ((_data$attachments7 = data.attachments) === null || _data$attachments7 === void 0 ? void 0 : (_data$attachments7$ = _data$attachments7[0]) === null || _data$attachments7$ === void 0 ? void 0 : _data$attachments7$.size) || 0\n          }, ...prev // Add to beginning\n          ];\n        });\n      }\n    } else {\n      var _data$content, _data$content2;\n      // Notification for message in other chat\n      let senderName = \"Người dùng\";\n      let contactId = data.senderId; // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find(g => g.groupId === data.groupId);\n        senderName = `${data.senderName || \"Ai đó\"} (${(group === null || group === void 0 ? void 0 : group.name) || \"Nhóm\"})`;\n      } else {\n        const contact = contacts.find(c => c.id === data.senderId); // Tìm contact dựa trên senderId\n        senderName = (contact === null || contact === void 0 ? void 0 : contact.name) || data.senderName || \"Ai đó\";\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n      const preview = data.type === \"text\" ? ((_data$content = data.content) === null || _data$content === void 0 ? void 0 : _data$content.substring(0, 30)) + (((_data$content2 = data.content) === null || _data$content2 === void 0 ? void 0 : _data$content2.length) > 30 ? \"...\" : \"\") : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`;\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`);\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview,\n              // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      var _contacts$find, _groups$find;\n      const contactName = data.senderName || \"Người dùng\";\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: ((_contacts$find = contacts.find(c => c.id === data.senderId)) === null || _contacts$find === void 0 ? void 0 : _contacts$find.avatar) || ((_groups$find = groups.find(g => g.groupId === data.groupId)) === null || _groups$find === void 0 ? void 0 : _groups$find.avatar) || \"/favicon.ico\" // Optional icon\n      });\n    }\n  }, [user.id, contacts, groups, selectedContact, showError]);\n  const handleFriendRequest = useCallback(data => {\n    if (!data || !data.requestId || !data.sender) return;\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab]);\n  const handleFriendRequestAccepted = useCallback(data => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\");\n      return;\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleFriendRemoved = useCallback(data => {\n    if (!data || !data.removerId) return;\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError]);\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\");\n    if (token) {\n      fetchContactsAndGroups(token);\n    }\n  }, [fetchContactsAndGroups]);\n  const handleSocketGroupCreated = useCallback(data => {\n    var _group$members3;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_created event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: ((_group$members3 = group.members) === null || _group$members3 === void 0 ? void 0 : _group$members3.length) || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`);\n  }, [addOrUpdateGroup, showError]);\n  const handleSocketGroupUpdated = useCallback(data => {\n    var _group$members4;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_updated event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members4 = group.members) === null || _group$members4 === void 0 ? void 0 : _group$members4.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleGroupDeleted = useCallback(data => {\n    var _groups$find2;\n    if (!(data !== null && data !== void 0 && data.groupId)) return;\n    console.log(\"Received group_deleted event:\", data.groupId);\n    const groupName = ((_groups$find2 = groups.find(g => g.groupId === data.groupId)) === null || _groups$find2 === void 0 ? void 0 : _groups$find2.name) || \"Một nhóm\";\n    setGroups(prev => prev.filter(group => group.groupId !== data.groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== data.groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after group delete\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === data.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`);\n  }, [groups, selectedContact, showError]);\n  const handleMemberAdded = useCallback(data => {\n    var _group$members5;\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.member) || !(data !== null && data !== void 0 && data.addedBy)) return;\n    console.log(\"Received member_added event:\", data);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members5 = group.members) === null || _group$members5 === void 0 ? void 0 : _group$members5.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleMemberRemoved = useCallback(data => {\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.memberId) || !(data !== null && data !== void 0 && data.removedBy)) return;\n    console.log(\"Received member_removed event:\", data);\n    const group = data.group;\n    const groupId = group.groupId;\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`);\n      setGroups(prev => prev.filter(g => g.groupId !== groupId));\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after being removed from group\", e);\n      }\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n    } else {\n      var _group$members6, _data$member;\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || ((_group$members6 = group.members) === null || _group$members6 === void 0 ? void 0 : _group$members6.length) || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt\n      };\n      addOrUpdateGroup(groupObject);\n      const memberName = ((_data$member = data.member) === null || _data$member === void 0 ? void 0 : _data$member.fullName) || \"một thành viên\";\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`);\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(groupObject);\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleNotification = useCallback(data => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data);\n      return;\n    }\n    if (data.type === \"success\") {\n      showError(data.message);\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\");\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\");\n    } else {\n      showError(data.message);\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchContactsAndGroups(token);\n      }\n    }\n  }, [showError, fetchContactsAndGroups]);\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true;\n    const handleConnect = () => {\n      if (!isMounted) return;\n      console.log(\"Socket re-connected inside hook.\");\n      setIsConnected(true);\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId);\n      }\n    };\n\n    // Add handler for message_sent event\n    const handleMessageSent = data => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data);\n        return;\n      }\n      console.log(\"Received message_sent_success event:\", data);\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n        // Match by tempMessageId if available\n        data.tempMessageId && msg.id === data.tempMessageId ||\n        // Or match by conversationId and content if tempMessageId not available\n        data.conversationId && msg.conversationId === data.conversationId && msg.content === data.content)) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          });\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          };\n        }\n        return msg;\n      }));\n    };\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect);\n    socket.on(\"message_sent_success\", handleMessageSent); // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage);\n    socket.on(\"receive_message\", handleNewMessage);\n    socket.on(\"group_message\", handleNewMessage);\n    socket.on(\"friend_request\", handleFriendRequest);\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted);\n    socket.on(\"friend_removed\", handleFriendRemoved);\n    socket.on(\"refresh_contacts\", handleRefreshContacts);\n    socket.on(\"notification\", handleNotification);\n    socket.on(\"group_created\", handleSocketGroupCreated);\n    socket.on(\"group_updated\", handleSocketGroupUpdated);\n    socket.on(\"group_deleted\", handleGroupDeleted);\n    socket.on(\"member_added\", handleMemberAdded);\n    socket.on(\"member_removed\", handleMemberRemoved);\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false;\n      socket.off(\"connect\", handleConnect);\n      socket.off(\"message_sent_success\", handleMessageSent); // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage);\n      socket.off(\"receive_message\", handleNewMessage);\n      socket.off(\"group_message\", handleNewMessage);\n      socket.off(\"friend_request\", handleFriendRequest);\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted);\n      socket.off(\"friend_removed\", handleFriendRemoved);\n      socket.off(\"refresh_contacts\", handleRefreshContacts);\n      socket.off(\"notification\", handleNotification);\n      socket.off(\"group_created\", handleSocketGroupCreated);\n      socket.off(\"group_updated\", handleSocketGroupUpdated);\n      socket.off(\"group_deleted\", handleGroupDeleted);\n      socket.off(\"member_added\", handleMemberAdded);\n      socket.off(\"member_removed\", handleMemberRemoved);\n    };\n  }, [handleNewMessage, handleFriendRequest, handleFriendRequestAccepted, handleFriendRemoved, handleRefreshContacts, handleNotification, handleSocketGroupCreated, handleSocketGroupUpdated, handleGroupDeleted, handleMemberAdded, handleMemberRemoved, selectedContact // Add selectedContact as dependency\n  ]);\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]); // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n      var _messagesEndRef$curre;\n      (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"end\"\n      });\n    }, 100);\n  };\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(contact => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const filteredGroups = groups.filter(group => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"]; // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts,\n    // Return full contacts list if needed elsewhere\n    groups,\n    // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab,\n    // Needed for friend request notification\n    setShowProfileModal,\n    // Needed for closing modal from component\n    setProfileData,\n    // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal,\n    // Needed for closing modal from component\n    setFriendEmail,\n    // Needed for form input\n    // setError, // Internal state\n    setShowToast,\n    // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal,\n    // Needed for closing modal from component\n    setShowGroupInfoModal,\n    // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile,\n    // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError,\n    // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\") // Pass token for Modals\n  };\n};\n_s(useChat, \"o3e9ngAy0aNkp6FNjXM2/W+DiHI=\", false, function () {\n  return [useNavigate];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useNavigate","axios","io","API_BASE_URL","socket","autoConnect","reconnection","reconnectionAttempts","Number","POSITIVE_INFINITY","reconnectionDelay","reconnectionDelayMax","timeout","transports","upgrade","forceNew","query","timestamp","Date","now","on","console","log","id","err","error","reason","window","originalConsoleError","args","includes","apply","useChat","_s","navigate","user","setUser","name","avatar","contacts","setContacts","groups","setGroups","selectedContact","setSelectedContact","messages","setMessages","newMessage","setNewMessage","isConnected","setIsConnected","connected","showEmojiPicker","setShowEmojiPicker","searchQuery","setSearchQuery","mediaFiles","setMediaFiles","documents","setDocuments","showMedia","setShowMedia","showFiles","setShowFiles","activeTab","setActiveTab","showProfileModal","setShowProfileModal","profileData","setProfileData","fullName","birthdate","gender","avatarUrl","loading","setLoading","showAddFriendModal","setShowAddFriendModal","friendEmail","setFriendEmail","setError","showToast","setShowToast","friendRequests","setFriendRequests","recoveredContacts","setRecoveredContacts","showCreateGroupModal","setShowCreateGroupModal","showGroupInfoModal","setShowGroupInfoModal","selectedGroup","setSelectedGroup","cachedMessages","setCachedMessages","messagesEndRef","fileInputRef","imageInputRef","videoInputRef","showError","message","apiCall","method","url","data","token","toUpperCase","FormData","config","headers","Authorization","Pragma","response","status","_error$response","_error$response2","_error$response2$data","localStorage","removeItem","Error","errorMessage","addOrUpdateContact","newContact","savedContacts","getItem","contactsArray","JSON","parse","filter","c","push","setItem","stringify","storageError","prev","exists","some","contact","map","addOrUpdateGroup","newGroup","groupId","savedGroups","groupsArray","g","group","fetchUserProfile","userData","userId","toISOString","split","fetchMessages","conversationId","isGroup","warn","endpoint","messagesData","Array","isArray","mappedMessages","msg","index","_msg$attachments","_msg$attachments$","_msg$attachments2","_msg$attachments$2","_msg$attachments3","_msg$attachments$3","_msg$attachments4","_msg$attachments$4","_msg$attachments5","_msg$attachments$5","messageId","sender","senderId","senderName","content","isRecalled","isDeleted","type","attachments","time","toLocaleTimeString","hour","minute","isImage","isVideo","isFile","isUnsent","isSystemMessage","fileUrl","length","fileName","fileType","duration","messageDate","toLocaleDateString","systemMessage","unshift","mergedMessages","cacheList","newFromCache","cacheMsg","media","_msg$attachments6","_msg$attachments6$","date","size","reverse","files","_msg$fileName","_msg$attachments7","_msg$attachments7$","pop","toLowerCase","fetchContactsAndGroups","fetchedContacts","fetchedGroups","friendsResponse","confirmedFriends","friends","validFriends","friend","friendshipId","mappedFriends","_friend$email","email","convResponse","conversationsMap","Map","forEach","conv","participants","otherUserId","find","set","has","get","existingContactsMap","existingContact","groupsResponse","userGroups","members","member","_group$members","_group$members2","adminId","admin","memberIds","memberCount","createdAt","e","fetchFriendRequests","createOrGetConversation","_response$conversatio","conversation","handleContactSelect","contactOrGroup","roomToLeave","eventName","emit","updatedContact","currentContacts","updatedContactsList","read","unreadCount","readError","handleSendMessage","preventDefault","trim","tempMessageId","messageTime","optimisticMessage","isSending","messageToSend","scrollToBottom","messageDataForSocket","_selectedContact$memb","messageContent","messageData","_error$response3","_error$response4","_response$messageData","_response$messageData2","receiverId","isError","handleSendFile","file","maxSize","startsWith","videoDuration","getVideoDuration","Math","round","tempUrl","URL","createObjectURL","formData","apiUrl","apiKey","append","revokeObjectURL","_messageData$attachme","attachment","newItem","socketEventData","socketEventName","Promise","resolve","reject","video","document","createElement","preload","onloadedmetadata","src","onerror","handleEmojiSelect","emoji","handleMessageAction","action","originalMessages","isDeleting","doc","toggleMediaView","toggleFilesView","handleTabChange","tab","handleProfileClick","userProfile","handleCloseProfileModal","handleAvatarChange","handleUpdateProfile","undefined","handleAddFriend","handleCloseAddFriendModal","handleSubmitAddFriend","emailRegex","test","_searchResult$data","searchResult","encodeURIComponent","handleRespondToFriendRequest","requestId","request","req","_response$conversatio2","_senderInfo$email","senderInfo","accepter","targetUserId","handleRemoveFriend","friendId","confirm","contactToRemove","updatedContacts","removerId","removedUserId","apiError","handleCreateGroup","handleGroupCreated","newGroupData","_newGroupData$members","groupObject","handleGroupInfo","handleGroupUpdated","updatedGroupData","_updatedGroupData$mem","handleLeaveGroup","updatedGroups","handleDeleteGroup","isMounted","socketInitialized","initializeApp","auth","opts","connect","off","handleNewMessage","_data$attachments","_data$attachments$","_data$attachments2","_data$attachments2$","_data$attachments3","_data$attachments3$","_data$attachments4","_data$attachments4$","_data$attachments5","_data$attachments5$","selectedContactType","selectedContactGroupId","selectedContactConversationId","isCurrentChat","prevList","_data$attachments6","_data$attachments6$","_newMessage$fileName","_data$attachments7","_data$attachments7$","_data$content","_data$content2","contactId","targetId","isGroupMessage","preview","substring","item","itemIdToMatch","lastMessage","lastMessageAt","hidden","Notification","permission","_contacts$find","_groups$find","contactName","body","icon","handleFriendRequest","handleFriendRequestAccepted","handleFriendRemoved","handleRefreshContacts","handleSocketGroupCreated","_group$members3","handleSocketGroupUpdated","_group$members4","handleGroupDeleted","_groups$find2","groupName","handleMemberAdded","_group$members5","addedBy","handleMemberRemoved","memberId","removedBy","_group$members6","_data$member","memberName","handleNotification","refreshContacts","handleConnect","handleMessageSent","prevMessages","oldId","newId","setTimeout","_messagesEndRef$curre","current","scrollIntoView","behavior","block","filteredContacts","filteredGroups","emojis"],"sources":["C:/Users/ADMIN/Desktop/Nhom12_Zalo_Web/FE-WebAppZola/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\"\nimport { useNavigate } from \"react-router-dom\"\nimport axios from \"axios\"\nimport { io } from \"socket.io-client\"\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\"\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false, // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false, // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now(),\n  },\n})\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id)\n})\n\nsocket.on(\"connect_error\", (err) => {\n  console.error(\"Socket connection error:\", err)\n})\n\nsocket.on(\"disconnect\", (reason) => {\n  console.log(\"Socket disconnected:\", reason)\n})\n\nsocket.on(\"error\", (err) => {\n  console.error(\"Socket error:\", err)\n})\n\nsocket.on(\"reconnect_error\", (err) => {\n  console.error(\"Socket reconnection error:\", err)\n})\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error\n  console.error = (...args) => {\n    if (\n      args[0] &&\n      typeof args[0] === \"string\" &&\n      (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))\n    ) {\n      return\n    }\n    originalConsoleError.apply(console, args)\n  }\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  const navigate = useNavigate()\n\n  // State Management\n  const [user, setUser] = useState({ id: \"\", name: \"User\", avatar: \"\" })\n  const [contacts, setContacts] = useState([])\n  const [groups, setGroups] = useState([])\n  const [selectedContact, setSelectedContact] = useState(null)\n  const [messages, setMessages] = useState([])\n  const [newMessage, setNewMessage] = useState(\"\")\n  const [isConnected, setIsConnected] = useState(socket.connected) // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false)\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [mediaFiles, setMediaFiles] = useState([])\n  const [documents, setDocuments] = useState([])\n  const [showMedia, setShowMedia] = useState(true)\n  const [showFiles, setShowFiles] = useState(false)\n  const [activeTab, setActiveTab] = useState(\"chat\")\n  const [showProfileModal, setShowProfileModal] = useState(false)\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null,\n  })\n  const [loading, setLoading] = useState(false)\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false)\n  const [friendEmail, setFriendEmail] = useState(\"\")\n  const [error, setError] = useState(null)\n  const [showToast, setShowToast] = useState(false)\n  const [friendRequests, setFriendRequests] = useState([])\n  const [recoveredContacts, setRecoveredContacts] = useState([]) // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false)\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false)\n  const [selectedGroup, setSelectedGroup] = useState(null)\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({})\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null)\n  const fileInputRef = useRef(null)\n  const imageInputRef = useRef(null)\n  const videoInputRef = useRef(null)\n\n  // --- Utility Functions ---\n\n  const showError = useCallback((message) => {\n    console.log(\"Showing Toast:\", message)\n    setError(message)\n    setShowToast(true)\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, [])\n\n  const apiCall = useCallback(\n    async (method, url, data = null, token) => {\n      try {\n        console.log(`API Call: ${method.toUpperCase()} ${url}`)\n        if (data) {\n          console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data)\n        }\n\n        const config = {\n          method,\n          url: `${API_BASE_URL}${url}`,\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n            \"If-None-Match\": \"\", // Prevent 304 responses\n          },\n          data,\n        }\n\n        if (!(data instanceof FormData)) {\n          config.headers[\"Content-Type\"] = \"application/json\"\n        }\n\n        console.log(\"Using config:\", {\n          method: config.method,\n          url: config.url,\n          headers: { ...config.headers, Authorization: \"Bearer [HIDDEN]\" },\n        })\n\n        const response = await axios(config)\n        console.log(`API Response ${url}:`, response.status, response.data)\n        return response.data\n      } catch (error) {\n        console.error(`API Error ${url}:`, error)\n        if (error.response) {\n          console.error(\"Response status:\", error.response.status)\n          console.error(\"Response data:\", error.response.data)\n        }\n\n        if (error.response?.status === 401) {\n          localStorage.removeItem(\"token\")\n          localStorage.removeItem(\"userProfile\") // Clear profile too\n          navigate(\"/login\")\n          // Use showError for consistency\n          showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\")\n          throw new Error(\"Phiên đăng nhập hết hạn.\") // Throw to stop further execution\n        }\n\n        const errorMessage = error.response?.data?.message || error.message || \"Đã xảy ra lỗi không xác định\"\n        // Don't automatically show toast here, let the calling function decide\n        // showError(errorMessage);\n        throw new Error(errorMessage)\n      }\n    },\n    [navigate, showError],\n  ) // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback((newContact) => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact)\n      return\n    }\n    console.log(\"Adding or updating contact:\", newContact)\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\")\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : []\n      contactsArray = contactsArray.filter((c) => c.id !== newContact.id)\n      contactsArray.push(newContact)\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray))\n      console.log(\"Saved contact to localStorage:\", newContact.id)\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError)\n    }\n    setContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n  }, [])\n\n  const addOrUpdateGroup = useCallback((newGroup) => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup)\n      return\n    }\n    console.log(\"Adding or updating group:\", newGroup)\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\")\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : []\n      groupsArray = groupsArray.filter((g) => g.groupId !== newGroup.groupId)\n      groupsArray.push(newGroup)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray))\n      console.log(\"Saved group to localStorage:\", newGroup.groupId)\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError)\n    }\n    setGroups((prev) => {\n      const exists = prev.some((group) => group.groupId === newGroup.groupId)\n      if (exists) {\n        return prev.map((group) => (group.groupId === newGroup.groupId ? { ...group, ...newGroup } : group))\n      }\n      return [...prev, newGroup]\n    })\n  }, [])\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(\n    async (token) => {\n      try {\n        const response = await apiCall(\"get\", \"/api/users/profile\", null, token)\n        const userData = {\n          id: response.userId,\n          name: response.fullName || \"User\",\n          avatar: response.avatarUrl || \"\",\n        }\n        setUser(userData)\n        setProfileData({\n          fullName: response.fullName || \"\",\n          birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n          gender: response.gender || \"\",\n          avatarUrl: response.avatarUrl || null,\n        })\n        // Save profile to localStorage after fetching\n        localStorage.setItem(\"userProfile\", JSON.stringify(response))\n        return response // Return the full profile\n      } catch (error) {\n        console.error(\"Error fetching user profile:\", error)\n        showError(\"Không thể lấy thông tin người dùng: \" + error.message)\n        // No need to navigate here, apiCall handles 401\n        return null\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const fetchMessages = useCallback(\n    async (token, conversationId, isGroup = false) => {\n      if (!token || !conversationId) {\n        console.warn(\"fetchMessages called without token or conversationId\")\n        setMessages([]) // Clear messages if no ID\n        setMediaFiles([])\n        setDocuments([])\n        return\n      }\n      setLoading(true) // Indicate loading messages\n      try {\n        let response\n        // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n        const endpoint = `/api/messages/conversations/${conversationId}/messages`\n\n        console.log(\"Fetching messages from endpoint:\", endpoint)\n        response = await apiCall(\"get\", endpoint, null, token)\n        console.log(\"Messages API response:\", response)\n\n        const messagesData = Array.isArray(response) ? response : response.data || []\n\n        const mappedMessages = messagesData\n          .map((msg, index) => ({\n            id: msg.messageId || `temp-${Date.now()}-${index}`,\n            sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n            content:\n              msg.isRecalled || msg.isDeleted\n                ? \"Tin nhắn đã bị thu hồi/xóa\"\n                : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\"\n                  ? msg.content\n                  : msg.attachments?.[0]?.url || msg.content || \"\", // Ensure content exists\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            senderId: msg.senderId,\n            isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n            isVideo: msg.type === \"video\",\n            isFile: msg.type === \"file\",\n            isUnsent: msg.isRecalled || msg.isDeleted,\n            isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n            fileUrl: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.url : null,\n            fileName: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.name : null,\n            fileType: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.type : null,\n            duration: msg.type === \"video\" && msg.attachments?.length > 0 ? msg.attachments[0]?.duration : null,\n            messageDate: new Date().toLocaleDateString(), // Used for media/files list\n          }))\n          .filter((msg) => msg.id) // Filter out messages without an ID\n\n        // Add system message if needed\n        if (mappedMessages.length === 0 || !mappedMessages.some((msg) => msg.isSystemMessage)) {\n          const systemMessage = isGroup\n            ? \"Chào mừng bạn đến với nhóm chat!\"\n            : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\"\n          mappedMessages.unshift({\n            id: `system-${Date.now()}`,\n            senderId: \"system\",\n            content: systemMessage,\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            isSystemMessage: true,\n          })\n        }\n\n        // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n        let mergedMessages = mappedMessages\n        if (cachedMessages[conversationId]) {\n          const cacheList = cachedMessages[conversationId]\n          // Lọc ra các tin nhắn cache chưa có trong mappedMessages\n          const newFromCache = cacheList.filter(\n            cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id)\n          )\n          mergedMessages = [...mappedMessages, ...newFromCache]\n        }\n        setMessages(mergedMessages)\n\n        // Update Media and Documents\n        const media = mappedMessages\n          .filter((msg) => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.isImage ? \"image\" : \"video\",\n            url: msg.content,\n            name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0, // Might not be available, default to 0\n            duration: msg.duration,\n          }))\n        setMediaFiles(media.reverse()) // Show newest first\n\n        const files = mappedMessages\n          .filter((msg) => msg.isFile && !msg.isUnsent && msg.fileUrl)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: msg.fileUrl,\n            name: msg.fileName,\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0,\n          }))\n        setDocuments(files.reverse()) // Show newest first\n      } catch (error) {\n        console.error(\"Error fetching messages:\", error)\n        showError(\"Không thể tải tin nhắn: \" + error.message)\n        setMessages([]) // Clear messages on error\n        setMediaFiles([])\n        setDocuments([])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id to compare sender\n  )\n\n  const fetchContactsAndGroups = useCallback(\n    async (token) => {\n      if (!token) return { contacts: [], groups: [] }\n      setLoading(true)\n      let fetchedContacts = []\n      let fetchedGroups = []\n\n      try {\n        // Fetch Friends (Contacts) from server first\n        console.log(\"Fetching friends from server...\")\n        const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token)\n        console.log(\"Friends API response:\", friendsResponse)\n\n        // Lọc ra những người bạn đã được xác nhận\n        // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n        const confirmedFriends = friendsResponse?.friends || []\n        console.log(\"Confirmed friends:\", confirmedFriends)\n\n        // Kiểm tra xem danh sách bạn bè có hợp lệ không\n        const validFriends = confirmedFriends.filter(friend =>\n          friend && friend.userId && friend.friendshipId\n        )\n\n        if (validFriends.length !== confirmedFriends.length) {\n          console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`)\n        }\n\n        const mappedFriends = validFriends.map((friend) => ({\n          id: friend.userId,\n          name: friend.fullName || friend.email?.split(\"@\")[0] || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\", // Trạng thái mặc định\n          friendshipId: friend.friendshipId, // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null, // Will be populated later\n        }))\n\n        // Fetch Conversations to get conversation IDs\n        console.log(\"Fetching conversations...\")\n        const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token)\n        const conversationsMap = new Map()\n        if (convResponse && Array.isArray(convResponse)) {\n          convResponse.forEach((conv) => {\n            if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n              const otherUserId = conv.participants.find((id) => id !== user.id)\n              if (otherUserId) {\n                conversationsMap.set(otherUserId, conv.conversationId)\n              }\n            }\n          })\n        }\n\n        // Update conversationId for mapped friends\n        mappedFriends.forEach((friend) => {\n          if (conversationsMap.has(friend.id)) {\n            friend.conversationId = conversationsMap.get(friend.id)\n          }\n        })\n\n        // Merge with existing contacts to preserve any additional data\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n\n        // Create a map of existing contacts for quick lookup\n        const existingContactsMap = new Map()\n        savedContacts.forEach(contact => {\n          if (contact && contact.id) {\n            existingContactsMap.set(contact.id, contact)\n          }\n        })\n\n        // Merge server data with existing data, prioritizing server data\n        fetchedContacts = mappedFriends.map(friend => {\n          const existingContact = existingContactsMap.get(friend.id)\n          if (existingContact) {\n            // Preserve conversationId if it exists in saved contact but not in server data\n            if (!friend.conversationId && existingContact.conversationId) {\n              friend.conversationId = existingContact.conversationId\n            }\n            return { ...existingContact, ...friend }\n          }\n          return friend\n        })\n\n        // Update state and localStorage\n        setContacts(fetchedContacts)\n        localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts))\n        console.log(\"Updated contacts from API:\", fetchedContacts.length)\n\n        // Fetch Groups\n        console.log(\"Fetching groups...\")\n        const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token)\n        console.log(\"Groups API response:\", groupsResponse)\n\n        if (groupsResponse && groupsResponse.groups) {\n          // Lọc các nhóm mà người dùng là thành viên\n          const userGroups = groupsResponse.groups.filter(\n            (group) => group.members && group.members.some(member => member.userId === user.id)\n          )\n          console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`)\n\n          fetchedGroups = userGroups.map((group) => ({\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [], // Lưu toàn bộ thông tin thành viên\n            memberIds: group.members?.map(member => member.userId) || [], // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || group.members?.length || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt,\n          }))\n          setGroups(fetchedGroups)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups))\n          console.log(\"Updated groups from API:\", fetchedGroups.length)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } catch (error) {\n        console.error(\"Error fetching contacts/groups:\", error)\n        showError(\"Không thể tải danh bạ/nhóm: \" + error.message)\n\n        // Fallback to localStorage only if server fetch fails\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n\n          if (savedContacts.length > 0) {\n            console.log(\"Falling back to contacts from localStorage\")\n            setContacts(savedContacts)\n            fetchedContacts = savedContacts\n          }\n\n          if (savedGroups.length > 0) {\n            console.log(\"Falling back to groups from localStorage\")\n            setGroups(savedGroups)\n            fetchedGroups = savedGroups\n          }\n        } catch (e) {\n          console.error(\"Error reading contacts/groups from localStorage\", e)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id for conversation mapping\n  )\n\n  const fetchFriendRequests = useCallback(\n    async (token) => {\n      if (!token) return\n      // No need for setLoading(true) here unless it's a primary action\n      try {\n        const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token)\n        setFriendRequests(response.data || [])\n      } catch (error) {\n        console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error)\n        // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(\n    async (otherUserId, token) => {\n      console.log(`Creating/getting conversation with user: ${otherUserId}`)\n      if (!token || !otherUserId) {\n        throw new Error(\"Token or otherUserId missing for createOrGetConversation\")\n      }\n      try {\n        const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token)\n        if (response?.conversation?.conversationId) {\n          console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId)\n          return response.conversation.conversationId\n        } else {\n          throw new Error(\"Invalid response structure from conversation API\")\n        }\n      } catch (error) {\n        console.error(\"Error in createOrGetConversation:\", error)\n        if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n          throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\")\n        }\n        throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`) // Rethrow with context\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(\n    async (contactOrGroup) => {\n      if (!contactOrGroup || contactOrGroup.id === selectedContact?.id) {\n        console.log(\"Selection unchanged or invalid.\")\n        return // Avoid re-selecting the same contact/group\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        navigate(\"/login\")\n        return\n      }\n\n      console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id)\n\n      // Leave previous room\n      if (selectedContact) {\n        const roomToLeave =\n          selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId\n        if (roomToLeave) {\n          const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\"\n          socket.emit(eventName, roomToLeave)\n          console.log(`Left ${selectedContact.type} room:`, roomToLeave)\n        }\n      }\n\n      // Clear previous state\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n      setSelectedContact(contactOrGroup) // Set selected contact immediately for UI update\n\n      try {\n        setLoading(true) // Show loading for message fetch\n\n        if (contactOrGroup.type === \"group\") {\n          const groupId = contactOrGroup.groupId\n          // Sử dụng conversationId từ group object\n          const conversationId = contactOrGroup.conversationId || groupId\n          socket.emit(\"join_group\", groupId)\n          console.log(\"Joined group room:\", groupId)\n          console.log(\"Using conversationId for group:\", conversationId)\n          await fetchMessages(token, conversationId, true)\n        } else {\n          // Handle individual contact\n          let conversationId = contactOrGroup.conversationId\n\n          // If conversationId is missing, try to fetch/create it\n          if (!conversationId) {\n            console.log(\"Conversation ID missing, attempting to fetch/create...\")\n            try {\n              conversationId = await createOrGetConversation(contactOrGroup.id, token)\n              // Update the contact in the list and the selected contact state\n              const updatedContact = { ...contactOrGroup, conversationId }\n              setSelectedContact(updatedContact) // Update selected state with new ID\n              setContacts((prev) => prev.map((c) => (c.id === contactOrGroup.id ? updatedContact : c)))\n              // Optionally save updated contacts list to localStorage\n              const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n              const updatedContactsList = currentContacts.map((c) =>\n                c.id === contactOrGroup.id ? updatedContact : c,\n              )\n              localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList))\n            } catch (error) {\n              showError(error.message) // Show error from createOrGetConversation\n              setSelectedContact(null) // Deselect if conversation fails\n              setLoading(false)\n              return // Stop execution if conversation fails\n            }\n          }\n\n          if (conversationId) {\n            socket.emit(\"join_conversation\", conversationId)\n            console.log(\"Joined conversation room:\", conversationId)\n            await fetchMessages(token, conversationId, false)\n\n            // Mark conversation as read with proper request body\n            try {\n              await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, { read: true }, token)\n\n              // Update contacts list to remove unread badge\n              setContacts((prev) =>\n                prev.map((c) =>\n                  c.id === contactOrGroup.id ? { ...c, unreadCount: 0 } : c\n                )\n              )\n            } catch (readError) {\n              console.error(\"Error marking conversation as read:\", readError)\n              // Don't show error to user since this is a non-critical operation\n            }\n          } else {\n            // This case should ideally not be reached if createOrGetConversation throws errors\n            showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\")\n            setSelectedContact(null)\n          }\n        }\n      } catch (error) {\n        // Catch errors from fetchMessages or socket emits\n        console.error(\"Error in handleContactSelect processing:\", error)\n        showError(`Lỗi khi chọn liên hệ: ${error.message}`)\n        setSelectedContact(null) // Deselect on error\n      } finally {\n        setLoading(false) // Ensure loading is turned off\n      }\n    },\n    [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages],\n  )\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(\n    async (e) => {\n      e.preventDefault()\n      if (!newMessage.trim() || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      const tempMessageId = `temp-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: newMessage,\n        time: messageTime,\n        senderId: user.id,\n        isSending: true, // Indicate sending state\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      const messageToSend = newMessage // Store message before clearing\n      setNewMessage(\"\") // Clear input immediately\n      scrollToBottom() // Scroll after adding optimistic message\n\n      try {\n        let response\n        let messageDataForSocket\n\n        if (selectedContact.type === \"group\") {\n          const groupId = selectedContact.groupId\n          console.log(\"Attempting to send group message:\", {\n            groupId,\n            messageContent: messageToSend,\n            selectedContact\n          })\n\n          if (!groupId) {\n            throw new Error(\"GroupId is missing\")\n          }\n\n          // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n          if (!selectedContact.memberIds?.includes(user.id)) {\n            console.error(\"User not in group members:\", {\n              userId: user.id,\n              memberIds: selectedContact.memberIds,\n              members: selectedContact.members\n            })\n            throw new Error(\"Bạn không phải là thành viên của nhóm này\")\n          }\n\n          try {\n            response = await apiCall(\n              \"post\", \n              `/api/groups/${groupId}/messages`, \n              { content: messageToSend }, \n              token\n            )\n            \n            console.log(\"Group message API response:\", response)\n            \n            if (!response) {\n              throw new Error(\"No response from server\")\n            }\n\n            if (!response.messageData) {\n              console.error(\"Invalid response structure:\", response)\n              throw new Error(\"Invalid response structure from server\")\n            }\n            \n            const messageData = response.messageData\n            messageDataForSocket = {\n              messageId: messageData.messageId,\n              groupId: groupId,\n              senderId: user.id,\n              senderName: user.name,\n              content: messageToSend,\n              type: \"text\",\n              createdAt: messageData.createdAt || new Date().toISOString(),\n            }\n\n            console.log(\"Emitting socket event with data:\", messageDataForSocket)\n            socket.emit(\"group_message\", messageDataForSocket)\n\n            // Update optimistic message with real ID and remove sending state\n            setMessages((prev) =>\n              prev.map((msg) =>\n                msg.id === tempMessageId\n                  ? {\n                      ...msg,\n                      id: messageData.messageId,\n                      isSending: false,\n                      time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    }\n                  : msg\n              )\n            )\n          } catch (error) {\n            console.error(\"Error details:\", {\n              error,\n              groupId,\n              selectedContact,\n              user: { id: user.id, name: user.name }\n            })\n            \n            if (error.response?.status === 404) {\n              throw new Error(\"Không tìm thấy nhóm chat\")\n            } else if (error.response?.status === 403) {\n              throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\")\n            } else {\n              throw error\n            }\n          }\n        } else {\n          // Handle individual contact message sending\n          const conversationId = selectedContact.conversationId\n          if (!conversationId) {\n            throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\")\n          }\n          response = await apiCall(\n            \"post\",\n            \"/api/messages/send/text\",\n            { \n              conversationId: conversationId, \n              content: messageToSend,\n              tempMessageId: tempMessageId // Add tempMessageId to help match response\n            },\n            token\n          )\n          messageDataForSocket = {\n            messageId: response.messageData?.messageId || response.messageId,\n            tempMessageId: tempMessageId, // Include tempMessageId in socket event\n            conversationId: conversationId,\n            senderId: user.id,\n            senderName: user.name,\n            receiverId: selectedContact.id,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: response.messageData?.createdAt || new Date().toISOString(),\n            time: messageTime // Include original time for matching\n          }\n          socket.emit(\"new_message\", messageDataForSocket)\n        }\n      } catch (error) {\n        console.error(\"Error sending message:\", error)\n        showError(\"Không thể gửi tin nhắn: \" + error.message)\n        // Remove or mark optimistic message as failed\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n      }\n    },\n    [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(\n    async (file, fileType = \"file\") => {\n      // fileType can be 'file', 'image', 'video'\n      if (!file || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n      const maxSize = 50 * 1024 * 1024 // 50MB\n      if (file.size > maxSize) {\n        showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`)\n        return\n      }\n      if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n        showError(\"Chỉ chấp nhận file hình ảnh.\")\n        return\n      }\n      if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n        showError(\"Chỉ chấp nhận file video.\")\n        return\n      }\n\n      // Video duration check\n      let videoDuration = null\n      if (fileType === \"video\") {\n        try {\n          const duration = await getVideoDuration(file)\n          if (duration > 90) {\n            showError(\"Video không được dài quá 90 giây.\")\n            return\n          }\n          videoDuration = Math.round(duration)\n        } catch (err) {\n          showError(\"Không thể đọc thông tin video.\")\n          return\n        }\n      }\n\n      const tempMessageId = `temp-file-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      const tempUrl = URL.createObjectURL(file) // For optimistic UI\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: fileType === \"text\" ? file.name : tempUrl, // Use tempUrl for image/video\n        time: messageTime,\n        senderId: user.id,\n        isSending: true,\n        isFile: fileType === \"file\",\n        isImage: fileType === \"image\",\n        isVideo: fileType === \"video\",\n        fileName: file.name,\n        fileType: file.type,\n        duration: videoDuration,\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      scrollToBottom()\n\n      const formData = new FormData()\n      let apiUrl = \"\"\n      let apiKey = \"\" // Key for the file in FormData\n\n      if (selectedContact.type === \"group\") {\n        const groupId = selectedContact.groupId\n        formData.append(\"groupId\", groupId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = `/api/groups/${groupId}/images`\n            apiKey = \"image\" // Match backend key\n            break\n          case \"video\":\n            apiUrl = `/api/groups/${groupId}/videos`\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = `/api/groups/${groupId}/files`\n            apiKey = \"file\"\n            break\n        }\n      } else {\n        const conversationId = selectedContact.conversationId\n        if (!conversationId) {\n          showError(\"Không tìm thấy cuộc trò chuyện để gửi file\")\n          URL.revokeObjectURL(tempUrl)\n          setMessages((prev) => prev.filter((msg) => msg.id !== tempMessageId)) // Remove optimistic msg\n          return\n        }\n        formData.append(\"conversationId\", conversationId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = \"/api/messages/send/image\"\n            apiKey = \"images\" // Match backend key (plural for this endpoint)\n            break\n          case \"video\":\n            apiUrl = \"/api/messages/send/video\"\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = \"/api/messages/send/file\"\n            apiKey = \"file\"\n            break\n        }\n      }\n\n      formData.append(apiKey, file)\n\n      try {\n        const response = await apiCall(\"post\", apiUrl, formData, token)\n        const messageData = response.messageData || response // Adjust based on API response structure\n        const attachment = messageData.attachments?.[0]\n\n        if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n          throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\")\n        }\n\n        // Update optimistic message\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === tempMessageId\n              ? {\n                  ...msg,\n                  id: messageData.messageId,\n                  content: attachment.url, // Use final URL\n                  fileUrl: fileType === \"file\" ? attachment.url : null,\n                  isSending: false,\n                  time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                  }),\n                }\n              : msg,\n          ),\n        )\n\n        // Update media/documents list\n        const newItem = {\n          id: messageData.messageId,\n          type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n          url: attachment.url,\n          name: attachment.name || file.name,\n          date: new Date(messageData.createdAt).toLocaleDateString(),\n          size: attachment.size || file.size,\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        if (fileType === \"image\" || fileType === \"video\") {\n          setMediaFiles((prev) => [newItem, ...prev]) // Add to beginning (newest)\n        } else {\n          setDocuments((prev) => [newItem, ...prev])\n        }\n\n        // Emit socket event\n        const socketEventData = {\n          messageId: messageData.messageId,\n          conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n          groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n          type: fileType, // 'file', 'image', 'video'\n          content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null, // Content might be null for media\n          attachments: messageData.attachments,\n          createdAt: messageData.createdAt || new Date().toISOString(),\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\"\n        socket.emit(socketEventName, socketEventData)\n\n        URL.revokeObjectURL(tempUrl) // Clean up temp URL\n      } catch (error) {\n        console.error(`Error sending ${fileType}:`, error)\n        showError(`Không thể gửi ${fileType}: ${error.message}`)\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n        URL.revokeObjectURL(tempUrl)\n      }\n    },\n    [isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  const getVideoDuration = (file) => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\")\n      video.preload = \"metadata\"\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src)\n        resolve(video.duration)\n      }\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src)\n        reject(new Error(\"Không thể tải metadata video\"))\n      }\n      video.src = URL.createObjectURL(file)\n    })\n  }\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback((emoji) => {\n    setNewMessage((prev) => prev + emoji)\n    setShowEmojiPicker(false)\n  }, [])\n\n  const handleMessageAction = useCallback(\n    async (messageId, action) => {\n      if (action === \"delete\") {\n        const token = localStorage.getItem(\"token\")\n        if (!token || !selectedContact) return\n\n        // Optimistic UI update\n        const originalMessages = [...messages]\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === messageId ? { ...msg, content: \"Đang xóa...\", isUnsent: true, isDeleting: true } : msg,\n          ),\n        )\n\n        try {\n          if (selectedContact.type === \"group\") {\n            await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token)\n          } else {\n            await apiCall(\"delete\", `/api/messages/${messageId}`, null, token)\n          }\n\n          // Confirm deletion in UI\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === messageId ? { ...msg, content: \"Tin nhắn đã bị xóa\", isDeleting: false } : msg,\n            ),\n          )\n\n          // Remove from media/documents lists\n          setMediaFiles((prev) => prev.filter((media) => media.id !== messageId))\n          setDocuments((prev) => prev.filter((doc) => doc.id !== messageId))\n\n          // TODO: Emit socket event for deletion if needed by backend/other clients\n        } catch (error) {\n          console.error(\"Error deleting message:\", error)\n          showError(\"Không thể xóa tin nhắn: \" + error.message)\n          // Revert optimistic update on error\n          setMessages(originalMessages)\n        }\n      }\n      // Handle other actions like 'recall' if implemented\n    },\n    [apiCall, selectedContact, showError, messages], // Include messages in dependency array\n  )\n\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true)\n    setShowFiles(false)\n  }, [])\n\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false)\n    setShowFiles(true)\n  }, [])\n\n  const handleTabChange = useCallback((tab) => {\n    setActiveTab(tab)\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchFriendRequests(token)\n      }\n    }\n  }, [fetchFriendRequests]) // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null,\n    })\n    setShowProfileModal(true)\n  }, [user.name, user.avatar]) // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false)\n  }, [])\n\n  const handleAvatarChange = useCallback(\n    async (file) => {\n      // File validation\n      if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n        showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\")\n        return\n      }\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const formData = new FormData()\n      formData.append(\"avatar\", file)\n\n      try {\n        setLoading(true) // Indicate loading\n        const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token)\n        // Update state optimistically/realistically\n        setProfileData((prev) => ({ ...prev, avatarUrl: response.avatarUrl }))\n        setUser((prev) => ({ ...prev, avatar: response.avatarUrl }))\n        // Update localStorage userProfile\n        const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n        userProfile.avatarUrl = response.avatarUrl\n        localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n        showError(\"Cập nhật ảnh đại diện thành công!\")\n      } catch (error) {\n        showError(\"Không thể tải avatar: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    try {\n      setLoading(true)\n      const response = await apiCall(\n        \"put\",\n        \"/api/users/profile\",\n        {\n          fullName: profileData.fullName,\n          // Ensure birthdate is sent correctly or omitted if empty\n          birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n          gender: profileData.gender || undefined, // Send undefined if empty to potentially clear it\n        },\n        token,\n      )\n      // Update user state\n      setUser((prev) => ({\n        ...prev,\n        name: response.fullName || prev.name,\n        // Avatar might not be in this response, keep existing one\n      }))\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      userProfile.fullName = response.fullName\n      userProfile.birthdate = response.birthdate\n      userProfile.gender = response.gender\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n\n      showError(\"Cập nhật hồ sơ thành công!\")\n      handleCloseProfileModal()\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message)\n    } finally {\n      setLoading(false)\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal])\n\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true)\n  }, [])\n\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false)\n    setFriendEmail(\"\") // Reset email field\n  }, [])\n\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\")\n      return\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\")\n      return\n    }\n\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    setLoading(true)\n    try {\n      // Search user first to get ID\n      const searchResult = await apiCall(\n        \"get\",\n        `/api/users/search?query=${encodeURIComponent(friendEmail)}`,\n        null,\n        token,\n      )\n      if (!searchResult?.data?.length) {\n        throw new Error(\"Không tìm thấy người dùng với email này\")\n      }\n      const receiverId = searchResult.data[0].userId\n\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\")\n      }\n\n      // Check if already friends\n      if (contacts.some((c) => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\")\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", { receiverId, message: `Kết bạn từ ${user.name}` }, token)\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`)\n      handleCloseAddFriendModal()\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`)\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`)\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`)\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`)\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false)\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts])\n\n  const handleRespondToFriendRequest = useCallback(\n    async (requestId, action) => {\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const request = friendRequests.find((req) => req.requestId === requestId)\n      if (!request) return\n\n      setLoading(true) // Indicate processing\n      // Optimistically remove from list\n      setFriendRequests((prev) => prev.filter((req) => req.requestId !== requestId))\n\n      try {\n        const response = await apiCall(\"post\", \"/api/friends/requests/respond\", { requestId, action }, token)\n        console.log(\"Friend request response:\", response)\n\n        if (action === \"accept\") {\n          showError(\"Đã chấp nhận lời mời kết bạn\")\n          const senderInfo = request.sender\n          if (!senderInfo || !senderInfo.userId) {\n            throw new Error(\"Thông tin người gửi không hợp lệ\")\n          }\n\n          // Get conversation ID (might be in response or need creation)\n          let conversationId = response.conversation?.conversationId\n          if (!conversationId) {\n            console.log(\"No conversationId in response, creating/getting...\")\n            conversationId = await createOrGetConversation(senderInfo.userId, token)\n          }\n\n          if (!conversationId) {\n            throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\")\n          }\n\n          // Create new contact object\n          const newContact = {\n            id: senderInfo.userId,\n            name: senderInfo.fullName || senderInfo.email?.split(\"@\")[0] || \"Unknown\",\n            avatar: senderInfo.avatarUrl || \"\",\n            type: \"contact\",\n            status: \"Bạn bè\",\n            conversationId: conversationId,\n          }\n\n          addOrUpdateContact(newContact) // Add/update contact list and localStorage\n\n          // Optionally select the new contact immediately\n          // handleContactSelect(newContact);\n\n          // Emit notification to the sender via socket\n          if (socket.connected) {\n            socket.emit(\"friend_request_accepted_notify\", {\n              accepter: { userId: user.id, fullName: user.name, avatarUrl: user.avatar },\n              senderId: senderInfo.userId, // Target the sender\n              conversationId: conversationId,\n            })\n            // Also tell sender to refresh their list\n            socket.emit(\"refresh_contacts_notify\", { targetUserId: senderInfo.userId })\n            console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\")\n          }\n        } else {\n          showError(\"Đã từ chối lời mời kết bạn\")\n          // Optionally notify sender of rejection via socket\n        }\n      } catch (error) {\n        console.error(\"Error responding to friend request:\", error)\n        showError(\"Không thể phản hồi lời mời: \" + error.message)\n        // Revert optimistic removal on error\n        setFriendRequests((prev) => [...prev, request])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user],\n  )\n\n  const handleRemoveFriend = useCallback(\n    async (friendId) => {\n      if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      console.log(`Attempting to remove friend with ID: ${friendId}`)\n      setLoading(true)\n\n      // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n      const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\")\n      if (!contactToRemove) {\n        showError(\"Không tìm thấy người dùng trong danh sách bạn bè\")\n        setLoading(false)\n        return\n      }\n\n      // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n      const currentContacts = [...contacts]\n\n      try {\n        // Cập nhật UI trước khi gọi API (optimistic update)\n        setContacts((prev) => prev.filter((contact) => contact.id !== friendId || contact.type !== \"contact\"))\n\n        // Cập nhật localStorage\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const updatedContacts = savedContacts.filter((c) => c.id !== friendId || c.type !== \"contact\")\n          localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts))\n        } catch (e) {\n          console.error(\"Error updating localStorage after friend removal\", e)\n        }\n\n        // Bỏ chọn nếu đang được chọn\n        if (selectedContact?.id === friendId && selectedContact?.type === \"contact\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        // Gọi API để xóa bạn bè\n        try {\n          console.log(`Calling API to remove friend: ${friendId}`)\n          const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token)\n          console.log(\"Friend removal API response:\", response)\n\n          showError(\"Đã xóa bạn bè thành công\")\n\n          // Thông báo cho người bạn bị xóa qua socket\n          if (socket && socket.connected) {\n            socket.emit(\"friend_removed_notify\", { removerId: user.id, removedUserId: friendId })\n            console.log(\"Emitted friend_removed_notify\")\n\n            // Thông báo cập nhật danh sách bạn bè\n            socket.emit(\"friend_list_updated\")\n          }\n\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token)\n        } catch (apiError) {\n          console.error(\"API error removing friend:\", apiError)\n\n          // Kiểm tra lỗi cụ thể\n          if (apiError.response && apiError.response.status === 404) {\n            // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n            showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\")\n            // Cập nhật lại danh sách bạn bè từ server\n            fetchContactsAndGroups(token)\n          } else {\n            // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n            showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"))\n            // Khôi phục lại danh sách bạn bè\n            setContacts(currentContacts)\n\n            // Khôi phục localStorage\n            try {\n              localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n            } catch (e) {\n              console.error(\"Error restoring localStorage\", e)\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error in handleRemoveFriend:\", error)\n        showError(\"Không thể xóa bạn bè: \" + error.message)\n\n        // Khôi phục lại danh sách bạn bè\n        setContacts(currentContacts)\n\n        // Khôi phục localStorage\n        try {\n          localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n        } catch (e) {\n          console.error(\"Error restoring localStorage\", e)\n        }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups],\n  )\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true)\n  }, [])\n\n  const handleGroupCreated = useCallback(\n    (newGroupData) => {\n      console.log(\"Group created data:\", newGroupData)\n      const groupObject = {\n        groupId: newGroupData.groupId,\n        id: newGroupData.groupId, // Add id for consistency\n        name: newGroupData.name,\n        avatar: newGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: newGroupData.adminId,\n        memberCount: newGroupData.members?.length || 1, // At least admin is a member\n        conversationId: newGroupData.conversationId || newGroupData.groupId,\n        createdAt: newGroupData.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      setShowCreateGroupModal(false)\n      showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`)\n      // Automatically select the new group\n      handleContactSelect(groupObject)\n    },\n    [addOrUpdateGroup, showError, handleContactSelect],\n  )\n\n  const handleGroupInfo = useCallback(\n    (group) => {\n      // Fetch full group details if necessary before showing modal\n      setSelectedGroup(group) // Pass the basic group info for now\n      setShowGroupInfoModal(true)\n      // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n    },\n    [], // No dependencies needed to just show the modal\n  )\n\n  const handleGroupUpdated = useCallback(\n    (updatedGroupData) => {\n      console.log(\"Group updated data:\", updatedGroupData)\n      // Ensure the data structure matches what addOrUpdateGroup expects\n      const groupObject = {\n        groupId: updatedGroupData.groupId,\n        id: updatedGroupData.groupId,\n        name: updatedGroupData.name,\n        avatar: updatedGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: updatedGroupData.adminId,\n        memberCount: updatedGroupData.memberCount || updatedGroupData.members?.length || 0,\n        conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n        createdAt: updatedGroupData.createdAt,\n        // Include other relevant fields if needed\n      }\n      addOrUpdateGroup(groupObject)\n      // Update selected contact if it's the one being edited\n      if (selectedContact?.id === groupObject.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n      setShowGroupInfoModal(false) // Close modal on success\n      showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`)\n    },\n    [addOrUpdateGroup, selectedContact, showError],\n  )\n\n  const handleLeaveGroup = useCallback(\n    async (groupId) => {\n      console.log(\"Leaving group:\", groupId)\n\n      if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      setLoading(true)\n\n      try {\n        // Gọi API để rời nhóm\n        const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token)\n        console.log(\"Leave group API response:\", response)\n\n        // Cập nhật UI sau khi API thành công\n        setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n\n        // Cập nhật localStorage\n        try {\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n          const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n        } catch (e) {\n          console.error(\"Error updating localStorage after leaving group\", e)\n        }\n\n        // Bỏ chọn nhóm nếu đang được chọn\n        if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        setShowGroupInfoModal(false) // Đóng modal\n        showError(\"Bạn đã rời khỏi nhóm thành công\")\n\n        // Thông báo qua socket nếu cần\n        if (socket.connected) {\n          socket.emit(\"left_group\", { groupId })\n        }\n      } catch (error) {\n        console.error(\"Error leaving group:\", error)\n        showError(\"Không thể rời khỏi nhóm: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [selectedContact, showError, apiCall],\n  )\n\n  const handleDeleteGroup = useCallback(\n    (groupId) => {\n      console.log(\"Deleting group:\", groupId)\n      setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch (e) {\n        console.error(\"Error updating localStorage after deleting group\", e)\n      }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n      setShowGroupInfoModal(false) // Close modal\n      showError(\"Đã xóa nhóm thành công\")\n      // API call to delete group should be handled within GroupInfoModal or here before state update\n    },\n    [selectedContact, showError],\n  )\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) {\n      navigate(\"/login\")\n      return\n    }\n\n    let isMounted = true // Flag to prevent state updates on unmounted component\n    let socketInitialized = false\n\n    const initializeApp = async () => {\n      try {\n        setLoading(true)\n        const userProfile = await fetchUserProfile(token)\n        if (!userProfile || !isMounted) return // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token)\n        if (!isMounted) return\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token)\n        if (!isMounted) return\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\")\n          \n          // Set socket auth and query params\n          socket.auth = { token }\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now(),\n          }\n\n          // Connect the socket\n          socket.connect()\n          socketInitialized = true\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error)\n      } finally {\n        if (isMounted) {\n          setLoading(false)\n        }\n      }\n    }\n\n    initializeApp()\n\n    // Cleanup function\n    return () => {\n      isMounted = false\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\")\n      socket.off(\"reconnect\")\n      socket.off(\"friend_request\")\n      socket.off(\"new_message\")\n      socket.off(\"receive_message\")\n      socket.off(\"group_message\")\n      socket.off(\"friend_request_accepted\")\n      socket.off(\"friend_removed\")\n      socket.off(\"refresh_contacts\")\n      socket.off(\"notification\")\n      socket.off(\"group_created\")\n      socket.off(\"group_updated\")\n      socket.off(\"group_deleted\")\n      socket.off(\"member_added\")\n      socket.off(\"member_removed\")\n    }\n  }, [navigate]) // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback((data) => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || (!data.messageId && !data.id)) {\n      console.error(\"Invalid message data received:\", data)\n      return\n    }\n\n    const messageTime = data.createdAt\n      ? new Date(data.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      : new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString()\n\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact?.type,\n      selectedContactGroupId: selectedContact?.groupId,\n      selectedContactConversationId: selectedContact?.conversationId\n    });\n\n    const isCurrentChat =\n      (selectedContact?.type === \"group\" && selectedContact.groupId === data.groupId) ||\n      (selectedContact?.type === \"contact\" && selectedContact.conversationId === data.conversationId)\n\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content:\n        data.isRecalled || data.isDeleted\n          ? \"Tin nhắn đã bị thu hồi/xóa\"\n          : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\"\n            ? data.content\n            : data.attachments?.[0]?.url || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: data.type === \"image\" || data.type === \"imageGroup\",\n      isVideo: data.type === \"video\",\n      isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: data.type === \"file\" ? data.attachments?.[0]?.url : null,\n      fileName: data.type === \"file\" ? data.attachments?.[0]?.name : null,\n      fileType: data.type === \"file\" ? data.attachments?.[0]?.type : null,\n      duration: data.type === \"video\" ? data.attachments?.[0]?.duration || data.duration : null,\n      messageDate: messageDate,\n    }\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || []\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev\n        return { ...prev, [data.conversationId]: [...prevList, newMessage] }\n      })\n    }\n\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id)\n        if (exists) return prev\n        return [...prev, newMessage]\n      })\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n            duration: newMessage.duration,\n          },\n          ...prev, // Add to beginning\n        ])\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n          },\n          ...prev, // Add to beginning\n        ])\n      }\n    } else {\n      // Notification for message in other chat\n      let senderName = \"Người dùng\"\n      let contactId = data.senderId // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find((g) => g.groupId === data.groupId)\n        senderName = `${data.senderName || \"Ai đó\"} (${group?.name || \"Nhóm\"})`\n      } else {\n        const contact = contacts.find((c) => c.id === data.senderId) // Tìm contact dựa trên senderId\n        senderName = contact?.name || data.senderName || \"Ai đó\"\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n\n      const preview =\n        data.type === \"text\"\n          ? data.content?.substring(0, 30) + (data.content?.length > 30 ? \"...\" : \"\")\n          : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`)\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview, // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      const contactName = data.senderName || \"Người dùng\"\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: contacts.find((c) => c.id === data.senderId)?.avatar || groups.find(g => g.groupId === data.groupId)?.avatar || \"/favicon.ico\", // Optional icon\n      })\n    }\n  }, [user.id, contacts, groups, selectedContact, showError])\n\n  const handleFriendRequest = useCallback((data) => {\n    if (!data || !data.requestId || !data.sender) return\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab])\n\n  const handleFriendRequestAccepted = useCallback((data) => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\")\n      return\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user])\n\n  const handleFriendRemoved = useCallback((data) => {\n    if (!data || !data.removerId) return\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError])\n\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\")\n    if (token) {\n      fetchContactsAndGroups(token)\n    }\n  }, [fetchContactsAndGroups])\n\n  const handleSocketGroupCreated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_created event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.members?.length || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`)\n  }, [addOrUpdateGroup, showError])\n\n  const handleSocketGroupUpdated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_updated event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`)\n  }, [addOrUpdateGroup, selectedContact, showError])\n\n  const handleGroupDeleted = useCallback((data) => {\n    if (!data?.groupId) return\n    console.log(\"Received group_deleted event:\", data.groupId)\n    const groupName = groups.find(g => g.groupId === data.groupId)?.name || \"Một nhóm\"\n    setGroups((prev) => prev.filter((group) => group.groupId !== data.groupId))\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n      const updatedGroups = savedGroups.filter((g) => g.groupId !== data.groupId)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n    } catch (e) { console.error(\"Error updating localStorage after group delete\", e) }\n\n    if (selectedContact?.id === data.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(null)\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`)\n  }, [groups, selectedContact, showError])\n\n  const handleMemberAdded = useCallback((data) => {\n    if (!data?.group || !data?.member || !data?.addedBy) return\n    console.log(\"Received member_added event:\", data)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`)\n    }\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleMemberRemoved = useCallback((data) => {\n    if (!data?.group || !data?.memberId || !data?.removedBy) return\n    console.log(\"Received member_removed event:\", data)\n    const group = data.group\n    const groupId = group.groupId\n\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`)\n      setGroups((prev) => prev.filter((g) => g.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch(e) { console.error(\"Error updating localStorage after being removed from group\", e) }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n    } else {\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || group.members?.length || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      const memberName = data.member?.fullName || \"một thành viên\"\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`)\n      if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleNotification = useCallback((data) => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data)\n      return\n    }\n    if (data.type === \"success\") {\n      showError(data.message)\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\")\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\")\n    } else {\n      showError(data.message)\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchContactsAndGroups(token)\n      }\n    }\n  }, [showError, fetchContactsAndGroups])\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true\n\n    const handleConnect = () => {\n      if (!isMounted) return\n      console.log(\"Socket re-connected inside hook.\")\n      setIsConnected(true)\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId)\n      }\n    }\n\n    // Add handler for message_sent event\n    const handleMessageSent = (data) => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data)\n        return\n      }\n      console.log(\"Received message_sent_success event:\", data)\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n          // Match by tempMessageId if available\n          (data.tempMessageId && msg.id === data.tempMessageId) ||\n          // Or match by conversationId and content if tempMessageId not available\n          (data.conversationId && msg.conversationId === data.conversationId && \n           msg.content === data.content)\n        )) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          })\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          }\n        }\n        return msg\n      }))\n    }\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect)\n    socket.on(\"message_sent_success\", handleMessageSent) // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage)\n    socket.on(\"receive_message\", handleNewMessage)\n    socket.on(\"group_message\", handleNewMessage)\n    socket.on(\"friend_request\", handleFriendRequest)\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted)\n    socket.on(\"friend_removed\", handleFriendRemoved)\n    socket.on(\"refresh_contacts\", handleRefreshContacts)\n    socket.on(\"notification\", handleNotification)\n    socket.on(\"group_created\", handleSocketGroupCreated)\n    socket.on(\"group_updated\", handleSocketGroupUpdated)\n    socket.on(\"group_deleted\", handleGroupDeleted)\n    socket.on(\"member_added\", handleMemberAdded)\n    socket.on(\"member_removed\", handleMemberRemoved)\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false\n      socket.off(\"connect\", handleConnect)\n      socket.off(\"message_sent_success\", handleMessageSent) // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage)\n      socket.off(\"receive_message\", handleNewMessage)\n      socket.off(\"group_message\", handleNewMessage)\n      socket.off(\"friend_request\", handleFriendRequest)\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted)\n      socket.off(\"friend_removed\", handleFriendRemoved)\n      socket.off(\"refresh_contacts\", handleRefreshContacts)\n      socket.off(\"notification\", handleNotification)\n      socket.off(\"group_created\", handleSocketGroupCreated)\n      socket.off(\"group_updated\", handleSocketGroupUpdated)\n      socket.off(\"group_deleted\", handleGroupDeleted)\n      socket.off(\"member_added\", handleMemberAdded)\n      socket.off(\"member_removed\", handleMemberRemoved)\n    }\n  }, [\n    handleNewMessage,\n    handleFriendRequest,\n    handleFriendRequestAccepted,\n    handleFriendRemoved,\n    handleRefreshContacts,\n    handleNotification,\n    handleSocketGroupCreated,\n    handleSocketGroupUpdated,\n    handleGroupDeleted,\n    handleMemberAdded,\n    handleMemberRemoved,\n    selectedContact // Add selectedContact as dependency\n  ])\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages]) // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n        messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }, 100);\n  }\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(\n    (contact) => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n  const filteredGroups = groups.filter(\n    (group) => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"] // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts, // Return full contacts list if needed elsewhere\n    groups,   // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab, // Needed for friend request notification\n    setShowProfileModal, // Needed for closing modal from component\n    setProfileData, // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal, // Needed for closing modal from component\n    setFriendEmail, // Needed for form input\n    // setError, // Internal state\n    setShowToast, // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal, // Needed for closing modal from component\n    setShowGroupInfoModal, // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile, // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError, // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"), // Pass token for Modals\n  }\n}\n\nexport default useChat\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}