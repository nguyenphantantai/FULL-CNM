{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport axios from \"axios\";\nimport { io } from \"socket.io-client\";\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\";\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false,\n  // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false,\n  // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now()\n  }\n});\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id);\n});\nsocket.on(\"connect_error\", err => {\n  console.error(\"Socket connection error:\", err);\n});\nsocket.on(\"disconnect\", reason => {\n  console.log(\"Socket disconnected:\", reason);\n});\nsocket.on(\"error\", err => {\n  console.error(\"Socket error:\", err);\n});\nsocket.on(\"reconnect_error\", err => {\n  console.error(\"Socket reconnection error:\", err);\n});\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error;\n  console.error = (...args) => {\n    if (args[0] && typeof args[0] === \"string\" && (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))) {\n      return;\n    }\n    originalConsoleError.apply(console, args);\n  };\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  _s();\n  const navigate = useNavigate();\n\n  // State Management\n  const [user, setUser] = useState({\n    id: \"\",\n    name: \"User\",\n    avatar: \"\"\n  });\n  const [contacts, setContacts] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [selectedContact, setSelectedContact] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(socket.connected); // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [mediaFiles, setMediaFiles] = useState([]);\n  const [documents, setDocuments] = useState([]);\n  const [showMedia, setShowMedia] = useState(true);\n  const [showFiles, setShowFiles] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"chat\");\n  const [showProfileModal, setShowProfileModal] = useState(false);\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null\n  });\n  const [loading, setLoading] = useState(false);\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false);\n  const [friendEmail, setFriendEmail] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [showToast, setShowToast] = useState(false);\n  const [friendRequests, setFriendRequests] = useState([]);\n  const [recoveredContacts, setRecoveredContacts] = useState([]); // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({});\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageInputRef = useRef(null);\n  const videoInputRef = useRef(null);\n\n  // --- Utility Functions ---\n\n  const showError = useCallback(message => {\n    console.log(\"Showing Toast:\", message);\n    setError(message);\n    setShowToast(true);\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, []);\n  const apiCall = useCallback(async (method, url, data = null, token) => {\n    try {\n      console.log(`API Call: ${method.toUpperCase()} ${url}`);\n      if (data) {\n        console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data);\n      }\n      const config = {\n        method,\n        url: `${API_BASE_URL}${url}`,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n          \"If-None-Match\": \"\" // Prevent 304 responses\n        },\n        data\n      };\n      if (!(data instanceof FormData)) {\n        config.headers[\"Content-Type\"] = \"application/json\";\n      }\n      console.log(\"Using config:\", {\n        method: config.method,\n        url: config.url,\n        headers: {\n          ...config.headers,\n          Authorization: \"Bearer [HIDDEN]\"\n        }\n      });\n      const response = await axios(config);\n      console.log(`API Response ${url}:`, response.status, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error(`API Error ${url}:`, error);\n      if (error.response) {\n        console.error(\"Response status:\", error.response.status);\n        console.error(\"Response data:\", error.response.data);\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"userProfile\"); // Clear profile too\n        navigate(\"/login\");\n        // Use showError for consistency\n        showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\");\n        throw new Error(\"Phiên đăng nhập hết hạn.\"); // Throw to stop further execution\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || \"Đã xảy ra lỗi không xác định\";\n      // Don't automatically show toast here, let the calling function decide\n      // showError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [navigate, showError]); // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback(newContact => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact);\n      return;\n    }\n    console.log(\"Adding or updating contact:\", newContact);\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\");\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : [];\n      contactsArray = contactsArray.filter(c => c.id !== newContact.id);\n      contactsArray.push(newContact);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray));\n      console.log(\"Saved contact to localStorage:\", newContact.id);\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError);\n    }\n    setContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n  }, []);\n  const addOrUpdateGroup = useCallback(newGroup => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup);\n      return;\n    }\n    console.log(\"Adding or updating group:\", newGroup);\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\");\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : [];\n      groupsArray = groupsArray.filter(g => g.groupId !== newGroup.groupId);\n      groupsArray.push(newGroup);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray));\n      console.log(\"Saved group to localStorage:\", newGroup.groupId);\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError);\n    }\n    setGroups(prev => {\n      const exists = prev.some(group => group.groupId === newGroup.groupId);\n      if (exists) {\n        return prev.map(group => group.groupId === newGroup.groupId ? {\n          ...group,\n          ...newGroup\n        } : group);\n      }\n      return [...prev, newGroup];\n    });\n  }, []);\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(async token => {\n    try {\n      const response = await apiCall(\"get\", \"/api/users/profile\", null, token);\n      const userData = {\n        id: response.userId,\n        name: response.fullName || \"User\",\n        avatar: response.avatarUrl || \"\"\n      };\n      setUser(userData);\n      setProfileData({\n        fullName: response.fullName || \"\",\n        birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n        gender: response.gender || \"\",\n        avatarUrl: response.avatarUrl || null\n      });\n      // Save profile to localStorage after fetching\n      localStorage.setItem(\"userProfile\", JSON.stringify(response));\n      return response; // Return the full profile\n    } catch (error) {\n      console.error(\"Error fetching user profile:\", error);\n      showError(\"Không thể lấy thông tin người dùng: \" + error.message);\n      // No need to navigate here, apiCall handles 401\n      return null;\n    }\n  }, [apiCall, showError]);\n  const fetchMessages = useCallback(async (token, conversationId, isGroup = false) => {\n    if (!token || !conversationId) {\n      console.warn(\"fetchMessages called without token or conversationId\");\n      setMessages([]); // Clear messages if no ID\n      setMediaFiles([]);\n      setDocuments([]);\n      return;\n    }\n    setLoading(true); // Indicate loading messages\n    try {\n      let response;\n      // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n      const endpoint = `/api/messages/conversations/${conversationId}/messages`;\n      console.log(\"Fetching messages from endpoint:\", endpoint);\n      response = await apiCall(\"get\", endpoint, null, token);\n      console.log(\"Messages API response:\", response);\n      const messagesData = Array.isArray(response) ? response : response.data || [];\n      const mappedMessages = messagesData.map((msg, index) => {\n        var _msg$attachments, _msg$attachments$, _msg$attachments2, _msg$attachments$2, _msg$attachments3, _msg$attachments$3, _msg$attachments4, _msg$attachments$4, _msg$attachments5, _msg$attachments$5;\n        return {\n          id: msg.messageId || `temp-${Date.now()}-${index}`,\n          sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n          content: msg.isRecalled || msg.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\" ? msg.content : ((_msg$attachments = msg.attachments) === null || _msg$attachments === void 0 ? void 0 : (_msg$attachments$ = _msg$attachments[0]) === null || _msg$attachments$ === void 0 ? void 0 : _msg$attachments$.url) || msg.content || \"\",\n          // Ensure content exists\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          senderId: msg.senderId,\n          isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n          isVideo: msg.type === \"video\",\n          isFile: msg.type === \"file\",\n          isUnsent: msg.isRecalled || msg.isDeleted,\n          isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n          fileUrl: msg.type === \"file\" && ((_msg$attachments2 = msg.attachments) === null || _msg$attachments2 === void 0 ? void 0 : _msg$attachments2.length) > 0 ? (_msg$attachments$2 = msg.attachments[0]) === null || _msg$attachments$2 === void 0 ? void 0 : _msg$attachments$2.url : null,\n          fileName: msg.type === \"file\" && ((_msg$attachments3 = msg.attachments) === null || _msg$attachments3 === void 0 ? void 0 : _msg$attachments3.length) > 0 ? (_msg$attachments$3 = msg.attachments[0]) === null || _msg$attachments$3 === void 0 ? void 0 : _msg$attachments$3.name : null,\n          fileType: msg.type === \"file\" && ((_msg$attachments4 = msg.attachments) === null || _msg$attachments4 === void 0 ? void 0 : _msg$attachments4.length) > 0 ? (_msg$attachments$4 = msg.attachments[0]) === null || _msg$attachments$4 === void 0 ? void 0 : _msg$attachments$4.type : null,\n          duration: msg.type === \"video\" && ((_msg$attachments5 = msg.attachments) === null || _msg$attachments5 === void 0 ? void 0 : _msg$attachments5.length) > 0 ? (_msg$attachments$5 = msg.attachments[0]) === null || _msg$attachments$5 === void 0 ? void 0 : _msg$attachments$5.duration : null,\n          messageDate: new Date().toLocaleDateString() // Used for media/files list\n        };\n      }).filter(msg => msg.id); // Filter out messages without an ID\n\n      // Add system message if needed\n      if (mappedMessages.length === 0 || !mappedMessages.some(msg => msg.isSystemMessage)) {\n        const systemMessage = isGroup ? \"Chào mừng bạn đến với nhóm chat!\" : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\";\n        mappedMessages.unshift({\n          id: `system-${Date.now()}`,\n          senderId: \"system\",\n          content: systemMessage,\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          isSystemMessage: true\n        });\n      }\n\n      // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n      let mergedMessages = mappedMessages;\n      if (cachedMessages[conversationId]) {\n        const cacheList = cachedMessages[conversationId];\n        console.log('Cache for this conversation:', cacheList);\n        // Lọc ra các tin nhắn cache chưa có trong mappedMessages\n        const newFromCache = cacheList.filter(cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id));\n        mergedMessages = [...mappedMessages, ...newFromCache];\n        // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n        mergedMessages.sort((a, b) => {\n          const aTime = new Date(a.createdAt || a.time || a.messageDate);\n          const bTime = new Date(b.createdAt || b.time || b.messageDate);\n          return aTime - bTime;\n        });\n      }\n      console.log('Merged messages after cache merge:', mergedMessages);\n      setMessages(mergedMessages);\n\n      // Update Media and Documents\n      const media = mappedMessages.filter(msg => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content).map(msg => {\n        var _msg$attachments6, _msg$attachments6$;\n        return {\n          id: msg.id,\n          type: msg.isImage ? \"image\" : \"video\",\n          url: msg.content,\n          name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n          date: msg.messageDate,\n          size: ((_msg$attachments6 = msg.attachments) === null || _msg$attachments6 === void 0 ? void 0 : (_msg$attachments6$ = _msg$attachments6[0]) === null || _msg$attachments6$ === void 0 ? void 0 : _msg$attachments6$.size) || 0,\n          // Might not be available, default to 0\n          duration: msg.duration\n        };\n      });\n      setMediaFiles(media.reverse()); // Show newest first\n\n      const files = mappedMessages.filter(msg => msg.isFile && !msg.isUnsent && msg.fileUrl).map(msg => {\n        var _msg$fileName, _msg$attachments7, _msg$attachments7$;\n        return {\n          id: msg.id,\n          type: ((_msg$fileName = msg.fileName) === null || _msg$fileName === void 0 ? void 0 : _msg$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n          url: msg.fileUrl,\n          name: msg.fileName,\n          date: msg.messageDate,\n          size: ((_msg$attachments7 = msg.attachments) === null || _msg$attachments7 === void 0 ? void 0 : (_msg$attachments7$ = _msg$attachments7[0]) === null || _msg$attachments7$ === void 0 ? void 0 : _msg$attachments7$.size) || 0\n        };\n      });\n      setDocuments(files.reverse()); // Show newest first\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      showError(\"Không thể tải tin nhắn: \" + error.message);\n      setMessages([]); // Clear messages on error\n      setMediaFiles([]);\n      setDocuments([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id to compare sender\n  );\n  const fetchContactsAndGroups = useCallback(async token => {\n    if (!token) return {\n      contacts: [],\n      groups: []\n    };\n    setLoading(true);\n    let fetchedContacts = [];\n    let fetchedGroups = [];\n    try {\n      // Fetch Friends (Contacts) from server first\n      console.log(\"Fetching friends from server...\");\n      const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token);\n      console.log(\"Friends API response:\", friendsResponse);\n\n      // Lọc ra những người bạn đã được xác nhận\n      // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n      const confirmedFriends = (friendsResponse === null || friendsResponse === void 0 ? void 0 : friendsResponse.friends) || [];\n      console.log(\"Confirmed friends:\", confirmedFriends);\n\n      // Kiểm tra xem danh sách bạn bè có hợp lệ không\n      const validFriends = confirmedFriends.filter(friend => friend && friend.userId && friend.friendshipId);\n      if (validFriends.length !== confirmedFriends.length) {\n        console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`);\n      }\n      const mappedFriends = validFriends.map(friend => {\n        var _friend$email;\n        return {\n          id: friend.userId,\n          name: friend.fullName || ((_friend$email = friend.email) === null || _friend$email === void 0 ? void 0 : _friend$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          // Trạng thái mặc định\n          friendshipId: friend.friendshipId,\n          // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null // Will be populated later\n        };\n      });\n\n      // Fetch Conversations to get conversation IDs\n      console.log(\"Fetching conversations...\");\n      const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token);\n      const conversationsMap = new Map();\n      if (convResponse && Array.isArray(convResponse)) {\n        convResponse.forEach(conv => {\n          if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n            const otherUserId = conv.participants.find(id => id !== user.id);\n            if (otherUserId) {\n              conversationsMap.set(otherUserId, conv.conversationId);\n            }\n          }\n        });\n      }\n\n      // Update conversationId for mapped friends\n      mappedFriends.forEach(friend => {\n        if (conversationsMap.has(friend.id)) {\n          friend.conversationId = conversationsMap.get(friend.id);\n        }\n      });\n\n      // Merge with existing contacts to preserve any additional data\n      const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n\n      // Create a map of existing contacts for quick lookup\n      const existingContactsMap = new Map();\n      savedContacts.forEach(contact => {\n        if (contact && contact.id) {\n          existingContactsMap.set(contact.id, contact);\n        }\n      });\n\n      // Merge server data with existing data, prioritizing server data\n      fetchedContacts = mappedFriends.map(friend => {\n        const existingContact = existingContactsMap.get(friend.id);\n        if (existingContact) {\n          // Preserve conversationId if it exists in saved contact but not in server data\n          if (!friend.conversationId && existingContact.conversationId) {\n            friend.conversationId = existingContact.conversationId;\n          }\n          return {\n            ...existingContact,\n            ...friend\n          };\n        }\n        return friend;\n      });\n\n      // Update state and localStorage\n      setContacts(fetchedContacts);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts));\n      console.log(\"Updated contacts from API:\", fetchedContacts.length);\n\n      // Fetch Groups\n      console.log(\"Fetching groups...\");\n      const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token);\n      console.log(\"Groups API response:\", groupsResponse);\n      if (groupsResponse && groupsResponse.groups) {\n        // Lọc các nhóm mà người dùng là thành viên\n        const userGroups = groupsResponse.groups.filter(group => group.members && group.members.some(member => member.userId === user.id));\n        console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`);\n        fetchedGroups = userGroups.map(group => {\n          var _group$members, _group$members2;\n          return {\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [],\n            // Lưu toàn bộ thông tin thành viên\n            memberIds: ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.map(member => member.userId)) || [],\n            // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || ((_group$members2 = group.members) === null || _group$members2 === void 0 ? void 0 : _group$members2.length) || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt\n          };\n        });\n        setGroups(fetchedGroups);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups));\n        console.log(\"Updated groups from API:\", fetchedGroups.length);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } catch (error) {\n      console.error(\"Error fetching contacts/groups:\", error);\n      showError(\"Không thể tải danh bạ/nhóm: \" + error.message);\n\n      // Fallback to localStorage only if server fetch fails\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        if (savedContacts.length > 0) {\n          console.log(\"Falling back to contacts from localStorage\");\n          setContacts(savedContacts);\n          fetchedContacts = savedContacts;\n        }\n        if (savedGroups.length > 0) {\n          console.log(\"Falling back to groups from localStorage\");\n          setGroups(savedGroups);\n          fetchedGroups = savedGroups;\n        }\n      } catch (e) {\n        console.error(\"Error reading contacts/groups from localStorage\", e);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id for conversation mapping\n  );\n  const fetchFriendRequests = useCallback(async token => {\n    if (!token) return;\n    // No need for setLoading(true) here unless it's a primary action\n    try {\n      const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token);\n      setFriendRequests(response.data || []);\n    } catch (error) {\n      console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error);\n      // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n    }\n  }, [apiCall]);\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(async (otherUserId, token) => {\n    console.log(`Creating/getting conversation with user: ${otherUserId}`);\n    if (!token || !otherUserId) {\n      throw new Error(\"Token or otherUserId missing for createOrGetConversation\");\n    }\n    try {\n      var _response$conversatio;\n      const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token);\n      if (response !== null && response !== void 0 && (_response$conversatio = response.conversation) !== null && _response$conversatio !== void 0 && _response$conversatio.conversationId) {\n        console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId);\n        return response.conversation.conversationId;\n      } else {\n        throw new Error(\"Invalid response structure from conversation API\");\n      }\n    } catch (error) {\n      console.error(\"Error in createOrGetConversation:\", error);\n      if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n        throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\");\n      }\n      throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`); // Rethrow with context\n    }\n  }, [apiCall]);\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(async contactOrGroup => {\n    if (!contactOrGroup || contactOrGroup.id === (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id)) {\n      console.log(\"Selection unchanged or invalid.\");\n      return; // Avoid re-selecting the same contact/group\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      navigate(\"/login\");\n      return;\n    }\n    console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id);\n\n    // Leave previous room\n    if (selectedContact) {\n      const roomToLeave = selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId;\n      if (roomToLeave) {\n        const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\";\n        socket.emit(eventName, roomToLeave);\n        console.log(`Left ${selectedContact.type} room:`, roomToLeave);\n      }\n    }\n\n    // Clear previous state\n    setMessages([]);\n    setMediaFiles([]);\n    setDocuments([]);\n    setSelectedContact(contactOrGroup); // Set selected contact immediately for UI update\n\n    try {\n      setLoading(true); // Show loading for message fetch\n\n      if (contactOrGroup.type === \"group\") {\n        const groupId = contactOrGroup.groupId;\n        // Sử dụng conversationId từ group object\n        const conversationId = contactOrGroup.conversationId || groupId;\n        socket.emit(\"join_group\", groupId);\n        console.log(\"Joined group room:\", groupId);\n        console.log(\"Using conversationId for group:\", conversationId);\n        await fetchMessages(token, conversationId, true);\n      } else {\n        // Handle individual contact\n        let conversationId = contactOrGroup.conversationId;\n\n        // If conversationId is missing, try to fetch/create it\n        if (!conversationId) {\n          console.log(\"Conversation ID missing, attempting to fetch/create...\");\n          try {\n            conversationId = await createOrGetConversation(contactOrGroup.id, token);\n            // Update the contact in the list and the selected contact state\n            const updatedContact = {\n              ...contactOrGroup,\n              conversationId\n            };\n            setSelectedContact(updatedContact); // Update selected state with new ID\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? updatedContact : c));\n            // Optionally save updated contacts list to localStorage\n            const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n            const updatedContactsList = currentContacts.map(c => c.id === contactOrGroup.id ? updatedContact : c);\n            localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList));\n          } catch (error) {\n            showError(error.message); // Show error from createOrGetConversation\n            setSelectedContact(null); // Deselect if conversation fails\n            setLoading(false);\n            return; // Stop execution if conversation fails\n          }\n        }\n        if (conversationId) {\n          socket.emit(\"join_conversation\", conversationId);\n          console.log(\"Joined conversation room:\", conversationId);\n          await fetchMessages(token, conversationId, false);\n\n          // Mark conversation as read with proper request body\n          try {\n            await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, {\n              read: true\n            }, token);\n\n            // Update contacts list to remove unread badge\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? {\n              ...c,\n              unreadCount: 0\n            } : c));\n          } catch (readError) {\n            console.error(\"Error marking conversation as read:\", readError);\n            // Don't show error to user since this is a non-critical operation\n          }\n        } else {\n          // This case should ideally not be reached if createOrGetConversation throws errors\n          showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\");\n          setSelectedContact(null);\n        }\n      }\n    } catch (error) {\n      // Catch errors from fetchMessages or socket emits\n      console.error(\"Error in handleContactSelect processing:\", error);\n      showError(`Lỗi khi chọn liên hệ: ${error.message}`);\n      setSelectedContact(null); // Deselect on error\n    } finally {\n      setLoading(false); // Ensure loading is turned off\n    }\n  }, [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages]);\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(async e => {\n    e.preventDefault();\n    if (!newMessage.trim() || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n    const tempMessageId = `temp-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: newMessage,\n      time: messageTime,\n      senderId: user.id,\n      isSending: true // Indicate sending state\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    const messageToSend = newMessage; // Store message before clearing\n    setNewMessage(\"\"); // Clear input immediately\n    scrollToBottom(); // Scroll after adding optimistic message\n\n    try {\n      let response;\n      let messageDataForSocket;\n      if (selectedContact.type === \"group\") {\n        var _selectedContact$memb;\n        const groupId = selectedContact.groupId;\n        console.log(\"Attempting to send group message:\", {\n          groupId,\n          messageContent: messageToSend,\n          selectedContact\n        });\n        if (!groupId) {\n          throw new Error(\"GroupId is missing\");\n        }\n\n        // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n        if (!((_selectedContact$memb = selectedContact.memberIds) !== null && _selectedContact$memb !== void 0 && _selectedContact$memb.includes(user.id))) {\n          console.error(\"User not in group members:\", {\n            userId: user.id,\n            memberIds: selectedContact.memberIds,\n            members: selectedContact.members\n          });\n          throw new Error(\"Bạn không phải là thành viên của nhóm này\");\n        }\n        try {\n          response = await apiCall(\"post\", `/api/groups/${groupId}/messages`, {\n            content: messageToSend\n          }, token);\n          console.log(\"Group message API response:\", response);\n          if (!response) {\n            throw new Error(\"No response from server\");\n          }\n          if (!response.messageData) {\n            console.error(\"Invalid response structure:\", response);\n            throw new Error(\"Invalid response structure from server\");\n          }\n          const messageData = response.messageData;\n          messageDataForSocket = {\n            messageId: messageData.messageId,\n            groupId: groupId,\n            senderId: user.id,\n            senderName: user.name,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: messageData.createdAt || new Date().toISOString()\n          };\n          console.log(\"Emitting socket event with data:\", messageDataForSocket);\n          socket.emit(\"group_message\", messageDataForSocket);\n\n          // Update optimistic message with real ID and remove sending state\n          setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n            ...msg,\n            id: messageData.messageId,\n            isSending: false,\n            time: new Date(messageData.createdAt).toLocaleTimeString([], {\n              hour: \"2-digit\",\n              minute: \"2-digit\"\n            })\n          } : msg));\n        } catch (error) {\n          var _error$response3, _error$response4;\n          console.error(\"Error details:\", {\n            error,\n            groupId,\n            selectedContact,\n            user: {\n              id: user.id,\n              name: user.name\n            }\n          });\n          if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n            throw new Error(\"Không tìm thấy nhóm chat\");\n          } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403) {\n            throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\");\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        var _response$messageData, _response$messageData2;\n        // Handle individual contact message sending\n        const conversationId = selectedContact.conversationId;\n        if (!conversationId) {\n          throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\");\n        }\n        response = await apiCall(\"post\", \"/api/messages/send/text\", {\n          conversationId: conversationId,\n          content: messageToSend,\n          tempMessageId: tempMessageId // Add tempMessageId to help match response\n        }, token);\n        messageDataForSocket = {\n          messageId: ((_response$messageData = response.messageData) === null || _response$messageData === void 0 ? void 0 : _response$messageData.messageId) || response.messageId,\n          tempMessageId: tempMessageId,\n          // Include tempMessageId in socket event\n          conversationId: conversationId,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.id,\n          content: messageToSend,\n          type: \"text\",\n          createdAt: ((_response$messageData2 = response.messageData) === null || _response$messageData2 === void 0 ? void 0 : _response$messageData2.createdAt) || new Date().toISOString(),\n          time: messageTime // Include original time for matching\n        };\n        socket.emit(\"new_message\", messageDataForSocket);\n      }\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      showError(\"Không thể gửi tin nhắn: \" + error.message);\n      // Remove or mark optimistic message as failed\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n    }\n  }, [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(async (file, fileType = \"file\") => {\n    // fileType can be 'file', 'image', 'video'\n    if (!file || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n\n    // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`);\n      return;\n    }\n    if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n      showError(\"Chỉ chấp nhận file hình ảnh.\");\n      return;\n    }\n    if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n      showError(\"Chỉ chấp nhận file video.\");\n      return;\n    }\n\n    // Video duration check\n    let videoDuration = null;\n    if (fileType === \"video\") {\n      try {\n        const duration = await getVideoDuration(file);\n        if (duration > 90) {\n          showError(\"Video không được dài quá 90 giây.\");\n          return;\n        }\n        videoDuration = Math.round(duration);\n      } catch (err) {\n        showError(\"Không thể đọc thông tin video.\");\n        return;\n      }\n    }\n    const tempMessageId = `temp-file-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const tempUrl = URL.createObjectURL(file); // For optimistic UI\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: fileType === \"text\" ? file.name : tempUrl,\n      // Use tempUrl for image/video\n      time: messageTime,\n      senderId: user.id,\n      isSending: true,\n      isFile: fileType === \"file\",\n      isImage: fileType === \"image\",\n      isVideo: fileType === \"video\",\n      fileName: file.name,\n      fileType: file.type,\n      duration: videoDuration\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    scrollToBottom();\n    const formData = new FormData();\n    let apiUrl = \"\";\n    let apiKey = \"\"; // Key for the file in FormData\n\n    if (selectedContact.type === \"group\") {\n      const groupId = selectedContact.groupId;\n      formData.append(\"groupId\", groupId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = `/api/groups/${groupId}/images`;\n          apiKey = \"image\"; // Match backend key\n          break;\n        case \"video\":\n          apiUrl = `/api/groups/${groupId}/videos`;\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = `/api/groups/${groupId}/files`;\n          apiKey = \"file\";\n          break;\n      }\n    } else {\n      const conversationId = selectedContact.conversationId;\n      if (!conversationId) {\n        showError(\"Không tìm thấy cuộc trò chuyện để gửi file\");\n        URL.revokeObjectURL(tempUrl);\n        setMessages(prev => prev.filter(msg => msg.id !== tempMessageId)); // Remove optimistic msg\n        return;\n      }\n      formData.append(\"conversationId\", conversationId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = \"/api/messages/send/image\";\n          apiKey = \"images\"; // Match backend key (plural for this endpoint)\n          break;\n        case \"video\":\n          apiUrl = \"/api/messages/send/video\";\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = \"/api/messages/send/file\";\n          apiKey = \"file\";\n          break;\n      }\n    }\n    formData.append(apiKey, file);\n    try {\n      var _messageData$attachme;\n      const response = await apiCall(\"post\", apiUrl, formData, token);\n      const messageData = response.messageData || response; // Adjust based on API response structure\n      const attachment = (_messageData$attachme = messageData.attachments) === null || _messageData$attachme === void 0 ? void 0 : _messageData$attachme[0];\n      if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n        throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\");\n      }\n\n      // Update optimistic message\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        id: messageData.messageId,\n        content: attachment.url,\n        // Use final URL\n        fileUrl: fileType === \"file\" ? attachment.url : null,\n        isSending: false,\n        time: new Date(messageData.createdAt).toLocaleTimeString([], {\n          hour: \"2-digit\",\n          minute: \"2-digit\"\n        })\n      } : msg));\n\n      // Update media/documents list\n      const newItem = {\n        id: messageData.messageId,\n        type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n        url: attachment.url,\n        name: attachment.name || file.name,\n        date: new Date(messageData.createdAt).toLocaleDateString(),\n        size: attachment.size || file.size,\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      if (fileType === \"image\" || fileType === \"video\") {\n        setMediaFiles(prev => [newItem, ...prev]); // Add to beginning (newest)\n      } else {\n        setDocuments(prev => [newItem, ...prev]);\n      }\n\n      // Emit socket event\n      const socketEventData = {\n        messageId: messageData.messageId,\n        conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n        groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n        senderId: user.id,\n        senderName: user.name,\n        receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n        type: fileType,\n        // 'file', 'image', 'video'\n        content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null,\n        // Content might be null for media\n        attachments: messageData.attachments,\n        createdAt: messageData.createdAt || new Date().toISOString(),\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\";\n      socket.emit(socketEventName, socketEventData);\n      URL.revokeObjectURL(tempUrl); // Clean up temp URL\n    } catch (error) {\n      console.error(`Error sending ${fileType}:`, error);\n      showError(`Không thể gửi ${fileType}: ${error.message}`);\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n      URL.revokeObjectURL(tempUrl);\n    }\n  }, [isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n  const getVideoDuration = file => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\");\n      video.preload = \"metadata\";\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src);\n        resolve(video.duration);\n      };\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src);\n        reject(new Error(\"Không thể tải metadata video\"));\n      };\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback(emoji => {\n    setNewMessage(prev => prev + emoji);\n    setShowEmojiPicker(false);\n  }, []);\n  const handleMessageAction = useCallback(async (messageId, action) => {\n    if (action === \"delete\") {\n      const token = localStorage.getItem(\"token\");\n      if (!token || !selectedContact) return;\n\n      // Optimistic UI update\n      const originalMessages = [...messages];\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        content: \"Đang xóa...\",\n        isUnsent: true,\n        isDeleting: true\n      } : msg));\n      try {\n        if (selectedContact.type === \"group\") {\n          await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token);\n        } else {\n          await apiCall(\"delete\", `/api/messages/${messageId}`, null, token);\n        }\n\n        // Confirm deletion in UI\n        setMessages(prev => prev.map(msg => msg.id === messageId ? {\n          ...msg,\n          content: \"Tin nhắn đã bị xóa\",\n          isDeleting: false\n        } : msg));\n\n        // Remove from media/documents lists\n        setMediaFiles(prev => prev.filter(media => media.id !== messageId));\n        setDocuments(prev => prev.filter(doc => doc.id !== messageId));\n\n        // TODO: Emit socket event for deletion if needed by backend/other clients\n      } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        showError(\"Không thể xóa tin nhắn: \" + error.message);\n        // Revert optimistic update on error\n        setMessages(originalMessages);\n      }\n    }\n    // Handle other actions like 'recall' if implemented\n  }, [apiCall, selectedContact, showError, messages] // Include messages in dependency array\n  );\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true);\n    setShowFiles(false);\n  }, []);\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false);\n    setShowFiles(true);\n  }, []);\n  const handleTabChange = useCallback(tab => {\n    setActiveTab(tab);\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchFriendRequests(token);\n      }\n    }\n  }, [fetchFriendRequests]); // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null\n    });\n    setShowProfileModal(true);\n  }, [user.name, user.avatar]); // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false);\n  }, []);\n  const handleAvatarChange = useCallback(async file => {\n    // File validation\n    if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n      showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const formData = new FormData();\n    formData.append(\"avatar\", file);\n    try {\n      setLoading(true); // Indicate loading\n      const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token);\n      // Update state optimistically/realistically\n      setProfileData(prev => ({\n        ...prev,\n        avatarUrl: response.avatarUrl\n      }));\n      setUser(prev => ({\n        ...prev,\n        avatar: response.avatarUrl\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.avatarUrl = response.avatarUrl;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật ảnh đại diện thành công!\");\n    } catch (error) {\n      showError(\"Không thể tải avatar: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError]);\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    try {\n      setLoading(true);\n      const response = await apiCall(\"put\", \"/api/users/profile\", {\n        fullName: profileData.fullName,\n        // Ensure birthdate is sent correctly or omitted if empty\n        birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n        gender: profileData.gender || undefined // Send undefined if empty to potentially clear it\n      }, token);\n      // Update user state\n      setUser(prev => ({\n        ...prev,\n        name: response.fullName || prev.name\n        // Avatar might not be in this response, keep existing one\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.fullName = response.fullName;\n      userProfile.birthdate = response.birthdate;\n      userProfile.gender = response.gender;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật hồ sơ thành công!\");\n      handleCloseProfileModal();\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal]);\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true);\n  }, []);\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false);\n    setFriendEmail(\"\"); // Reset email field\n  }, []);\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\");\n      return;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      var _searchResult$data;\n      // Search user first to get ID\n      const searchResult = await apiCall(\"get\", `/api/users/search?query=${encodeURIComponent(friendEmail)}`, null, token);\n      if (!(searchResult !== null && searchResult !== void 0 && (_searchResult$data = searchResult.data) !== null && _searchResult$data !== void 0 && _searchResult$data.length)) {\n        throw new Error(\"Không tìm thấy người dùng với email này\");\n      }\n      const receiverId = searchResult.data[0].userId;\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\");\n      }\n\n      // Check if already friends\n      if (contacts.some(c => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\");\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", {\n        receiverId,\n        message: `Kết bạn từ ${user.name}`\n      }, token);\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`);\n      handleCloseAddFriendModal();\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`);\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`);\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`);\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`);\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false);\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts]);\n  const handleRespondToFriendRequest = useCallback(async (requestId, action) => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const request = friendRequests.find(req => req.requestId === requestId);\n    if (!request) return;\n    setLoading(true); // Indicate processing\n    // Optimistically remove from list\n    setFriendRequests(prev => prev.filter(req => req.requestId !== requestId));\n    try {\n      const response = await apiCall(\"post\", \"/api/friends/requests/respond\", {\n        requestId,\n        action\n      }, token);\n      console.log(\"Friend request response:\", response);\n      if (action === \"accept\") {\n        var _response$conversatio2, _senderInfo$email;\n        showError(\"Đã chấp nhận lời mời kết bạn\");\n        const senderInfo = request.sender;\n        if (!senderInfo || !senderInfo.userId) {\n          throw new Error(\"Thông tin người gửi không hợp lệ\");\n        }\n\n        // Get conversation ID (might be in response or need creation)\n        let conversationId = (_response$conversatio2 = response.conversation) === null || _response$conversatio2 === void 0 ? void 0 : _response$conversatio2.conversationId;\n        if (!conversationId) {\n          console.log(\"No conversationId in response, creating/getting...\");\n          conversationId = await createOrGetConversation(senderInfo.userId, token);\n        }\n        if (!conversationId) {\n          throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\");\n        }\n\n        // Create new contact object\n        const newContact = {\n          id: senderInfo.userId,\n          name: senderInfo.fullName || ((_senderInfo$email = senderInfo.email) === null || _senderInfo$email === void 0 ? void 0 : _senderInfo$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: senderInfo.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          conversationId: conversationId\n        };\n        addOrUpdateContact(newContact); // Add/update contact list and localStorage\n\n        // Optionally select the new contact immediately\n        // handleContactSelect(newContact);\n\n        // Emit notification to the sender via socket\n        if (socket.connected) {\n          socket.emit(\"friend_request_accepted_notify\", {\n            accepter: {\n              userId: user.id,\n              fullName: user.name,\n              avatarUrl: user.avatar\n            },\n            senderId: senderInfo.userId,\n            // Target the sender\n            conversationId: conversationId\n          });\n          // Also tell sender to refresh their list\n          socket.emit(\"refresh_contacts_notify\", {\n            targetUserId: senderInfo.userId\n          });\n          console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\");\n        }\n      } else {\n        showError(\"Đã từ chối lời mời kết bạn\");\n        // Optionally notify sender of rejection via socket\n      }\n    } catch (error) {\n      console.error(\"Error responding to friend request:\", error);\n      showError(\"Không thể phản hồi lời mời: \" + error.message);\n      // Revert optimistic removal on error\n      setFriendRequests(prev => [...prev, request]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleRemoveFriend = useCallback(async friendId => {\n    if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    console.log(`Attempting to remove friend with ID: ${friendId}`);\n    setLoading(true);\n\n    // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n    const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\");\n    if (!contactToRemove) {\n      showError(\"Không tìm thấy người dùng trong danh sách bạn bè\");\n      setLoading(false);\n      return;\n    }\n\n    // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n    const currentContacts = [...contacts];\n    try {\n      // Cập nhật UI trước khi gọi API (optimistic update)\n      setContacts(prev => prev.filter(contact => contact.id !== friendId || contact.type !== \"contact\"));\n\n      // Cập nhật localStorage\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const updatedContacts = savedContacts.filter(c => c.id !== friendId || c.type !== \"contact\");\n        localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts));\n      } catch (e) {\n        console.error(\"Error updating localStorage after friend removal\", e);\n      }\n\n      // Bỏ chọn nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === friendId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n\n      // Gọi API để xóa bạn bè\n      try {\n        console.log(`Calling API to remove friend: ${friendId}`);\n        const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token);\n        console.log(\"Friend removal API response:\", response);\n        showError(\"Đã xóa bạn bè thành công\");\n\n        // Thông báo cho người bạn bị xóa qua socket\n        if (socket && socket.connected) {\n          socket.emit(\"friend_removed_notify\", {\n            removerId: user.id,\n            removedUserId: friendId\n          });\n          console.log(\"Emitted friend_removed_notify\");\n\n          // Thông báo cập nhật danh sách bạn bè\n          socket.emit(\"friend_list_updated\");\n        }\n\n        // Cập nhật lại danh sách bạn bè từ server\n        fetchContactsAndGroups(token);\n      } catch (apiError) {\n        console.error(\"API error removing friend:\", apiError);\n\n        // Kiểm tra lỗi cụ thể\n        if (apiError.response && apiError.response.status === 404) {\n          // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n          showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\");\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token);\n        } else {\n          // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n          showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"));\n          // Khôi phục lại danh sách bạn bè\n          setContacts(currentContacts);\n\n          // Khôi phục localStorage\n          try {\n            localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n          } catch (e) {\n            console.error(\"Error restoring localStorage\", e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in handleRemoveFriend:\", error);\n      showError(\"Không thể xóa bạn bè: \" + error.message);\n\n      // Khôi phục lại danh sách bạn bè\n      setContacts(currentContacts);\n\n      // Khôi phục localStorage\n      try {\n        localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n      } catch (e) {\n        console.error(\"Error restoring localStorage\", e);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups]);\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true);\n  }, []);\n  const handleGroupCreated = useCallback(newGroupData => {\n    var _newGroupData$members;\n    console.log(\"Group created data:\", newGroupData);\n    const groupObject = {\n      groupId: newGroupData.groupId,\n      id: newGroupData.groupId,\n      // Add id for consistency\n      name: newGroupData.name,\n      avatar: newGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: newGroupData.adminId,\n      memberCount: ((_newGroupData$members = newGroupData.members) === null || _newGroupData$members === void 0 ? void 0 : _newGroupData$members.length) || 1,\n      // At least admin is a member\n      conversationId: newGroupData.conversationId || newGroupData.groupId,\n      createdAt: newGroupData.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    setShowCreateGroupModal(false);\n    showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`);\n    // Automatically select the new group\n    handleContactSelect(groupObject);\n  }, [addOrUpdateGroup, showError, handleContactSelect]);\n  const handleGroupInfo = useCallback(group => {\n    // Fetch full group details if necessary before showing modal\n    setSelectedGroup(group); // Pass the basic group info for now\n    setShowGroupInfoModal(true);\n    // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n  }, [] // No dependencies needed to just show the modal\n  );\n  const handleGroupUpdated = useCallback(updatedGroupData => {\n    var _updatedGroupData$mem;\n    console.log(\"Group updated data:\", updatedGroupData);\n    // Ensure the data structure matches what addOrUpdateGroup expects\n    const groupObject = {\n      groupId: updatedGroupData.groupId,\n      id: updatedGroupData.groupId,\n      name: updatedGroupData.name,\n      avatar: updatedGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: updatedGroupData.adminId,\n      memberCount: updatedGroupData.memberCount || ((_updatedGroupData$mem = updatedGroupData.members) === null || _updatedGroupData$mem === void 0 ? void 0 : _updatedGroupData$mem.length) || 0,\n      conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n      createdAt: updatedGroupData.createdAt\n      // Include other relevant fields if needed\n    };\n    addOrUpdateGroup(groupObject);\n    // Update selected contact if it's the one being edited\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupObject.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    setShowGroupInfoModal(false); // Close modal on success\n    showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleLeaveGroup = useCallback(async groupId => {\n    console.log(\"Leaving group:\", groupId);\n    if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      // Gọi API để rời nhóm\n      const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token);\n      console.log(\"Leave group API response:\", response);\n\n      // Cập nhật UI sau khi API thành công\n      setGroups(prev => prev.filter(group => group.groupId !== groupId));\n\n      // Cập nhật localStorage\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after leaving group\", e);\n      }\n\n      // Bỏ chọn nhóm nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n      setShowGroupInfoModal(false); // Đóng modal\n      showError(\"Bạn đã rời khỏi nhóm thành công\");\n\n      // Thông báo qua socket nếu cần\n      if (socket.connected) {\n        socket.emit(\"left_group\", {\n          groupId\n        });\n      }\n    } catch (error) {\n      console.error(\"Error leaving group:\", error);\n      showError(\"Không thể rời khỏi nhóm: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedContact, showError, apiCall]);\n  const handleDeleteGroup = useCallback(groupId => {\n    console.log(\"Deleting group:\", groupId);\n    setGroups(prev => prev.filter(group => group.groupId !== groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after deleting group\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    setShowGroupInfoModal(false); // Close modal\n    showError(\"Đã xóa nhóm thành công\");\n    // API call to delete group should be handled within GroupInfoModal or here before state update\n  }, [selectedContact, showError]);\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      navigate(\"/login\");\n      return;\n    }\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    let socketInitialized = false;\n    const initializeApp = async () => {\n      try {\n        setLoading(true);\n        const userProfile = await fetchUserProfile(token);\n        if (!userProfile || !isMounted) return; // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token);\n        if (!isMounted) return;\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token);\n        if (!isMounted) return;\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\");\n\n          // Set socket auth and query params\n          socket.auth = {\n            token\n          };\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now()\n          };\n\n          // Connect the socket\n          socket.connect();\n          socketInitialized = true;\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\");\n      socket.off(\"reconnect\");\n      socket.off(\"friend_request\");\n      socket.off(\"new_message\");\n      socket.off(\"receive_message\");\n      socket.off(\"group_message\");\n      socket.off(\"friend_request_accepted\");\n      socket.off(\"friend_removed\");\n      socket.off(\"refresh_contacts\");\n      socket.off(\"notification\");\n      socket.off(\"group_created\");\n      socket.off(\"group_updated\");\n      socket.off(\"group_deleted\");\n      socket.off(\"member_added\");\n      socket.off(\"member_removed\");\n    };\n  }, [navigate]); // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback(data => {\n    var _data$attachments, _data$attachments$, _data$attachments2, _data$attachments2$, _data$attachments3, _data$attachments3$, _data$attachments4, _data$attachments4$, _data$attachments5, _data$attachments5$;\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || !data.messageId && !data.id) {\n      console.error(\"Invalid message data received:\", data);\n      return;\n    }\n    const messageTime = data.createdAt ? new Date(data.createdAt).toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }) : new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString();\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type,\n      selectedContactGroupId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.groupId,\n      selectedContactConversationId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.conversationId\n    });\n    const isCurrentChat = (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\" && selectedContact.groupId === data.groupId || (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\" && selectedContact.conversationId === data.conversationId;\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content: data.isRecalled || data.isDeleted ? \"Tin nhắn đã bị thu hồi/xóa\" : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\" ? data.content : ((_data$attachments = data.attachments) === null || _data$attachments === void 0 ? void 0 : (_data$attachments$ = _data$attachments[0]) === null || _data$attachments$ === void 0 ? void 0 : _data$attachments$.url) || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: data.type === \"image\" || data.type === \"imageGroup\",\n      isVideo: data.type === \"video\",\n      isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: data.type === \"file\" ? (_data$attachments2 = data.attachments) === null || _data$attachments2 === void 0 ? void 0 : (_data$attachments2$ = _data$attachments2[0]) === null || _data$attachments2$ === void 0 ? void 0 : _data$attachments2$.url : null,\n      fileName: data.type === \"file\" ? (_data$attachments3 = data.attachments) === null || _data$attachments3 === void 0 ? void 0 : (_data$attachments3$ = _data$attachments3[0]) === null || _data$attachments3$ === void 0 ? void 0 : _data$attachments3$.name : null,\n      fileType: data.type === \"file\" ? (_data$attachments4 = data.attachments) === null || _data$attachments4 === void 0 ? void 0 : (_data$attachments4$ = _data$attachments4[0]) === null || _data$attachments4$ === void 0 ? void 0 : _data$attachments4$.type : null,\n      duration: data.type === \"video\" ? ((_data$attachments5 = data.attachments) === null || _data$attachments5 === void 0 ? void 0 : (_data$attachments5$ = _data$attachments5[0]) === null || _data$attachments5$ === void 0 ? void 0 : _data$attachments5$.duration) || data.duration : null,\n      messageDate: messageDate\n    };\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || [];\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev;\n        return {\n          ...prev,\n          [data.conversationId]: [...prevList, newMessage]\n        };\n      });\n    }\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        if (exists) return prev;\n        return [...prev, newMessage];\n      });\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles(prev => {\n          var _data$attachments6, _data$attachments6$;\n          return [{\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: ((_data$attachments6 = data.attachments) === null || _data$attachments6 === void 0 ? void 0 : (_data$attachments6$ = _data$attachments6[0]) === null || _data$attachments6$ === void 0 ? void 0 : _data$attachments6$.size) || 0,\n            duration: newMessage.duration\n          }, ...prev // Add to beginning\n          ];\n        });\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments(prev => {\n          var _newMessage$fileName, _data$attachments7, _data$attachments7$;\n          return [{\n            id: newMessage.id,\n            type: ((_newMessage$fileName = newMessage.fileName) === null || _newMessage$fileName === void 0 ? void 0 : _newMessage$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: ((_data$attachments7 = data.attachments) === null || _data$attachments7 === void 0 ? void 0 : (_data$attachments7$ = _data$attachments7[0]) === null || _data$attachments7$ === void 0 ? void 0 : _data$attachments7$.size) || 0\n          }, ...prev // Add to beginning\n          ];\n        });\n      }\n    } else {\n      var _data$content, _data$content2;\n      // Notification for message in other chat\n      let senderName = \"Người dùng\";\n      let contactId = data.senderId; // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find(g => g.groupId === data.groupId);\n        senderName = `${data.senderName || \"Ai đó\"} (${(group === null || group === void 0 ? void 0 : group.name) || \"Nhóm\"})`;\n      } else {\n        const contact = contacts.find(c => c.id === data.senderId); // Tìm contact dựa trên senderId\n        senderName = (contact === null || contact === void 0 ? void 0 : contact.name) || data.senderName || \"Ai đó\";\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n      const preview = data.type === \"text\" ? ((_data$content = data.content) === null || _data$content === void 0 ? void 0 : _data$content.substring(0, 30)) + (((_data$content2 = data.content) === null || _data$content2 === void 0 ? void 0 : _data$content2.length) > 30 ? \"...\" : \"\") : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`;\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`);\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview,\n              // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(c => c.conversationId === data.conversationId || c.id === data.senderId);\n        if (foundContact) {\n          setSelectedContact(foundContact);\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || []);\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      var _contacts$find, _groups$find;\n      const contactName = data.senderName || \"Người dùng\";\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: ((_contacts$find = contacts.find(c => c.id === data.senderId)) === null || _contacts$find === void 0 ? void 0 : _contacts$find.avatar) || ((_groups$find = groups.find(g => g.groupId === data.groupId)) === null || _groups$find === void 0 ? void 0 : _groups$find.avatar) || \"/favicon.ico\" // Optional icon\n      });\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages]);\n  const handleFriendRequest = useCallback(data => {\n    if (!data || !data.requestId || !data.sender) return;\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab]);\n  const handleFriendRequestAccepted = useCallback(data => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\");\n      return;\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleFriendRemoved = useCallback(data => {\n    if (!data || !data.removerId) return;\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError]);\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\");\n    if (token) {\n      fetchContactsAndGroups(token);\n    }\n  }, [fetchContactsAndGroups]);\n  const handleSocketGroupCreated = useCallback(data => {\n    var _group$members3;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_created event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: ((_group$members3 = group.members) === null || _group$members3 === void 0 ? void 0 : _group$members3.length) || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`);\n  }, [addOrUpdateGroup, showError]);\n  const handleSocketGroupUpdated = useCallback(data => {\n    var _group$members4;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_updated event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members4 = group.members) === null || _group$members4 === void 0 ? void 0 : _group$members4.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleGroupDeleted = useCallback(data => {\n    var _groups$find2;\n    if (!(data !== null && data !== void 0 && data.groupId)) return;\n    console.log(\"Received group_deleted event:\", data.groupId);\n    const groupName = ((_groups$find2 = groups.find(g => g.groupId === data.groupId)) === null || _groups$find2 === void 0 ? void 0 : _groups$find2.name) || \"Một nhóm\";\n    setGroups(prev => prev.filter(group => group.groupId !== data.groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== data.groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after group delete\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === data.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`);\n  }, [groups, selectedContact, showError]);\n  const handleMemberAdded = useCallback(data => {\n    var _group$members5;\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.member) || !(data !== null && data !== void 0 && data.addedBy)) return;\n    console.log(\"Received member_added event:\", data);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members5 = group.members) === null || _group$members5 === void 0 ? void 0 : _group$members5.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleMemberRemoved = useCallback(data => {\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.memberId) || !(data !== null && data !== void 0 && data.removedBy)) return;\n    console.log(\"Received member_removed event:\", data);\n    const group = data.group;\n    const groupId = group.groupId;\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`);\n      setGroups(prev => prev.filter(g => g.groupId !== groupId));\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after being removed from group\", e);\n      }\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n    } else {\n      var _group$members6, _data$member;\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || ((_group$members6 = group.members) === null || _group$members6 === void 0 ? void 0 : _group$members6.length) || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt\n      };\n      addOrUpdateGroup(groupObject);\n      const memberName = ((_data$member = data.member) === null || _data$member === void 0 ? void 0 : _data$member.fullName) || \"một thành viên\";\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`);\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(groupObject);\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleNotification = useCallback(data => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data);\n      return;\n    }\n    if (data.type === \"success\") {\n      showError(data.message);\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\");\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\");\n    } else {\n      showError(data.message);\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchContactsAndGroups(token);\n      }\n    }\n  }, [showError, fetchContactsAndGroups]);\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true;\n    const handleConnect = () => {\n      if (!isMounted) return;\n      console.log(\"Socket re-connected inside hook.\");\n      setIsConnected(true);\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId);\n      }\n    };\n\n    // Add handler for message_sent event\n    const handleMessageSent = data => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data);\n        return;\n      }\n      console.log(\"Received message_sent_success event:\", data);\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n        // Match by tempMessageId if available\n        data.tempMessageId && msg.id === data.tempMessageId ||\n        // Or match by conversationId and content if tempMessageId not available\n        data.conversationId && msg.conversationId === data.conversationId && msg.content === data.content)) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          });\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          };\n        }\n        return msg;\n      }));\n    };\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect);\n    socket.on(\"message_sent_success\", handleMessageSent); // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage);\n    socket.on(\"receive_message\", handleNewMessage);\n    socket.on(\"group_message\", handleNewMessage);\n    socket.on(\"friend_request\", handleFriendRequest);\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted);\n    socket.on(\"friend_removed\", handleFriendRemoved);\n    socket.on(\"refresh_contacts\", handleRefreshContacts);\n    socket.on(\"notification\", handleNotification);\n    socket.on(\"group_created\", handleSocketGroupCreated);\n    socket.on(\"group_updated\", handleSocketGroupUpdated);\n    socket.on(\"group_deleted\", handleGroupDeleted);\n    socket.on(\"member_added\", handleMemberAdded);\n    socket.on(\"member_removed\", handleMemberRemoved);\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false;\n      socket.off(\"connect\", handleConnect);\n      socket.off(\"message_sent_success\", handleMessageSent); // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage);\n      socket.off(\"receive_message\", handleNewMessage);\n      socket.off(\"group_message\", handleNewMessage);\n      socket.off(\"friend_request\", handleFriendRequest);\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted);\n      socket.off(\"friend_removed\", handleFriendRemoved);\n      socket.off(\"refresh_contacts\", handleRefreshContacts);\n      socket.off(\"notification\", handleNotification);\n      socket.off(\"group_created\", handleSocketGroupCreated);\n      socket.off(\"group_updated\", handleSocketGroupUpdated);\n      socket.off(\"group_deleted\", handleGroupDeleted);\n      socket.off(\"member_added\", handleMemberAdded);\n      socket.off(\"member_removed\", handleMemberRemoved);\n    };\n  }, [handleNewMessage, handleFriendRequest, handleFriendRequestAccepted, handleFriendRemoved, handleRefreshContacts, handleNotification, handleSocketGroupCreated, handleSocketGroupUpdated, handleGroupDeleted, handleMemberAdded, handleMemberRemoved, selectedContact // Add selectedContact as dependency\n  ]);\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]); // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n      var _messagesEndRef$curre;\n      (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"end\"\n      });\n    }, 100);\n  };\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(contact => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const filteredGroups = groups.filter(group => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"]; // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts,\n    // Return full contacts list if needed elsewhere\n    groups,\n    // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab,\n    // Needed for friend request notification\n    setShowProfileModal,\n    // Needed for closing modal from component\n    setProfileData,\n    // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal,\n    // Needed for closing modal from component\n    setFriendEmail,\n    // Needed for form input\n    // setError, // Internal state\n    setShowToast,\n    // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal,\n    // Needed for closing modal from component\n    setShowGroupInfoModal,\n    // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile,\n    // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError,\n    // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\") // Pass token for Modals\n  };\n};\n_s(useChat, \"o3e9ngAy0aNkp6FNjXM2/W+DiHI=\", false, function () {\n  return [useNavigate];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useNavigate","axios","io","API_BASE_URL","socket","autoConnect","reconnection","reconnectionAttempts","Number","POSITIVE_INFINITY","reconnectionDelay","reconnectionDelayMax","timeout","transports","upgrade","forceNew","query","timestamp","Date","now","on","console","log","id","err","error","reason","window","originalConsoleError","args","includes","apply","useChat","_s","navigate","user","setUser","name","avatar","contacts","setContacts","groups","setGroups","selectedContact","setSelectedContact","messages","setMessages","newMessage","setNewMessage","isConnected","setIsConnected","connected","showEmojiPicker","setShowEmojiPicker","searchQuery","setSearchQuery","mediaFiles","setMediaFiles","documents","setDocuments","showMedia","setShowMedia","showFiles","setShowFiles","activeTab","setActiveTab","showProfileModal","setShowProfileModal","profileData","setProfileData","fullName","birthdate","gender","avatarUrl","loading","setLoading","showAddFriendModal","setShowAddFriendModal","friendEmail","setFriendEmail","setError","showToast","setShowToast","friendRequests","setFriendRequests","recoveredContacts","setRecoveredContacts","showCreateGroupModal","setShowCreateGroupModal","showGroupInfoModal","setShowGroupInfoModal","selectedGroup","setSelectedGroup","cachedMessages","setCachedMessages","messagesEndRef","fileInputRef","imageInputRef","videoInputRef","showError","message","apiCall","method","url","data","token","toUpperCase","FormData","config","headers","Authorization","Pragma","response","status","_error$response","_error$response2","_error$response2$data","localStorage","removeItem","Error","errorMessage","addOrUpdateContact","newContact","savedContacts","getItem","contactsArray","JSON","parse","filter","c","push","setItem","stringify","storageError","prev","exists","some","contact","map","addOrUpdateGroup","newGroup","groupId","savedGroups","groupsArray","g","group","fetchUserProfile","userData","userId","toISOString","split","fetchMessages","conversationId","isGroup","warn","endpoint","messagesData","Array","isArray","mappedMessages","msg","index","_msg$attachments","_msg$attachments$","_msg$attachments2","_msg$attachments$2","_msg$attachments3","_msg$attachments$3","_msg$attachments4","_msg$attachments$4","_msg$attachments5","_msg$attachments$5","messageId","sender","senderId","senderName","content","isRecalled","isDeleted","type","attachments","time","toLocaleTimeString","hour","minute","isImage","isVideo","isFile","isUnsent","isSystemMessage","fileUrl","length","fileName","fileType","duration","messageDate","toLocaleDateString","systemMessage","unshift","mergedMessages","cacheList","newFromCache","cacheMsg","sort","a","b","aTime","createdAt","bTime","media","_msg$attachments6","_msg$attachments6$","date","size","reverse","files","_msg$fileName","_msg$attachments7","_msg$attachments7$","pop","toLowerCase","fetchContactsAndGroups","fetchedContacts","fetchedGroups","friendsResponse","confirmedFriends","friends","validFriends","friend","friendshipId","mappedFriends","_friend$email","email","convResponse","conversationsMap","Map","forEach","conv","participants","otherUserId","find","set","has","get","existingContactsMap","existingContact","groupsResponse","userGroups","members","member","_group$members","_group$members2","adminId","admin","memberIds","memberCount","e","fetchFriendRequests","createOrGetConversation","_response$conversatio","conversation","handleContactSelect","contactOrGroup","roomToLeave","eventName","emit","updatedContact","currentContacts","updatedContactsList","read","unreadCount","readError","handleSendMessage","preventDefault","trim","tempMessageId","messageTime","optimisticMessage","isSending","messageToSend","scrollToBottom","messageDataForSocket","_selectedContact$memb","messageContent","messageData","_error$response3","_error$response4","_response$messageData","_response$messageData2","receiverId","isError","handleSendFile","file","maxSize","startsWith","videoDuration","getVideoDuration","Math","round","tempUrl","URL","createObjectURL","formData","apiUrl","apiKey","append","revokeObjectURL","_messageData$attachme","attachment","newItem","socketEventData","socketEventName","Promise","resolve","reject","video","document","createElement","preload","onloadedmetadata","src","onerror","handleEmojiSelect","emoji","handleMessageAction","action","originalMessages","isDeleting","doc","toggleMediaView","toggleFilesView","handleTabChange","tab","handleProfileClick","userProfile","handleCloseProfileModal","handleAvatarChange","handleUpdateProfile","undefined","handleAddFriend","handleCloseAddFriendModal","handleSubmitAddFriend","emailRegex","test","_searchResult$data","searchResult","encodeURIComponent","handleRespondToFriendRequest","requestId","request","req","_response$conversatio2","_senderInfo$email","senderInfo","accepter","targetUserId","handleRemoveFriend","friendId","confirm","contactToRemove","updatedContacts","removerId","removedUserId","apiError","handleCreateGroup","handleGroupCreated","newGroupData","_newGroupData$members","groupObject","handleGroupInfo","handleGroupUpdated","updatedGroupData","_updatedGroupData$mem","handleLeaveGroup","updatedGroups","handleDeleteGroup","isMounted","socketInitialized","initializeApp","auth","opts","connect","off","handleNewMessage","_data$attachments","_data$attachments$","_data$attachments2","_data$attachments2$","_data$attachments3","_data$attachments3$","_data$attachments4","_data$attachments4$","_data$attachments5","_data$attachments5$","selectedContactType","selectedContactGroupId","selectedContactConversationId","isCurrentChat","prevList","_data$attachments6","_data$attachments6$","_newMessage$fileName","_data$attachments7","_data$attachments7$","_data$content","_data$content2","contactId","targetId","isGroupMessage","preview","substring","item","itemIdToMatch","lastMessage","lastMessageAt","foundContact","hidden","Notification","permission","_contacts$find","_groups$find","contactName","body","icon","handleFriendRequest","handleFriendRequestAccepted","handleFriendRemoved","handleRefreshContacts","handleSocketGroupCreated","_group$members3","handleSocketGroupUpdated","_group$members4","handleGroupDeleted","_groups$find2","groupName","handleMemberAdded","_group$members5","addedBy","handleMemberRemoved","memberId","removedBy","_group$members6","_data$member","memberName","handleNotification","refreshContacts","handleConnect","handleMessageSent","prevMessages","oldId","newId","setTimeout","_messagesEndRef$curre","current","scrollIntoView","behavior","block","filteredContacts","filteredGroups","emojis"],"sources":["C:/Users/ADMIN/Desktop/Nhom12_Zalo_Web/FE-WebAppZola/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\"\nimport { useNavigate } from \"react-router-dom\"\nimport axios from \"axios\"\nimport { io } from \"socket.io-client\"\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\"\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false, // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false, // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now(),\n  },\n})\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id)\n})\n\nsocket.on(\"connect_error\", (err) => {\n  console.error(\"Socket connection error:\", err)\n})\n\nsocket.on(\"disconnect\", (reason) => {\n  console.log(\"Socket disconnected:\", reason)\n})\n\nsocket.on(\"error\", (err) => {\n  console.error(\"Socket error:\", err)\n})\n\nsocket.on(\"reconnect_error\", (err) => {\n  console.error(\"Socket reconnection error:\", err)\n})\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error\n  console.error = (...args) => {\n    if (\n      args[0] &&\n      typeof args[0] === \"string\" &&\n      (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))\n    ) {\n      return\n    }\n    originalConsoleError.apply(console, args)\n  }\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  const navigate = useNavigate()\n\n  // State Management\n  const [user, setUser] = useState({ id: \"\", name: \"User\", avatar: \"\" })\n  const [contacts, setContacts] = useState([])\n  const [groups, setGroups] = useState([])\n  const [selectedContact, setSelectedContact] = useState(null)\n  const [messages, setMessages] = useState([])\n  const [newMessage, setNewMessage] = useState(\"\")\n  const [isConnected, setIsConnected] = useState(socket.connected) // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false)\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [mediaFiles, setMediaFiles] = useState([])\n  const [documents, setDocuments] = useState([])\n  const [showMedia, setShowMedia] = useState(true)\n  const [showFiles, setShowFiles] = useState(false)\n  const [activeTab, setActiveTab] = useState(\"chat\")\n  const [showProfileModal, setShowProfileModal] = useState(false)\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null,\n  })\n  const [loading, setLoading] = useState(false)\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false)\n  const [friendEmail, setFriendEmail] = useState(\"\")\n  const [error, setError] = useState(null)\n  const [showToast, setShowToast] = useState(false)\n  const [friendRequests, setFriendRequests] = useState([])\n  const [recoveredContacts, setRecoveredContacts] = useState([]) // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false)\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false)\n  const [selectedGroup, setSelectedGroup] = useState(null)\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({})\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null)\n  const fileInputRef = useRef(null)\n  const imageInputRef = useRef(null)\n  const videoInputRef = useRef(null)\n\n  // --- Utility Functions ---\n\n  const showError = useCallback((message) => {\n    console.log(\"Showing Toast:\", message)\n    setError(message)\n    setShowToast(true)\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, [])\n\n  const apiCall = useCallback(\n    async (method, url, data = null, token) => {\n      try {\n        console.log(`API Call: ${method.toUpperCase()} ${url}`)\n        if (data) {\n          console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data)\n        }\n\n        const config = {\n          method,\n          url: `${API_BASE_URL}${url}`,\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n            \"If-None-Match\": \"\", // Prevent 304 responses\n          },\n          data,\n        }\n\n        if (!(data instanceof FormData)) {\n          config.headers[\"Content-Type\"] = \"application/json\"\n        }\n\n        console.log(\"Using config:\", {\n          method: config.method,\n          url: config.url,\n          headers: { ...config.headers, Authorization: \"Bearer [HIDDEN]\" },\n        })\n\n        const response = await axios(config)\n        console.log(`API Response ${url}:`, response.status, response.data)\n        return response.data\n      } catch (error) {\n        console.error(`API Error ${url}:`, error)\n        if (error.response) {\n          console.error(\"Response status:\", error.response.status)\n          console.error(\"Response data:\", error.response.data)\n        }\n\n        if (error.response?.status === 401) {\n          localStorage.removeItem(\"token\")\n          localStorage.removeItem(\"userProfile\") // Clear profile too\n          navigate(\"/login\")\n          // Use showError for consistency\n          showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\")\n          throw new Error(\"Phiên đăng nhập hết hạn.\") // Throw to stop further execution\n        }\n\n        const errorMessage = error.response?.data?.message || error.message || \"Đã xảy ra lỗi không xác định\"\n        // Don't automatically show toast here, let the calling function decide\n        // showError(errorMessage);\n        throw new Error(errorMessage)\n      }\n    },\n    [navigate, showError],\n  ) // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback((newContact) => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact)\n      return\n    }\n    console.log(\"Adding or updating contact:\", newContact)\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\")\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : []\n      contactsArray = contactsArray.filter((c) => c.id !== newContact.id)\n      contactsArray.push(newContact)\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray))\n      console.log(\"Saved contact to localStorage:\", newContact.id)\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError)\n    }\n    setContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n  }, [])\n\n  const addOrUpdateGroup = useCallback((newGroup) => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup)\n      return\n    }\n    console.log(\"Adding or updating group:\", newGroup)\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\")\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : []\n      groupsArray = groupsArray.filter((g) => g.groupId !== newGroup.groupId)\n      groupsArray.push(newGroup)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray))\n      console.log(\"Saved group to localStorage:\", newGroup.groupId)\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError)\n    }\n    setGroups((prev) => {\n      const exists = prev.some((group) => group.groupId === newGroup.groupId)\n      if (exists) {\n        return prev.map((group) => (group.groupId === newGroup.groupId ? { ...group, ...newGroup } : group))\n      }\n      return [...prev, newGroup]\n    })\n  }, [])\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(\n    async (token) => {\n      try {\n        const response = await apiCall(\"get\", \"/api/users/profile\", null, token)\n        const userData = {\n          id: response.userId,\n          name: response.fullName || \"User\",\n          avatar: response.avatarUrl || \"\",\n        }\n        setUser(userData)\n        setProfileData({\n          fullName: response.fullName || \"\",\n          birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n          gender: response.gender || \"\",\n          avatarUrl: response.avatarUrl || null,\n        })\n        // Save profile to localStorage after fetching\n        localStorage.setItem(\"userProfile\", JSON.stringify(response))\n        return response // Return the full profile\n      } catch (error) {\n        console.error(\"Error fetching user profile:\", error)\n        showError(\"Không thể lấy thông tin người dùng: \" + error.message)\n        // No need to navigate here, apiCall handles 401\n        return null\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const fetchMessages = useCallback(\n    async (token, conversationId, isGroup = false) => {\n      if (!token || !conversationId) {\n        console.warn(\"fetchMessages called without token or conversationId\")\n        setMessages([]) // Clear messages if no ID\n        setMediaFiles([])\n        setDocuments([])\n        return\n      }\n      setLoading(true) // Indicate loading messages\n      try {\n        let response\n        // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n        const endpoint = `/api/messages/conversations/${conversationId}/messages`\n\n        console.log(\"Fetching messages from endpoint:\", endpoint)\n        response = await apiCall(\"get\", endpoint, null, token)\n        console.log(\"Messages API response:\", response)\n\n        const messagesData = Array.isArray(response) ? response : response.data || []\n\n        const mappedMessages = messagesData\n          .map((msg, index) => ({\n            id: msg.messageId || `temp-${Date.now()}-${index}`,\n            sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n            content:\n              msg.isRecalled || msg.isDeleted\n                ? \"Tin nhắn đã bị thu hồi/xóa\"\n                : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\"\n                  ? msg.content\n                  : msg.attachments?.[0]?.url || msg.content || \"\", // Ensure content exists\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            senderId: msg.senderId,\n            isImage: msg.type === \"image\" || msg.type === \"imageGroup\",\n            isVideo: msg.type === \"video\",\n            isFile: msg.type === \"file\",\n            isUnsent: msg.isRecalled || msg.isDeleted,\n            isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n            fileUrl: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.url : null,\n            fileName: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.name : null,\n            fileType: msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.type : null,\n            duration: msg.type === \"video\" && msg.attachments?.length > 0 ? msg.attachments[0]?.duration : null,\n            messageDate: new Date().toLocaleDateString(), // Used for media/files list\n          }))\n          .filter((msg) => msg.id) // Filter out messages without an ID\n\n        // Add system message if needed\n        if (mappedMessages.length === 0 || !mappedMessages.some((msg) => msg.isSystemMessage)) {\n          const systemMessage = isGroup\n            ? \"Chào mừng bạn đến với nhóm chat!\"\n            : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\"\n          mappedMessages.unshift({\n            id: `system-${Date.now()}`,\n            senderId: \"system\",\n            content: systemMessage,\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            isSystemMessage: true,\n          })\n        }\n\n        // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n        let mergedMessages = mappedMessages\n        if (cachedMessages[conversationId]) {\n          const cacheList = cachedMessages[conversationId]\n          console.log('Cache for this conversation:', cacheList)\n          // Lọc ra các tin nhắn cache chưa có trong mappedMessages\n          const newFromCache = cacheList.filter(\n            cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id)\n          )\n          mergedMessages = [...mappedMessages, ...newFromCache]\n          // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n          mergedMessages.sort((a, b) => {\n            const aTime = new Date(a.createdAt || a.time || a.messageDate)\n            const bTime = new Date(b.createdAt || b.time || b.messageDate)\n            return aTime - bTime\n          })\n        }\n        console.log('Merged messages after cache merge:', mergedMessages)\n        setMessages(mergedMessages)\n\n        // Update Media and Documents\n        const media = mappedMessages\n          .filter((msg) => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.isImage ? \"image\" : \"video\",\n            url: msg.content,\n            name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0, // Might not be available, default to 0\n            duration: msg.duration,\n          }))\n        setMediaFiles(media.reverse()) // Show newest first\n\n        const files = mappedMessages\n          .filter((msg) => msg.isFile && !msg.isUnsent && msg.fileUrl)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: msg.fileUrl,\n            name: msg.fileName,\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0,\n          }))\n        setDocuments(files.reverse()) // Show newest first\n      } catch (error) {\n        console.error(\"Error fetching messages:\", error)\n        showError(\"Không thể tải tin nhắn: \" + error.message)\n        setMessages([]) // Clear messages on error\n        setMediaFiles([])\n        setDocuments([])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id to compare sender\n  )\n\n  const fetchContactsAndGroups = useCallback(\n    async (token) => {\n      if (!token) return { contacts: [], groups: [] }\n      setLoading(true)\n      let fetchedContacts = []\n      let fetchedGroups = []\n\n      try {\n        // Fetch Friends (Contacts) from server first\n        console.log(\"Fetching friends from server...\")\n        const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token)\n        console.log(\"Friends API response:\", friendsResponse)\n\n        // Lọc ra những người bạn đã được xác nhận\n        // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n        const confirmedFriends = friendsResponse?.friends || []\n        console.log(\"Confirmed friends:\", confirmedFriends)\n\n        // Kiểm tra xem danh sách bạn bè có hợp lệ không\n        const validFriends = confirmedFriends.filter(friend =>\n          friend && friend.userId && friend.friendshipId\n        )\n\n        if (validFriends.length !== confirmedFriends.length) {\n          console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`)\n        }\n\n        const mappedFriends = validFriends.map((friend) => ({\n          id: friend.userId,\n          name: friend.fullName || friend.email?.split(\"@\")[0] || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\", // Trạng thái mặc định\n          friendshipId: friend.friendshipId, // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null, // Will be populated later\n        }))\n\n        // Fetch Conversations to get conversation IDs\n        console.log(\"Fetching conversations...\")\n        const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token)\n        const conversationsMap = new Map()\n        if (convResponse && Array.isArray(convResponse)) {\n          convResponse.forEach((conv) => {\n            if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n              const otherUserId = conv.participants.find((id) => id !== user.id)\n              if (otherUserId) {\n                conversationsMap.set(otherUserId, conv.conversationId)\n              }\n            }\n          })\n        }\n\n        // Update conversationId for mapped friends\n        mappedFriends.forEach((friend) => {\n          if (conversationsMap.has(friend.id)) {\n            friend.conversationId = conversationsMap.get(friend.id)\n          }\n        })\n\n        // Merge with existing contacts to preserve any additional data\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n\n        // Create a map of existing contacts for quick lookup\n        const existingContactsMap = new Map()\n        savedContacts.forEach(contact => {\n          if (contact && contact.id) {\n            existingContactsMap.set(contact.id, contact)\n          }\n        })\n\n        // Merge server data with existing data, prioritizing server data\n        fetchedContacts = mappedFriends.map(friend => {\n          const existingContact = existingContactsMap.get(friend.id)\n          if (existingContact) {\n            // Preserve conversationId if it exists in saved contact but not in server data\n            if (!friend.conversationId && existingContact.conversationId) {\n              friend.conversationId = existingContact.conversationId\n            }\n            return { ...existingContact, ...friend }\n          }\n          return friend\n        })\n\n        // Update state and localStorage\n        setContacts(fetchedContacts)\n        localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts))\n        console.log(\"Updated contacts from API:\", fetchedContacts.length)\n\n        // Fetch Groups\n        console.log(\"Fetching groups...\")\n        const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token)\n        console.log(\"Groups API response:\", groupsResponse)\n\n        if (groupsResponse && groupsResponse.groups) {\n          // Lọc các nhóm mà người dùng là thành viên\n          const userGroups = groupsResponse.groups.filter(\n            (group) => group.members && group.members.some(member => member.userId === user.id)\n          )\n          console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`)\n\n          fetchedGroups = userGroups.map((group) => ({\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [], // Lưu toàn bộ thông tin thành viên\n            memberIds: group.members?.map(member => member.userId) || [], // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || group.members?.length || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt,\n          }))\n          setGroups(fetchedGroups)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups))\n          console.log(\"Updated groups from API:\", fetchedGroups.length)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } catch (error) {\n        console.error(\"Error fetching contacts/groups:\", error)\n        showError(\"Không thể tải danh bạ/nhóm: \" + error.message)\n\n        // Fallback to localStorage only if server fetch fails\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n\n          if (savedContacts.length > 0) {\n            console.log(\"Falling back to contacts from localStorage\")\n            setContacts(savedContacts)\n            fetchedContacts = savedContacts\n          }\n\n          if (savedGroups.length > 0) {\n            console.log(\"Falling back to groups from localStorage\")\n            setGroups(savedGroups)\n            fetchedGroups = savedGroups\n          }\n        } catch (e) {\n          console.error(\"Error reading contacts/groups from localStorage\", e)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id for conversation mapping\n  )\n\n  const fetchFriendRequests = useCallback(\n    async (token) => {\n      if (!token) return\n      // No need for setLoading(true) here unless it's a primary action\n      try {\n        const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token)\n        setFriendRequests(response.data || [])\n      } catch (error) {\n        console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error)\n        // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(\n    async (otherUserId, token) => {\n      console.log(`Creating/getting conversation with user: ${otherUserId}`)\n      if (!token || !otherUserId) {\n        throw new Error(\"Token or otherUserId missing for createOrGetConversation\")\n      }\n      try {\n        const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token)\n        if (response?.conversation?.conversationId) {\n          console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId)\n          return response.conversation.conversationId\n        } else {\n          throw new Error(\"Invalid response structure from conversation API\")\n        }\n      } catch (error) {\n        console.error(\"Error in createOrGetConversation:\", error)\n        if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n          throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\")\n        }\n        throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`) // Rethrow with context\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(\n    async (contactOrGroup) => {\n      if (!contactOrGroup || contactOrGroup.id === selectedContact?.id) {\n        console.log(\"Selection unchanged or invalid.\")\n        return // Avoid re-selecting the same contact/group\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        navigate(\"/login\")\n        return\n      }\n\n      console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id)\n\n      // Leave previous room\n      if (selectedContact) {\n        const roomToLeave =\n          selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId\n        if (roomToLeave) {\n          const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\"\n          socket.emit(eventName, roomToLeave)\n          console.log(`Left ${selectedContact.type} room:`, roomToLeave)\n        }\n      }\n\n      // Clear previous state\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n      setSelectedContact(contactOrGroup) // Set selected contact immediately for UI update\n\n      try {\n        setLoading(true) // Show loading for message fetch\n\n        if (contactOrGroup.type === \"group\") {\n          const groupId = contactOrGroup.groupId\n          // Sử dụng conversationId từ group object\n          const conversationId = contactOrGroup.conversationId || groupId\n          socket.emit(\"join_group\", groupId)\n          console.log(\"Joined group room:\", groupId)\n          console.log(\"Using conversationId for group:\", conversationId)\n          await fetchMessages(token, conversationId, true)\n        } else {\n          // Handle individual contact\n          let conversationId = contactOrGroup.conversationId\n\n          // If conversationId is missing, try to fetch/create it\n          if (!conversationId) {\n            console.log(\"Conversation ID missing, attempting to fetch/create...\")\n            try {\n              conversationId = await createOrGetConversation(contactOrGroup.id, token)\n              // Update the contact in the list and the selected contact state\n              const updatedContact = { ...contactOrGroup, conversationId }\n              setSelectedContact(updatedContact) // Update selected state with new ID\n              setContacts((prev) => prev.map((c) => (c.id === contactOrGroup.id ? updatedContact : c)))\n              // Optionally save updated contacts list to localStorage\n              const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n              const updatedContactsList = currentContacts.map((c) =>\n                c.id === contactOrGroup.id ? updatedContact : c,\n              )\n              localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList))\n            } catch (error) {\n              showError(error.message) // Show error from createOrGetConversation\n              setSelectedContact(null) // Deselect if conversation fails\n              setLoading(false)\n              return // Stop execution if conversation fails\n            }\n          }\n\n          if (conversationId) {\n            socket.emit(\"join_conversation\", conversationId)\n            console.log(\"Joined conversation room:\", conversationId)\n            await fetchMessages(token, conversationId, false)\n\n            // Mark conversation as read with proper request body\n            try {\n              await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, { read: true }, token)\n\n              // Update contacts list to remove unread badge\n              setContacts((prev) =>\n                prev.map((c) =>\n                  c.id === contactOrGroup.id ? { ...c, unreadCount: 0 } : c\n                )\n              )\n            } catch (readError) {\n              console.error(\"Error marking conversation as read:\", readError)\n              // Don't show error to user since this is a non-critical operation\n            }\n          } else {\n            // This case should ideally not be reached if createOrGetConversation throws errors\n            showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\")\n            setSelectedContact(null)\n          }\n        }\n      } catch (error) {\n        // Catch errors from fetchMessages or socket emits\n        console.error(\"Error in handleContactSelect processing:\", error)\n        showError(`Lỗi khi chọn liên hệ: ${error.message}`)\n        setSelectedContact(null) // Deselect on error\n      } finally {\n        setLoading(false) // Ensure loading is turned off\n      }\n    },\n    [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages],\n  )\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(\n    async (e) => {\n      e.preventDefault()\n      if (!newMessage.trim() || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      const tempMessageId = `temp-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: newMessage,\n        time: messageTime,\n        senderId: user.id,\n        isSending: true, // Indicate sending state\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      const messageToSend = newMessage // Store message before clearing\n      setNewMessage(\"\") // Clear input immediately\n      scrollToBottom() // Scroll after adding optimistic message\n\n      try {\n        let response\n        let messageDataForSocket\n\n        if (selectedContact.type === \"group\") {\n          const groupId = selectedContact.groupId\n          console.log(\"Attempting to send group message:\", {\n            groupId,\n            messageContent: messageToSend,\n            selectedContact\n          })\n\n          if (!groupId) {\n            throw new Error(\"GroupId is missing\")\n          }\n\n          // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n          if (!selectedContact.memberIds?.includes(user.id)) {\n            console.error(\"User not in group members:\", {\n              userId: user.id,\n              memberIds: selectedContact.memberIds,\n              members: selectedContact.members\n            })\n            throw new Error(\"Bạn không phải là thành viên của nhóm này\")\n          }\n\n          try {\n            response = await apiCall(\n              \"post\", \n              `/api/groups/${groupId}/messages`, \n              { content: messageToSend }, \n              token\n            )\n            \n            console.log(\"Group message API response:\", response)\n            \n            if (!response) {\n              throw new Error(\"No response from server\")\n            }\n\n            if (!response.messageData) {\n              console.error(\"Invalid response structure:\", response)\n              throw new Error(\"Invalid response structure from server\")\n            }\n            \n            const messageData = response.messageData\n            messageDataForSocket = {\n              messageId: messageData.messageId,\n              groupId: groupId,\n              senderId: user.id,\n              senderName: user.name,\n              content: messageToSend,\n              type: \"text\",\n              createdAt: messageData.createdAt || new Date().toISOString(),\n            }\n\n            console.log(\"Emitting socket event with data:\", messageDataForSocket)\n            socket.emit(\"group_message\", messageDataForSocket)\n\n            // Update optimistic message with real ID and remove sending state\n            setMessages((prev) =>\n              prev.map((msg) =>\n                msg.id === tempMessageId\n                  ? {\n                      ...msg,\n                      id: messageData.messageId,\n                      isSending: false,\n                      time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    }\n                  : msg\n              )\n            )\n          } catch (error) {\n            console.error(\"Error details:\", {\n              error,\n              groupId,\n              selectedContact,\n              user: { id: user.id, name: user.name }\n            })\n            \n            if (error.response?.status === 404) {\n              throw new Error(\"Không tìm thấy nhóm chat\")\n            } else if (error.response?.status === 403) {\n              throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\")\n            } else {\n              throw error\n            }\n          }\n        } else {\n          // Handle individual contact message sending\n          const conversationId = selectedContact.conversationId\n          if (!conversationId) {\n            throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\")\n          }\n          response = await apiCall(\n            \"post\",\n            \"/api/messages/send/text\",\n            { \n              conversationId: conversationId, \n              content: messageToSend,\n              tempMessageId: tempMessageId // Add tempMessageId to help match response\n            },\n            token\n          )\n          messageDataForSocket = {\n            messageId: response.messageData?.messageId || response.messageId,\n            tempMessageId: tempMessageId, // Include tempMessageId in socket event\n            conversationId: conversationId,\n            senderId: user.id,\n            senderName: user.name,\n            receiverId: selectedContact.id,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: response.messageData?.createdAt || new Date().toISOString(),\n            time: messageTime // Include original time for matching\n          }\n          socket.emit(\"new_message\", messageDataForSocket)\n        }\n      } catch (error) {\n        console.error(\"Error sending message:\", error)\n        showError(\"Không thể gửi tin nhắn: \" + error.message)\n        // Remove or mark optimistic message as failed\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n      }\n    },\n    [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(\n    async (file, fileType = \"file\") => {\n      // fileType can be 'file', 'image', 'video'\n      if (!file || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n      const maxSize = 50 * 1024 * 1024 // 50MB\n      if (file.size > maxSize) {\n        showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`)\n        return\n      }\n      if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n        showError(\"Chỉ chấp nhận file hình ảnh.\")\n        return\n      }\n      if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n        showError(\"Chỉ chấp nhận file video.\")\n        return\n      }\n\n      // Video duration check\n      let videoDuration = null\n      if (fileType === \"video\") {\n        try {\n          const duration = await getVideoDuration(file)\n          if (duration > 90) {\n            showError(\"Video không được dài quá 90 giây.\")\n            return\n          }\n          videoDuration = Math.round(duration)\n        } catch (err) {\n          showError(\"Không thể đọc thông tin video.\")\n          return\n        }\n      }\n\n      const tempMessageId = `temp-file-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      const tempUrl = URL.createObjectURL(file) // For optimistic UI\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: fileType === \"text\" ? file.name : tempUrl, // Use tempUrl for image/video\n        time: messageTime,\n        senderId: user.id,\n        isSending: true,\n        isFile: fileType === \"file\",\n        isImage: fileType === \"image\",\n        isVideo: fileType === \"video\",\n        fileName: file.name,\n        fileType: file.type,\n        duration: videoDuration,\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      scrollToBottom()\n\n      const formData = new FormData()\n      let apiUrl = \"\"\n      let apiKey = \"\" // Key for the file in FormData\n\n      if (selectedContact.type === \"group\") {\n        const groupId = selectedContact.groupId\n        formData.append(\"groupId\", groupId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = `/api/groups/${groupId}/images`\n            apiKey = \"image\" // Match backend key\n            break\n          case \"video\":\n            apiUrl = `/api/groups/${groupId}/videos`\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = `/api/groups/${groupId}/files`\n            apiKey = \"file\"\n            break\n        }\n      } else {\n        const conversationId = selectedContact.conversationId\n        if (!conversationId) {\n          showError(\"Không tìm thấy cuộc trò chuyện để gửi file\")\n          URL.revokeObjectURL(tempUrl)\n          setMessages((prev) => prev.filter((msg) => msg.id !== tempMessageId)) // Remove optimistic msg\n          return\n        }\n        formData.append(\"conversationId\", conversationId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = \"/api/messages/send/image\"\n            apiKey = \"images\" // Match backend key (plural for this endpoint)\n            break\n          case \"video\":\n            apiUrl = \"/api/messages/send/video\"\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = \"/api/messages/send/file\"\n            apiKey = \"file\"\n            break\n        }\n      }\n\n      formData.append(apiKey, file)\n\n      try {\n        const response = await apiCall(\"post\", apiUrl, formData, token)\n        const messageData = response.messageData || response // Adjust based on API response structure\n        const attachment = messageData.attachments?.[0]\n\n        if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n          throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\")\n        }\n\n        // Update optimistic message\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === tempMessageId\n              ? {\n                  ...msg,\n                  id: messageData.messageId,\n                  content: attachment.url, // Use final URL\n                  fileUrl: fileType === \"file\" ? attachment.url : null,\n                  isSending: false,\n                  time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                  }),\n                }\n              : msg,\n          ),\n        )\n\n        // Update media/documents list\n        const newItem = {\n          id: messageData.messageId,\n          type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n          url: attachment.url,\n          name: attachment.name || file.name,\n          date: new Date(messageData.createdAt).toLocaleDateString(),\n          size: attachment.size || file.size,\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        if (fileType === \"image\" || fileType === \"video\") {\n          setMediaFiles((prev) => [newItem, ...prev]) // Add to beginning (newest)\n        } else {\n          setDocuments((prev) => [newItem, ...prev])\n        }\n\n        // Emit socket event\n        const socketEventData = {\n          messageId: messageData.messageId,\n          conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n          groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n          type: fileType, // 'file', 'image', 'video'\n          content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null, // Content might be null for media\n          attachments: messageData.attachments,\n          createdAt: messageData.createdAt || new Date().toISOString(),\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\"\n        socket.emit(socketEventName, socketEventData)\n\n        URL.revokeObjectURL(tempUrl) // Clean up temp URL\n      } catch (error) {\n        console.error(`Error sending ${fileType}:`, error)\n        showError(`Không thể gửi ${fileType}: ${error.message}`)\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n        URL.revokeObjectURL(tempUrl)\n      }\n    },\n    [isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  const getVideoDuration = (file) => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\")\n      video.preload = \"metadata\"\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src)\n        resolve(video.duration)\n      }\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src)\n        reject(new Error(\"Không thể tải metadata video\"))\n      }\n      video.src = URL.createObjectURL(file)\n    })\n  }\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback((emoji) => {\n    setNewMessage((prev) => prev + emoji)\n    setShowEmojiPicker(false)\n  }, [])\n\n  const handleMessageAction = useCallback(\n    async (messageId, action) => {\n      if (action === \"delete\") {\n        const token = localStorage.getItem(\"token\")\n        if (!token || !selectedContact) return\n\n        // Optimistic UI update\n        const originalMessages = [...messages]\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === messageId ? { ...msg, content: \"Đang xóa...\", isUnsent: true, isDeleting: true } : msg,\n          ),\n        )\n\n        try {\n          if (selectedContact.type === \"group\") {\n            await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, null, token)\n          } else {\n            await apiCall(\"delete\", `/api/messages/${messageId}`, null, token)\n          }\n\n          // Confirm deletion in UI\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === messageId ? { ...msg, content: \"Tin nhắn đã bị xóa\", isDeleting: false } : msg,\n            ),\n          )\n\n          // Remove from media/documents lists\n          setMediaFiles((prev) => prev.filter((media) => media.id !== messageId))\n          setDocuments((prev) => prev.filter((doc) => doc.id !== messageId))\n\n          // TODO: Emit socket event for deletion if needed by backend/other clients\n        } catch (error) {\n          console.error(\"Error deleting message:\", error)\n          showError(\"Không thể xóa tin nhắn: \" + error.message)\n          // Revert optimistic update on error\n          setMessages(originalMessages)\n        }\n      }\n      // Handle other actions like 'recall' if implemented\n    },\n    [apiCall, selectedContact, showError, messages], // Include messages in dependency array\n  )\n\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true)\n    setShowFiles(false)\n  }, [])\n\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false)\n    setShowFiles(true)\n  }, [])\n\n  const handleTabChange = useCallback((tab) => {\n    setActiveTab(tab)\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchFriendRequests(token)\n      }\n    }\n  }, [fetchFriendRequests]) // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null,\n    })\n    setShowProfileModal(true)\n  }, [user.name, user.avatar]) // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false)\n  }, [])\n\n  const handleAvatarChange = useCallback(\n    async (file) => {\n      // File validation\n      if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n        showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\")\n        return\n      }\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const formData = new FormData()\n      formData.append(\"avatar\", file)\n\n      try {\n        setLoading(true) // Indicate loading\n        const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token)\n        // Update state optimistically/realistically\n        setProfileData((prev) => ({ ...prev, avatarUrl: response.avatarUrl }))\n        setUser((prev) => ({ ...prev, avatar: response.avatarUrl }))\n        // Update localStorage userProfile\n        const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n        userProfile.avatarUrl = response.avatarUrl\n        localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n        showError(\"Cập nhật ảnh đại diện thành công!\")\n      } catch (error) {\n        showError(\"Không thể tải avatar: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    try {\n      setLoading(true)\n      const response = await apiCall(\n        \"put\",\n        \"/api/users/profile\",\n        {\n          fullName: profileData.fullName,\n          // Ensure birthdate is sent correctly or omitted if empty\n          birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n          gender: profileData.gender || undefined, // Send undefined if empty to potentially clear it\n        },\n        token,\n      )\n      // Update user state\n      setUser((prev) => ({\n        ...prev,\n        name: response.fullName || prev.name,\n        // Avatar might not be in this response, keep existing one\n      }))\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      userProfile.fullName = response.fullName\n      userProfile.birthdate = response.birthdate\n      userProfile.gender = response.gender\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n\n      showError(\"Cập nhật hồ sơ thành công!\")\n      handleCloseProfileModal()\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message)\n    } finally {\n      setLoading(false)\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal])\n\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true)\n  }, [])\n\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false)\n    setFriendEmail(\"\") // Reset email field\n  }, [])\n\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\")\n      return\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\")\n      return\n    }\n\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    setLoading(true)\n    try {\n      // Search user first to get ID\n      const searchResult = await apiCall(\n        \"get\",\n        `/api/users/search?query=${encodeURIComponent(friendEmail)}`,\n        null,\n        token,\n      )\n      if (!searchResult?.data?.length) {\n        throw new Error(\"Không tìm thấy người dùng với email này\")\n      }\n      const receiverId = searchResult.data[0].userId\n\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\")\n      }\n\n      // Check if already friends\n      if (contacts.some((c) => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\")\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", { receiverId, message: `Kết bạn từ ${user.name}` }, token)\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`)\n      handleCloseAddFriendModal()\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`)\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`)\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`)\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`)\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false)\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts])\n\n  const handleRespondToFriendRequest = useCallback(\n    async (requestId, action) => {\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const request = friendRequests.find((req) => req.requestId === requestId)\n      if (!request) return\n\n      setLoading(true) // Indicate processing\n      // Optimistically remove from list\n      setFriendRequests((prev) => prev.filter((req) => req.requestId !== requestId))\n\n      try {\n        const response = await apiCall(\"post\", \"/api/friends/requests/respond\", { requestId, action }, token)\n        console.log(\"Friend request response:\", response)\n\n        if (action === \"accept\") {\n          showError(\"Đã chấp nhận lời mời kết bạn\")\n          const senderInfo = request.sender\n          if (!senderInfo || !senderInfo.userId) {\n            throw new Error(\"Thông tin người gửi không hợp lệ\")\n          }\n\n          // Get conversation ID (might be in response or need creation)\n          let conversationId = response.conversation?.conversationId\n          if (!conversationId) {\n            console.log(\"No conversationId in response, creating/getting...\")\n            conversationId = await createOrGetConversation(senderInfo.userId, token)\n          }\n\n          if (!conversationId) {\n            throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\")\n          }\n\n          // Create new contact object\n          const newContact = {\n            id: senderInfo.userId,\n            name: senderInfo.fullName || senderInfo.email?.split(\"@\")[0] || \"Unknown\",\n            avatar: senderInfo.avatarUrl || \"\",\n            type: \"contact\",\n            status: \"Bạn bè\",\n            conversationId: conversationId,\n          }\n\n          addOrUpdateContact(newContact) // Add/update contact list and localStorage\n\n          // Optionally select the new contact immediately\n          // handleContactSelect(newContact);\n\n          // Emit notification to the sender via socket\n          if (socket.connected) {\n            socket.emit(\"friend_request_accepted_notify\", {\n              accepter: { userId: user.id, fullName: user.name, avatarUrl: user.avatar },\n              senderId: senderInfo.userId, // Target the sender\n              conversationId: conversationId,\n            })\n            // Also tell sender to refresh their list\n            socket.emit(\"refresh_contacts_notify\", { targetUserId: senderInfo.userId })\n            console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\")\n          }\n        } else {\n          showError(\"Đã từ chối lời mời kết bạn\")\n          // Optionally notify sender of rejection via socket\n        }\n      } catch (error) {\n        console.error(\"Error responding to friend request:\", error)\n        showError(\"Không thể phản hồi lời mời: \" + error.message)\n        // Revert optimistic removal on error\n        setFriendRequests((prev) => [...prev, request])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user],\n  )\n\n  const handleRemoveFriend = useCallback(\n    async (friendId) => {\n      if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      console.log(`Attempting to remove friend with ID: ${friendId}`)\n      setLoading(true)\n\n      // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n      const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\")\n      if (!contactToRemove) {\n        showError(\"Không tìm thấy người dùng trong danh sách bạn bè\")\n        setLoading(false)\n        return\n      }\n\n      // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n      const currentContacts = [...contacts]\n\n      try {\n        // Cập nhật UI trước khi gọi API (optimistic update)\n        setContacts((prev) => prev.filter((contact) => contact.id !== friendId || contact.type !== \"contact\"))\n\n        // Cập nhật localStorage\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const updatedContacts = savedContacts.filter((c) => c.id !== friendId || c.type !== \"contact\")\n          localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts))\n        } catch (e) {\n          console.error(\"Error updating localStorage after friend removal\", e)\n        }\n\n        // Bỏ chọn nếu đang được chọn\n        if (selectedContact?.id === friendId && selectedContact?.type === \"contact\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        // Gọi API để xóa bạn bè\n        try {\n          console.log(`Calling API to remove friend: ${friendId}`)\n          const response = await apiCall(\"delete\", `/api/friends/${friendId}`, null, token)\n          console.log(\"Friend removal API response:\", response)\n\n          showError(\"Đã xóa bạn bè thành công\")\n\n          // Thông báo cho người bạn bị xóa qua socket\n          if (socket && socket.connected) {\n            socket.emit(\"friend_removed_notify\", { removerId: user.id, removedUserId: friendId })\n            console.log(\"Emitted friend_removed_notify\")\n\n            // Thông báo cập nhật danh sách bạn bè\n            socket.emit(\"friend_list_updated\")\n          }\n\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token)\n        } catch (apiError) {\n          console.error(\"API error removing friend:\", apiError)\n\n          // Kiểm tra lỗi cụ thể\n          if (apiError.response && apiError.response.status === 404) {\n            // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n            showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\")\n            // Cập nhật lại danh sách bạn bè từ server\n            fetchContactsAndGroups(token)\n          } else {\n            // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n            showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"))\n            // Khôi phục lại danh sách bạn bè\n            setContacts(currentContacts)\n\n            // Khôi phục localStorage\n            try {\n              localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n            } catch (e) {\n              console.error(\"Error restoring localStorage\", e)\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error in handleRemoveFriend:\", error)\n        showError(\"Không thể xóa bạn bè: \" + error.message)\n\n        // Khôi phục lại danh sách bạn bè\n        setContacts(currentContacts)\n\n        // Khôi phục localStorage\n        try {\n          localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n        } catch (e) {\n          console.error(\"Error restoring localStorage\", e)\n        }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups],\n  )\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true)\n  }, [])\n\n  const handleGroupCreated = useCallback(\n    (newGroupData) => {\n      console.log(\"Group created data:\", newGroupData)\n      const groupObject = {\n        groupId: newGroupData.groupId,\n        id: newGroupData.groupId, // Add id for consistency\n        name: newGroupData.name,\n        avatar: newGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: newGroupData.adminId,\n        memberCount: newGroupData.members?.length || 1, // At least admin is a member\n        conversationId: newGroupData.conversationId || newGroupData.groupId,\n        createdAt: newGroupData.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      setShowCreateGroupModal(false)\n      showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`)\n      // Automatically select the new group\n      handleContactSelect(groupObject)\n    },\n    [addOrUpdateGroup, showError, handleContactSelect],\n  )\n\n  const handleGroupInfo = useCallback(\n    (group) => {\n      // Fetch full group details if necessary before showing modal\n      setSelectedGroup(group) // Pass the basic group info for now\n      setShowGroupInfoModal(true)\n      // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n    },\n    [], // No dependencies needed to just show the modal\n  )\n\n  const handleGroupUpdated = useCallback(\n    (updatedGroupData) => {\n      console.log(\"Group updated data:\", updatedGroupData)\n      // Ensure the data structure matches what addOrUpdateGroup expects\n      const groupObject = {\n        groupId: updatedGroupData.groupId,\n        id: updatedGroupData.groupId,\n        name: updatedGroupData.name,\n        avatar: updatedGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: updatedGroupData.adminId,\n        memberCount: updatedGroupData.memberCount || updatedGroupData.members?.length || 0,\n        conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n        createdAt: updatedGroupData.createdAt,\n        // Include other relevant fields if needed\n      }\n      addOrUpdateGroup(groupObject)\n      // Update selected contact if it's the one being edited\n      if (selectedContact?.id === groupObject.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n      setShowGroupInfoModal(false) // Close modal on success\n      showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`)\n    },\n    [addOrUpdateGroup, selectedContact, showError],\n  )\n\n  const handleLeaveGroup = useCallback(\n    async (groupId) => {\n      console.log(\"Leaving group:\", groupId)\n\n      if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      setLoading(true)\n\n      try {\n        // Gọi API để rời nhóm\n        const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, null, token)\n        console.log(\"Leave group API response:\", response)\n\n        // Cập nhật UI sau khi API thành công\n        setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n\n        // Cập nhật localStorage\n        try {\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n          const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n        } catch (e) {\n          console.error(\"Error updating localStorage after leaving group\", e)\n        }\n\n        // Bỏ chọn nhóm nếu đang được chọn\n        if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        setShowGroupInfoModal(false) // Đóng modal\n        showError(\"Bạn đã rời khỏi nhóm thành công\")\n\n        // Thông báo qua socket nếu cần\n        if (socket.connected) {\n          socket.emit(\"left_group\", { groupId })\n        }\n      } catch (error) {\n        console.error(\"Error leaving group:\", error)\n        showError(\"Không thể rời khỏi nhóm: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [selectedContact, showError, apiCall],\n  )\n\n  const handleDeleteGroup = useCallback(\n    (groupId) => {\n      console.log(\"Deleting group:\", groupId)\n      setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch (e) {\n        console.error(\"Error updating localStorage after deleting group\", e)\n      }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n      setShowGroupInfoModal(false) // Close modal\n      showError(\"Đã xóa nhóm thành công\")\n      // API call to delete group should be handled within GroupInfoModal or here before state update\n    },\n    [selectedContact, showError],\n  )\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) {\n      navigate(\"/login\")\n      return\n    }\n\n    let isMounted = true // Flag to prevent state updates on unmounted component\n    let socketInitialized = false\n\n    const initializeApp = async () => {\n      try {\n        setLoading(true)\n        const userProfile = await fetchUserProfile(token)\n        if (!userProfile || !isMounted) return // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token)\n        if (!isMounted) return\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token)\n        if (!isMounted) return\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\")\n          \n          // Set socket auth and query params\n          socket.auth = { token }\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now(),\n          }\n\n          // Connect the socket\n          socket.connect()\n          socketInitialized = true\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error)\n      } finally {\n        if (isMounted) {\n          setLoading(false)\n        }\n      }\n    }\n\n    initializeApp()\n\n    // Cleanup function\n    return () => {\n      isMounted = false\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\")\n      socket.off(\"reconnect\")\n      socket.off(\"friend_request\")\n      socket.off(\"new_message\")\n      socket.off(\"receive_message\")\n      socket.off(\"group_message\")\n      socket.off(\"friend_request_accepted\")\n      socket.off(\"friend_removed\")\n      socket.off(\"refresh_contacts\")\n      socket.off(\"notification\")\n      socket.off(\"group_created\")\n      socket.off(\"group_updated\")\n      socket.off(\"group_deleted\")\n      socket.off(\"member_added\")\n      socket.off(\"member_removed\")\n    }\n  }, [navigate]) // Only depend on navigate\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback((data) => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || (!data.messageId && !data.id)) {\n      console.error(\"Invalid message data received:\", data)\n      return\n    }\n\n    const messageTime = data.createdAt\n      ? new Date(data.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      : new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString()\n\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact?.type,\n      selectedContactGroupId: selectedContact?.groupId,\n      selectedContactConversationId: selectedContact?.conversationId\n    });\n\n    const isCurrentChat =\n      (selectedContact?.type === \"group\" && selectedContact.groupId === data.groupId) ||\n      (selectedContact?.type === \"contact\" && selectedContact.conversationId === data.conversationId)\n\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content:\n        data.isRecalled || data.isDeleted\n          ? \"Tin nhắn đã bị thu hồi/xóa\"\n          : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\"\n            ? data.content\n            : data.attachments?.[0]?.url || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: data.type === \"image\" || data.type === \"imageGroup\",\n      isVideo: data.type === \"video\",\n      isFile: data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: data.type === \"file\" ? data.attachments?.[0]?.url : null,\n      fileName: data.type === \"file\" ? data.attachments?.[0]?.name : null,\n      fileType: data.type === \"file\" ? data.attachments?.[0]?.type : null,\n      duration: data.type === \"video\" ? data.attachments?.[0]?.duration || data.duration : null,\n      messageDate: messageDate,\n    }\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || []\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev\n        return { ...prev, [data.conversationId]: [...prevList, newMessage] }\n      })\n    }\n\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id)\n        if (exists) return prev\n        return [...prev, newMessage]\n      })\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n            duration: newMessage.duration,\n          },\n          ...prev, // Add to beginning\n        ])\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n          },\n          ...prev, // Add to beginning\n        ])\n      }\n    } else {\n      // Notification for message in other chat\n      let senderName = \"Người dùng\"\n      let contactId = data.senderId // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find((g) => g.groupId === data.groupId)\n        senderName = `${data.senderName || \"Ai đó\"} (${group?.name || \"Nhóm\"})`\n      } else {\n        const contact = contacts.find((c) => c.id === data.senderId) // Tìm contact dựa trên senderId\n        senderName = contact?.name || data.senderName || \"Ai đó\"\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n\n      const preview =\n        data.type === \"text\"\n          ? data.content?.substring(0, 30) + (data.content?.length > 30 ? \"...\" : \"\")\n          : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`)\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview, // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(\n          c => c.conversationId === data.conversationId || c.id === data.senderId\n        )\n        if (foundContact) {\n          setSelectedContact(foundContact)\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || [])\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      const contactName = data.senderName || \"Người dùng\"\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: contacts.find((c) => c.id === data.senderId)?.avatar || groups.find(g => g.groupId === data.groupId)?.avatar || \"/favicon.ico\", // Optional icon\n      })\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages])\n\n  const handleFriendRequest = useCallback((data) => {\n    if (!data || !data.requestId || !data.sender) return\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab])\n\n  const handleFriendRequestAccepted = useCallback((data) => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\")\n      return\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user])\n\n  const handleFriendRemoved = useCallback((data) => {\n    if (!data || !data.removerId) return\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError])\n\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\")\n    if (token) {\n      fetchContactsAndGroups(token)\n    }\n  }, [fetchContactsAndGroups])\n\n  const handleSocketGroupCreated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_created event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.members?.length || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`)\n  }, [addOrUpdateGroup, showError])\n\n  const handleSocketGroupUpdated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_updated event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`)\n  }, [addOrUpdateGroup, selectedContact, showError])\n\n  const handleGroupDeleted = useCallback((data) => {\n    if (!data?.groupId) return\n    console.log(\"Received group_deleted event:\", data.groupId)\n    const groupName = groups.find(g => g.groupId === data.groupId)?.name || \"Một nhóm\"\n    setGroups((prev) => prev.filter((group) => group.groupId !== data.groupId))\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n      const updatedGroups = savedGroups.filter((g) => g.groupId !== data.groupId)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n    } catch (e) { console.error(\"Error updating localStorage after group delete\", e) }\n\n    if (selectedContact?.id === data.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(null)\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`)\n  }, [groups, selectedContact, showError])\n\n  const handleMemberAdded = useCallback((data) => {\n    if (!data?.group || !data?.member || !data?.addedBy) return\n    console.log(\"Received member_added event:\", data)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`)\n    }\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleMemberRemoved = useCallback((data) => {\n    if (!data?.group || !data?.memberId || !data?.removedBy) return\n    console.log(\"Received member_removed event:\", data)\n    const group = data.group\n    const groupId = group.groupId\n\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`)\n      setGroups((prev) => prev.filter((g) => g.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch(e) { console.error(\"Error updating localStorage after being removed from group\", e) }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n    } else {\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || group.members?.length || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      const memberName = data.member?.fullName || \"một thành viên\"\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`)\n      if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleNotification = useCallback((data) => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data)\n      return\n    }\n    if (data.type === \"success\") {\n      showError(data.message)\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\")\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\")\n    } else {\n      showError(data.message)\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchContactsAndGroups(token)\n      }\n    }\n  }, [showError, fetchContactsAndGroups])\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true\n\n    const handleConnect = () => {\n      if (!isMounted) return\n      console.log(\"Socket re-connected inside hook.\")\n      setIsConnected(true)\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId)\n      }\n    }\n\n    // Add handler for message_sent event\n    const handleMessageSent = (data) => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data)\n        return\n      }\n      console.log(\"Received message_sent_success event:\", data)\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n          // Match by tempMessageId if available\n          (data.tempMessageId && msg.id === data.tempMessageId) ||\n          // Or match by conversationId and content if tempMessageId not available\n          (data.conversationId && msg.conversationId === data.conversationId && \n           msg.content === data.content)\n        )) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          })\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          }\n        }\n        return msg\n      }))\n    }\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect)\n    socket.on(\"message_sent_success\", handleMessageSent) // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage)\n    socket.on(\"receive_message\", handleNewMessage)\n    socket.on(\"group_message\", handleNewMessage)\n    socket.on(\"friend_request\", handleFriendRequest)\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted)\n    socket.on(\"friend_removed\", handleFriendRemoved)\n    socket.on(\"refresh_contacts\", handleRefreshContacts)\n    socket.on(\"notification\", handleNotification)\n    socket.on(\"group_created\", handleSocketGroupCreated)\n    socket.on(\"group_updated\", handleSocketGroupUpdated)\n    socket.on(\"group_deleted\", handleGroupDeleted)\n    socket.on(\"member_added\", handleMemberAdded)\n    socket.on(\"member_removed\", handleMemberRemoved)\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false\n      socket.off(\"connect\", handleConnect)\n      socket.off(\"message_sent_success\", handleMessageSent) // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage)\n      socket.off(\"receive_message\", handleNewMessage)\n      socket.off(\"group_message\", handleNewMessage)\n      socket.off(\"friend_request\", handleFriendRequest)\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted)\n      socket.off(\"friend_removed\", handleFriendRemoved)\n      socket.off(\"refresh_contacts\", handleRefreshContacts)\n      socket.off(\"notification\", handleNotification)\n      socket.off(\"group_created\", handleSocketGroupCreated)\n      socket.off(\"group_updated\", handleSocketGroupUpdated)\n      socket.off(\"group_deleted\", handleGroupDeleted)\n      socket.off(\"member_added\", handleMemberAdded)\n      socket.off(\"member_removed\", handleMemberRemoved)\n    }\n  }, [\n    handleNewMessage,\n    handleFriendRequest,\n    handleFriendRequestAccepted,\n    handleFriendRemoved,\n    handleRefreshContacts,\n    handleNotification,\n    handleSocketGroupCreated,\n    handleSocketGroupUpdated,\n    handleGroupDeleted,\n    handleMemberAdded,\n    handleMemberRemoved,\n    selectedContact // Add selectedContact as dependency\n  ])\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages]) // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n        messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }, 100);\n  }\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(\n    (contact) => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n  const filteredGroups = groups.filter(\n    (group) => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"] // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts, // Return full contacts list if needed elsewhere\n    groups,   // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab, // Needed for friend request notification\n    setShowProfileModal, // Needed for closing modal from component\n    setProfileData, // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal, // Needed for closing modal from component\n    setFriendEmail, // Needed for form input\n    // setError, // Internal state\n    setShowToast, // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal, // Needed for closing modal from component\n    setShowGroupInfoModal, // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile, // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError, // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"), // Pass token for Modals\n  }\n}\n\nexport default useChat\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}