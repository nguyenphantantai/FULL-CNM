{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport axios from \"axios\";\nimport { io } from \"socket.io-client\";\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\";\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false,\n  // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false,\n  // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now()\n  }\n});\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id);\n});\nsocket.on(\"connect_error\", err => {\n  console.error(\"Socket connection error:\", err);\n});\nsocket.on(\"disconnect\", reason => {\n  console.log(\"Socket disconnected:\", reason);\n});\nsocket.on(\"error\", err => {\n  console.error(\"Socket error:\", err);\n});\nsocket.on(\"reconnect_error\", err => {\n  console.error(\"Socket reconnection error:\", err);\n});\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error;\n  console.error = (...args) => {\n    if (args[0] && typeof args[0] === \"string\" && (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))) {\n      return;\n    }\n    originalConsoleError.apply(console, args);\n  };\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  _s();\n  const navigate = useNavigate();\n\n  // State Management\n  const [user, setUser] = useState({\n    id: \"\",\n    name: \"User\",\n    avatar: \"\"\n  });\n  const [contacts, setContacts] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [selectedContact, setSelectedContact] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [newMessage, setNewMessage] = useState(\"\");\n  const [isConnected, setIsConnected] = useState(socket.connected); // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [mediaFiles, setMediaFiles] = useState([]);\n  const [documents, setDocuments] = useState([]);\n  const [showMedia, setShowMedia] = useState(true);\n  const [showFiles, setShowFiles] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"chat\");\n  const [showProfileModal, setShowProfileModal] = useState(false);\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null\n  });\n  const [loading, setLoading] = useState(false);\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false);\n  const [friendEmail, setFriendEmail] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [showToast, setShowToast] = useState(false);\n  const [friendRequests, setFriendRequests] = useState([]);\n  const [recoveredContacts, setRecoveredContacts] = useState([]); // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({});\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const imageInputRef = useRef(null);\n  const videoInputRef = useRef(null);\n\n  // Thêm state cho danh sách emoji có thể reaction\n  const reactionEmojis = [\"👍\", \"❤️\", \"😂\", \"😢\", \"🙏\", \"🎉\"]; // Danh sách emoji react\n\n  // --- Utility Functions ---\n\n  const showError = useCallback(message => {\n    console.log(\"Showing Toast:\", message);\n    setError(message);\n    setShowToast(true);\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, []);\n  const apiCall = useCallback(async (method, url, data = null, token) => {\n    try {\n      console.log(`API Call: ${method.toUpperCase()} ${url}`);\n      if (data) {\n        console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data);\n      }\n      const config = {\n        method,\n        url: `${API_BASE_URL}${url}`,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n          \"If-None-Match\": \"\" // Prevent 304 responses\n        },\n        data\n      };\n      if (!(data instanceof FormData)) {\n        config.headers[\"Content-Type\"] = \"application/json\";\n      }\n      console.log(\"Using config:\", {\n        method: config.method,\n        url: config.url,\n        headers: {\n          ...config.headers,\n          Authorization: \"Bearer [HIDDEN]\"\n        }\n      });\n      const response = await axios(config);\n      console.log(`API Response ${url}:`, response.status, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response2$data;\n      console.error(`API Error ${url}:`, error);\n      if (error.response) {\n        console.error(\"Response status:\", error.response.status);\n        console.error(\"Response data:\", error.response.data);\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"userProfile\"); // Clear profile too\n        navigate(\"/login\");\n        // Use showError for consistency\n        showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\");\n        throw new Error(\"Phiên đăng nhập hết hạn.\"); // Throw to stop further execution\n      }\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message || \"Đã xảy ra lỗi không xác định\";\n      // Don't automatically show toast here, let the calling function decide\n      // showError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [navigate, showError]); // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback(newContact => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact);\n      return;\n    }\n    console.log(\"Adding or updating contact:\", newContact);\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\");\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : [];\n      contactsArray = contactsArray.filter(c => c.id !== newContact.id);\n      contactsArray.push(newContact);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray));\n      console.log(\"Saved contact to localStorage:\", newContact.id);\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError);\n    }\n    setContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts(prev => {\n      const exists = prev.some(contact => contact.id === newContact.id);\n      if (exists) {\n        return prev.map(contact => contact.id === newContact.id ? {\n          ...contact,\n          ...newContact\n        } : contact);\n      }\n      return [...prev, newContact];\n    });\n  }, []);\n  const addOrUpdateGroup = useCallback(newGroup => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup);\n      return;\n    }\n    console.log(\"Adding or updating group:\", newGroup);\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\");\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : [];\n      groupsArray = groupsArray.filter(g => g.groupId !== newGroup.groupId);\n      groupsArray.push(newGroup);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray));\n      console.log(\"Saved group to localStorage:\", newGroup.groupId);\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError);\n    }\n    setGroups(prev => {\n      const exists = prev.some(group => group.groupId === newGroup.groupId);\n      if (exists) {\n        return prev.map(group => group.groupId === newGroup.groupId ? {\n          ...group,\n          ...newGroup\n        } : group);\n      }\n      return [...prev, newGroup];\n    });\n  }, []);\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(async token => {\n    try {\n      const response = await apiCall(\"get\", \"/api/users/profile\", null, token);\n      const userData = {\n        id: response.userId,\n        name: response.fullName || \"User\",\n        avatar: response.avatarUrl || \"\"\n      };\n      setUser(userData);\n      setProfileData({\n        fullName: response.fullName || \"\",\n        birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n        gender: response.gender || \"\",\n        avatarUrl: response.avatarUrl || null\n      });\n      // Save profile to localStorage after fetching\n      localStorage.setItem(\"userProfile\", JSON.stringify(response));\n      return response; // Return the full profile\n    } catch (error) {\n      console.error(\"Error fetching user profile:\", error);\n      showError(\"Không thể lấy thông tin người dùng: \" + error.message);\n      // No need to navigate here, apiCall handles 401\n      return null;\n    }\n  }, [apiCall, showError]);\n  const fetchMessages = useCallback(async (token, conversationId, isGroup = false) => {\n    if (!token || !conversationId) {\n      console.warn(\"fetchMessages called without token or conversationId\");\n      setMessages([]); // Clear messages if no ID\n      setMediaFiles([]);\n      setDocuments([]);\n      return;\n    }\n    setLoading(true); // Indicate loading messages\n    try {\n      let response;\n      // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n      const endpoint = `/api/messages/conversations/${conversationId}/messages`;\n      console.log(\"Fetching messages from endpoint:\", endpoint);\n      response = await apiCall(\"get\", endpoint, null, token);\n      console.log(\"Messages API response:\", response);\n      const messagesData = Array.isArray(response) ? response : response.data || [];\n      const mappedMessages = messagesData.map((msg, index) => {\n        var _msg$attachments, _msg$attachments$, _msg$attachments2, _msg$attachments$2, _msg$attachments3, _msg$attachments$3, _msg$attachments4, _msg$attachments$4, _msg$attachments5, _msg$attachments$5;\n        return {\n          id: msg.messageId || `temp-${Date.now()}-${index}`,\n          sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n          content: msg.isDeleted ? \"Tin nhắn đã bị xóa\" : msg.isRecalled ? \"Tin nhắn đã bị thu hồi/xóa\" : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\" ? msg.content : ((_msg$attachments = msg.attachments) === null || _msg$attachments === void 0 ? void 0 : (_msg$attachments$ = _msg$attachments[0]) === null || _msg$attachments$ === void 0 ? void 0 : _msg$attachments$.url) || msg.content || \"\",\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          senderId: msg.senderId,\n          isImage: !msg.isDeleted && (msg.type === \"image\" || msg.type === \"imageGroup\"),\n          isVideo: !msg.isDeleted && msg.type === \"video\",\n          isFile: !msg.isDeleted && msg.type === \"file\",\n          isUnsent: msg.isRecalled || msg.isDeleted,\n          isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n          fileUrl: !msg.isDeleted && msg.type === \"file\" && ((_msg$attachments2 = msg.attachments) === null || _msg$attachments2 === void 0 ? void 0 : _msg$attachments2.length) > 0 ? (_msg$attachments$2 = msg.attachments[0]) === null || _msg$attachments$2 === void 0 ? void 0 : _msg$attachments$2.url : null,\n          fileName: !msg.isDeleted && msg.type === \"file\" && ((_msg$attachments3 = msg.attachments) === null || _msg$attachments3 === void 0 ? void 0 : _msg$attachments3.length) > 0 ? (_msg$attachments$3 = msg.attachments[0]) === null || _msg$attachments$3 === void 0 ? void 0 : _msg$attachments$3.name : null,\n          fileType: !msg.isDeleted && msg.type === \"file\" && ((_msg$attachments4 = msg.attachments) === null || _msg$attachments4 === void 0 ? void 0 : _msg$attachments4.length) > 0 ? (_msg$attachments$4 = msg.attachments[0]) === null || _msg$attachments$4 === void 0 ? void 0 : _msg$attachments$4.type : null,\n          duration: !msg.isDeleted && msg.type === \"video\" && ((_msg$attachments5 = msg.attachments) === null || _msg$attachments5 === void 0 ? void 0 : _msg$attachments5.length) > 0 ? (_msg$attachments$5 = msg.attachments[0]) === null || _msg$attachments$5 === void 0 ? void 0 : _msg$attachments$5.duration : null,\n          messageDate: new Date().toLocaleDateString(),\n          reactions: msg.reactions || [] // Thêm trường reactions\n        };\n      }).filter(msg => msg.id); // Filter out messages without an ID\n\n      // Add system message if needed\n      if (mappedMessages.length === 0 || !mappedMessages.some(msg => msg.isSystemMessage)) {\n        const systemMessage = isGroup ? \"Chào mừng bạn đến với nhóm chat!\" : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\";\n        mappedMessages.unshift({\n          id: `system-${Date.now()}`,\n          senderId: \"system\",\n          content: systemMessage,\n          time: new Date().toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n          }),\n          isSystemMessage: true\n        });\n      }\n\n      // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n      let mergedMessages = mappedMessages;\n      // Lấy cache mới nhất từ localStorage thay vì chỉ lấy từ state\n      const cacheFromStorage = JSON.parse(localStorage.getItem('cachedMessages') || '{}');\n      const cacheList = cacheFromStorage[conversationId] || [];\n      console.log('Cache for this conversation:', cacheList);\n      const newFromCache = cacheList.filter(cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id));\n      mergedMessages = [...mappedMessages, ...newFromCache];\n      // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n      mergedMessages.sort((a, b) => {\n        const aTime = new Date(a.createdAt || a.time || a.messageDate);\n        const bTime = new Date(b.createdAt || b.time || b.messageDate);\n        return aTime - bTime;\n      });\n      console.log('Merged messages after cache merge:', mergedMessages);\n      setMessages(mergedMessages);\n\n      // Update Media and Documents\n      const media = mappedMessages.filter(msg => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content).map(msg => {\n        var _msg$attachments6, _msg$attachments6$;\n        return {\n          id: msg.id,\n          type: msg.isImage ? \"image\" : \"video\",\n          url: msg.content,\n          name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n          date: msg.messageDate,\n          size: ((_msg$attachments6 = msg.attachments) === null || _msg$attachments6 === void 0 ? void 0 : (_msg$attachments6$ = _msg$attachments6[0]) === null || _msg$attachments6$ === void 0 ? void 0 : _msg$attachments6$.size) || 0,\n          // Might not be available, default to 0\n          duration: msg.duration\n        };\n      });\n      setMediaFiles(media.reverse()); // Show newest first\n\n      const files = mappedMessages.filter(msg => msg.isFile && !msg.isUnsent && msg.fileUrl).map(msg => {\n        var _msg$fileName, _msg$attachments7, _msg$attachments7$;\n        return {\n          id: msg.id,\n          type: ((_msg$fileName = msg.fileName) === null || _msg$fileName === void 0 ? void 0 : _msg$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n          url: msg.fileUrl,\n          name: msg.fileName,\n          date: msg.messageDate,\n          size: ((_msg$attachments7 = msg.attachments) === null || _msg$attachments7 === void 0 ? void 0 : (_msg$attachments7$ = _msg$attachments7[0]) === null || _msg$attachments7$ === void 0 ? void 0 : _msg$attachments7$.size) || 0\n        };\n      });\n      setDocuments(files.reverse()); // Show newest first\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      showError(\"Không thể tải tin nhắn: \" + error.message);\n      setMessages([]); // Clear messages on error\n      setMediaFiles([]);\n      setDocuments([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id, cachedMessages] // Depend on user.id and cachedMessages\n  );\n  const fetchContactsAndGroups = useCallback(async token => {\n    if (!token) return {\n      contacts: [],\n      groups: []\n    };\n    setLoading(true);\n    let fetchedContacts = [];\n    let fetchedGroups = [];\n    try {\n      // Fetch Friends (Contacts) from server first\n      console.log(\"Fetching friends from server...\");\n      const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token);\n      console.log(\"Friends API response:\", friendsResponse);\n\n      // Lọc ra những người bạn đã được xác nhận\n      // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n      const confirmedFriends = (friendsResponse === null || friendsResponse === void 0 ? void 0 : friendsResponse.friends) || [];\n      console.log(\"Confirmed friends:\", confirmedFriends);\n\n      // Kiểm tra xem danh sách bạn bè có hợp lệ không\n      const validFriends = confirmedFriends.filter(friend => friend && friend.userId && friend.friendshipId);\n      if (validFriends.length !== confirmedFriends.length) {\n        console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`);\n      }\n      const mappedFriends = validFriends.map(friend => {\n        var _friend$email;\n        return {\n          id: friend.userId,\n          name: friend.fullName || ((_friend$email = friend.email) === null || _friend$email === void 0 ? void 0 : _friend$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          // Trạng thái mặc định\n          friendshipId: friend.friendshipId,\n          // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null // Will be populated later\n        };\n      });\n\n      // Fetch Conversations to get conversation IDs\n      console.log(\"Fetching conversations...\");\n      const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token);\n      const conversationsMap = new Map();\n      if (convResponse && Array.isArray(convResponse)) {\n        convResponse.forEach(conv => {\n          if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n            const otherUserId = conv.participants.find(id => id !== user.id);\n            if (otherUserId) {\n              conversationsMap.set(otherUserId, conv.conversationId);\n            }\n          }\n        });\n      }\n\n      // Update conversationId for mapped friends\n      mappedFriends.forEach(friend => {\n        if (conversationsMap.has(friend.id)) {\n          friend.conversationId = conversationsMap.get(friend.id);\n        }\n      });\n\n      // Merge with existing contacts to preserve any additional data\n      const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n\n      // Create a map of existing contacts for quick lookup\n      const existingContactsMap = new Map();\n      savedContacts.forEach(contact => {\n        if (contact && contact.id) {\n          existingContactsMap.set(contact.id, contact);\n        }\n      });\n\n      // Merge server data with existing data, prioritizing server data\n      fetchedContacts = mappedFriends.map(friend => {\n        const existingContact = existingContactsMap.get(friend.id);\n        if (existingContact) {\n          // Preserve conversationId if it exists in saved contact but not in server data\n          if (!friend.conversationId && existingContact.conversationId) {\n            friend.conversationId = existingContact.conversationId;\n          }\n          return {\n            ...existingContact,\n            ...friend\n          };\n        }\n        return friend;\n      });\n\n      // Update state and localStorage\n      setContacts(fetchedContacts);\n      localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts));\n      console.log(\"Updated contacts from API:\", fetchedContacts.length);\n\n      // Fetch Groups\n      console.log(\"Fetching groups...\");\n      const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token);\n      console.log(\"Groups API response:\", groupsResponse);\n      if (groupsResponse && groupsResponse.groups) {\n        // Lọc các nhóm mà người dùng là thành viên\n        const userGroups = groupsResponse.groups.filter(group => group.members && group.members.some(member => member.userId === user.id));\n        console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`);\n        fetchedGroups = userGroups.map(group => {\n          var _group$members, _group$members2;\n          return {\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [],\n            // Lưu toàn bộ thông tin thành viên\n            memberIds: ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.map(member => member.userId)) || [],\n            // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || ((_group$members2 = group.members) === null || _group$members2 === void 0 ? void 0 : _group$members2.length) || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt\n          };\n        });\n        setGroups(fetchedGroups);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups));\n        console.log(\"Updated groups from API:\", fetchedGroups.length);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } catch (error) {\n      console.error(\"Error fetching contacts/groups:\", error);\n      showError(\"Không thể tải danh bạ/nhóm: \" + error.message);\n\n      // Fallback to localStorage only if server fetch fails\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        if (savedContacts.length > 0) {\n          console.log(\"Falling back to contacts from localStorage\");\n          setContacts(savedContacts);\n          fetchedContacts = savedContacts;\n        }\n        if (savedGroups.length > 0) {\n          console.log(\"Falling back to groups from localStorage\");\n          setGroups(savedGroups);\n          fetchedGroups = savedGroups;\n        }\n      } catch (e) {\n        console.error(\"Error reading contacts/groups from localStorage\", e);\n      }\n      return {\n        contacts: fetchedContacts,\n        groups: fetchedGroups\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, user.id] // Depend on user.id for conversation mapping\n  );\n  const fetchFriendRequests = useCallback(async token => {\n    if (!token) return;\n    // No need for setLoading(true) here unless it's a primary action\n    try {\n      const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token);\n      setFriendRequests(response.data || []);\n    } catch (error) {\n      console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error);\n      // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n    }\n  }, [apiCall]);\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(async (otherUserId, token) => {\n    console.log(`Creating/getting conversation with user: ${otherUserId}`);\n    if (!token || !otherUserId) {\n      throw new Error(\"Token or otherUserId missing for createOrGetConversation\");\n    }\n    try {\n      var _response$conversatio;\n      const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token);\n      if (response !== null && response !== void 0 && (_response$conversatio = response.conversation) !== null && _response$conversatio !== void 0 && _response$conversatio.conversationId) {\n        console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId);\n        return response.conversation.conversationId;\n      } else {\n        throw new Error(\"Invalid response structure from conversation API\");\n      }\n    } catch (error) {\n      console.error(\"Error in createOrGetConversation:\", error);\n      if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n        throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\");\n      }\n      throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`); // Rethrow with context\n    }\n  }, [apiCall]);\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(async contactOrGroup => {\n    if (!contactOrGroup || contactOrGroup.id === (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id)) {\n      console.log(\"Selection unchanged or invalid.\");\n      return; // Avoid re-selecting the same contact/group\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      navigate(\"/login\");\n      return;\n    }\n    console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id);\n\n    // Leave previous room\n    if (selectedContact) {\n      const roomToLeave = selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId;\n      if (roomToLeave) {\n        const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\";\n        socket.emit(eventName, roomToLeave);\n        console.log(`Left ${selectedContact.type} room:`, roomToLeave);\n      }\n    }\n\n    // Clear previous state\n    setMessages([]);\n    setMediaFiles([]);\n    setDocuments([]);\n    setSelectedContact(contactOrGroup); // Set selected contact immediately for UI update\n\n    try {\n      setLoading(true); // Show loading for message fetch\n\n      if (contactOrGroup.type === \"group\") {\n        const groupId = contactOrGroup.groupId;\n        // Sử dụng conversationId từ group object\n        const conversationId = contactOrGroup.conversationId || groupId;\n        socket.emit(\"join_group\", groupId);\n        console.log(\"Joined group room:\", groupId);\n        console.log(\"Using conversationId for group:\", conversationId);\n        await fetchMessages(token, conversationId, true);\n      } else {\n        // Handle individual contact\n        let conversationId = contactOrGroup.conversationId;\n\n        // If conversationId is missing, try to fetch/create it\n        if (!conversationId) {\n          console.log(\"Conversation ID missing, attempting to fetch/create...\");\n          try {\n            conversationId = await createOrGetConversation(contactOrGroup.id, token);\n            // Update the contact in the list and the selected contact state\n            const updatedContact = {\n              ...contactOrGroup,\n              conversationId\n            };\n            setSelectedContact(updatedContact); // Update selected state with new ID\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? updatedContact : c));\n            // Optionally save updated contacts list to localStorage\n            const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n            const updatedContactsList = currentContacts.map(c => c.id === contactOrGroup.id ? updatedContact : c);\n            localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList));\n          } catch (error) {\n            showError(error.message); // Show error from createOrGetConversation\n            setSelectedContact(null); // Deselect if conversation fails\n            setLoading(false);\n            return; // Stop execution if conversation fails\n          }\n        }\n        if (conversationId) {\n          socket.emit(\"join_conversation\", conversationId);\n          console.log(\"Joined conversation room:\", conversationId);\n          await fetchMessages(token, conversationId, false);\n\n          // Mark conversation as read with proper request body\n          try {\n            await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, {\n              read: true\n            }, token);\n\n            // Update contacts list to remove unread badge\n            setContacts(prev => prev.map(c => c.id === contactOrGroup.id ? {\n              ...c,\n              unreadCount: 0\n            } : c));\n          } catch (readError) {\n            console.error(\"Error marking conversation as read:\", readError);\n            // Don't show error to user since this is a non-critical operation\n          }\n        } else {\n          // This case should ideally not be reached if createOrGetConversation throws errors\n          showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\");\n          setSelectedContact(null);\n        }\n      }\n    } catch (error) {\n      // Catch errors from fetchMessages or socket emits\n      console.error(\"Error in handleContactSelect processing:\", error);\n      showError(`Lỗi khi chọn liên hệ: ${error.message}`);\n      setSelectedContact(null); // Deselect on error\n    } finally {\n      setLoading(false); // Ensure loading is turned off\n    }\n  }, [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages]);\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(async e => {\n    e.preventDefault();\n    if (!newMessage.trim() || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n    const tempMessageId = `temp-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: newMessage,\n      time: messageTime,\n      senderId: user.id,\n      isSending: true // Indicate sending state\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    const messageToSend = newMessage; // Store message before clearing\n    setNewMessage(\"\"); // Clear input immediately\n    scrollToBottom(); // Scroll after adding optimistic message\n\n    try {\n      let response;\n      let messageDataForSocket;\n      if (selectedContact.type === \"group\") {\n        var _selectedContact$memb;\n        const groupId = selectedContact.groupId;\n        console.log(\"Attempting to send group message:\", {\n          groupId,\n          messageContent: messageToSend,\n          selectedContact\n        });\n        if (!groupId) {\n          throw new Error(\"GroupId is missing\");\n        }\n\n        // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n        if (!((_selectedContact$memb = selectedContact.memberIds) !== null && _selectedContact$memb !== void 0 && _selectedContact$memb.includes(user.id))) {\n          console.error(\"User not in group members:\", {\n            userId: user.id,\n            memberIds: selectedContact.memberIds,\n            members: selectedContact.members\n          });\n          throw new Error(\"Bạn không phải là thành viên của nhóm này\");\n        }\n        try {\n          response = await apiCall(\"post\", `/api/groups/${groupId}/messages`, {\n            content: messageToSend\n          }, token);\n          console.log(\"Group message API response:\", response);\n          if (!response) {\n            throw new Error(\"No response from server\");\n          }\n          if (!response.messageData) {\n            console.error(\"Invalid response structure:\", response);\n            throw new Error(\"Invalid response structure from server\");\n          }\n          const messageData = response.messageData;\n          messageDataForSocket = {\n            messageId: messageData.messageId,\n            groupId: groupId,\n            senderId: user.id,\n            senderName: user.name,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: messageData.createdAt || new Date().toISOString()\n          };\n          console.log(\"Emitting socket event with data:\", messageDataForSocket);\n          socket.emit(\"group_message\", messageDataForSocket);\n\n          // Update optimistic message with real ID and remove sending state\n          setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n            ...msg,\n            id: messageData.messageId,\n            isSending: false,\n            time: new Date(messageData.createdAt).toLocaleTimeString([], {\n              hour: \"2-digit\",\n              minute: \"2-digit\"\n            })\n          } : msg));\n        } catch (error) {\n          var _error$response3, _error$response4;\n          console.error(\"Error details:\", {\n            error,\n            groupId,\n            selectedContact,\n            user: {\n              id: user.id,\n              name: user.name\n            }\n          });\n          if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n            throw new Error(\"Không tìm thấy nhóm chat\");\n          } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403) {\n            throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\");\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        var _response$messageData, _response$messageData2;\n        // Handle individual contact message sending\n        const conversationId = selectedContact.conversationId;\n        if (!conversationId) {\n          throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\");\n        }\n        response = await apiCall(\"post\", \"/api/messages/send/text\", {\n          conversationId: conversationId,\n          content: messageToSend,\n          tempMessageId: tempMessageId // Add tempMessageId to help match response\n        }, token);\n        messageDataForSocket = {\n          messageId: ((_response$messageData = response.messageData) === null || _response$messageData === void 0 ? void 0 : _response$messageData.messageId) || response.messageId,\n          tempMessageId: tempMessageId,\n          // Include tempMessageId in socket event\n          conversationId: conversationId,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.id,\n          content: messageToSend,\n          type: \"text\",\n          createdAt: ((_response$messageData2 = response.messageData) === null || _response$messageData2 === void 0 ? void 0 : _response$messageData2.createdAt) || new Date().toISOString(),\n          time: messageTime // Include original time for matching\n        };\n        socket.emit(\"new_message\", messageDataForSocket);\n      }\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      showError(\"Không thể gửi tin nhắn: \" + error.message);\n      // Remove or mark optimistic message as failed\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n    }\n  }, [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(async (file, fileType = \"file\") => {\n    // fileType can be 'file', 'image', 'video'\n    if (!file || !isConnected || !selectedContact) return;\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      showError(\"Vui lòng đăng nhập lại.\");\n      return;\n    }\n\n    // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`);\n      return;\n    }\n    if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n      showError(\"Chỉ chấp nhận file hình ảnh.\");\n      return;\n    }\n    if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n      showError(\"Chỉ chấp nhận file video.\");\n      return;\n    }\n\n    // Video duration check\n    let videoDuration = null;\n    if (fileType === \"video\") {\n      try {\n        const duration = await getVideoDuration(file);\n        if (duration > 90) {\n          showError(\"Video không được dài quá 90 giây.\");\n          return;\n        }\n        videoDuration = Math.round(duration);\n      } catch (err) {\n        showError(\"Không thể đọc thông tin video.\");\n        return;\n      }\n    }\n    const tempMessageId = `temp-file-${Date.now()}`;\n    const messageTime = new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const tempUrl = URL.createObjectURL(file); // For optimistic UI\n\n    // Optimistic UI update\n    const optimisticMessage = {\n      id: tempMessageId,\n      sender: \"Me\",\n      content: fileType === \"text\" ? file.name : tempUrl,\n      // Use tempUrl for image/video\n      time: messageTime,\n      senderId: user.id,\n      isSending: true,\n      isFile: fileType === \"file\",\n      isImage: fileType === \"image\",\n      isVideo: fileType === \"video\",\n      fileName: file.name,\n      fileType: file.type,\n      duration: videoDuration\n    };\n    setMessages(prev => [...prev, optimisticMessage]);\n    scrollToBottom();\n    const formData = new FormData();\n    let apiUrl = \"\";\n    let apiKey = \"\"; // Key for the file in FormData\n\n    if (selectedContact.type === \"group\") {\n      const groupId = selectedContact.groupId;\n      formData.append(\"groupId\", groupId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = `/api/groups/${groupId}/images`;\n          apiKey = \"image\"; // Match backend key\n          break;\n        case \"video\":\n          apiUrl = `/api/groups/${groupId}/videos`;\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = `/api/groups/${groupId}/files`;\n          apiKey = \"file\";\n          break;\n      }\n    } else {\n      const conversationId = selectedContact.conversationId;\n      if (!conversationId) {\n        showError(\"Không tìm thấy cuộc trò chuyện để gửi file\");\n        URL.revokeObjectURL(tempUrl);\n        setMessages(prev => prev.filter(msg => msg.id !== tempMessageId)); // Remove optimistic msg\n        return;\n      }\n      formData.append(\"conversationId\", conversationId);\n      switch (fileType) {\n        case \"image\":\n          apiUrl = \"/api/messages/send/image\";\n          apiKey = \"images\"; // Match backend key (plural for this endpoint)\n          break;\n        case \"video\":\n          apiUrl = \"/api/messages/send/video\";\n          apiKey = \"video\";\n          break;\n        default:\n          // file\n          apiUrl = \"/api/messages/send/file\";\n          apiKey = \"file\";\n          break;\n      }\n    }\n    formData.append(apiKey, file);\n    try {\n      var _messageData$attachme;\n      const response = await apiCall(\"post\", apiUrl, formData, token);\n      const messageData = response.messageData || response; // Adjust based on API response structure\n      const attachment = (_messageData$attachme = messageData.attachments) === null || _messageData$attachme === void 0 ? void 0 : _messageData$attachme[0];\n      if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n        throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\");\n      }\n\n      // Update optimistic message\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        id: messageData.messageId,\n        content: attachment.url,\n        // Use final URL\n        fileUrl: fileType === \"file\" ? attachment.url : null,\n        isSending: false,\n        time: new Date(messageData.createdAt).toLocaleTimeString([], {\n          hour: \"2-digit\",\n          minute: \"2-digit\"\n        })\n      } : msg));\n\n      // Update media/documents list\n      const newItem = {\n        id: messageData.messageId,\n        type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n        url: attachment.url,\n        name: attachment.name || file.name,\n        date: new Date(messageData.createdAt).toLocaleDateString(),\n        size: attachment.size || file.size,\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      if (fileType === \"image\" || fileType === \"video\") {\n        setMediaFiles(prev => [newItem, ...prev]); // Add to beginning (newest)\n      } else {\n        setDocuments(prev => [newItem, ...prev]);\n      }\n\n      // Emit socket event\n      const socketEventData = {\n        messageId: messageData.messageId,\n        conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n        groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n        senderId: user.id,\n        senderName: user.name,\n        receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n        type: fileType,\n        // 'file', 'image', 'video'\n        content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null,\n        // Content might be null for media\n        attachments: messageData.attachments,\n        createdAt: messageData.createdAt || new Date().toISOString(),\n        duration: fileType === \"video\" ? videoDuration || attachment.duration : null\n      };\n      const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\";\n      socket.emit(socketEventName, socketEventData);\n      URL.revokeObjectURL(tempUrl); // Clean up temp URL\n    } catch (error) {\n      console.error(`Error sending ${fileType}:`, error);\n      showError(`Không thể gửi ${fileType}: ${error.message}`);\n      setMessages(prev => prev.map(msg => msg.id === tempMessageId ? {\n        ...msg,\n        isSending: false,\n        isError: true\n      } : msg));\n      URL.revokeObjectURL(tempUrl);\n    }\n  }, [isConnected, selectedContact, apiCall, showError, user.id, user.name]);\n  const getVideoDuration = file => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\");\n      video.preload = \"metadata\";\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src);\n        resolve(video.duration);\n      };\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src);\n        reject(new Error(\"Không thể tải metadata video\"));\n      };\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback(emoji => {\n    setNewMessage(prev => prev + emoji);\n    setShowEmojiPicker(false);\n  }, []);\n  const handleMessageAction = useCallback(async (messageId, action) => {\n    if (action === \"delete\") {\n      const token = localStorage.getItem(\"token\");\n      if (!token || !selectedContact) return;\n\n      // Optimistic UI update\n      const originalMessages = [...messages];\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        content: \"Đang xóa...\",\n        isUnsent: true,\n        isDeleting: true\n      } : msg));\n      try {\n        if (selectedContact.type === \"group\") {\n          await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, undefined, token);\n        } else {\n          await apiCall(\"delete\", `/api/messages/${messageId}`, undefined, token);\n        }\n\n        // Confirm deletion in UI\n        setMessages(prev => prev.map(msg => msg.id === messageId ? {\n          ...msg,\n          content: \"Tin nhắn đã bị xóa\",\n          isDeleting: false\n        } : msg));\n\n        // Remove from media/documents lists\n        setMediaFiles(prev => prev.filter(media => media.id !== messageId));\n        setDocuments(prev => prev.filter(doc => doc.id !== messageId));\n\n        // TODO: Emit socket event for deletion if needed by backend/other clients\n      } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        showError(\"Không thể xóa tin nhắn: \" + error.message);\n        // Revert optimistic update on error\n        setMessages(originalMessages);\n      }\n    }\n    // Handle other actions like 'recall' if implemented\n  }, [apiCall, selectedContact, showError, messages] // Include messages in dependency array\n  );\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true);\n    setShowFiles(false);\n  }, []);\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false);\n    setShowFiles(true);\n  }, []);\n  const handleTabChange = useCallback(tab => {\n    setActiveTab(tab);\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchFriendRequests(token);\n      }\n    }\n  }, [fetchFriendRequests]); // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null\n    });\n    setShowProfileModal(true);\n  }, [user.name, user.avatar]); // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false);\n  }, []);\n  const handleAvatarChange = useCallback(async file => {\n    // File validation\n    if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n      showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const formData = new FormData();\n    formData.append(\"avatar\", file);\n    try {\n      setLoading(true); // Indicate loading\n      const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token);\n      // Update state optimistically/realistically\n      setProfileData(prev => ({\n        ...prev,\n        avatarUrl: response.avatarUrl\n      }));\n      setUser(prev => ({\n        ...prev,\n        avatar: response.avatarUrl\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.avatarUrl = response.avatarUrl;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật ảnh đại diện thành công!\");\n    } catch (error) {\n      showError(\"Không thể tải avatar: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError]);\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    try {\n      setLoading(true);\n      const response = await apiCall(\"put\", \"/api/users/profile\", {\n        fullName: profileData.fullName,\n        // Ensure birthdate is sent correctly or omitted if empty\n        birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n        gender: profileData.gender || undefined // Send undefined if empty to potentially clear it\n      }, token);\n      // Update user state\n      setUser(prev => ({\n        ...prev,\n        name: response.fullName || prev.name\n        // Avatar might not be in this response, keep existing one\n      }));\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      userProfile.fullName = response.fullName;\n      userProfile.birthdate = response.birthdate;\n      userProfile.gender = response.gender;\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile));\n      showError(\"Cập nhật hồ sơ thành công!\");\n      handleCloseProfileModal();\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal]);\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true);\n  }, []);\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false);\n    setFriendEmail(\"\"); // Reset email field\n  }, []);\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\");\n      return;\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\");\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      var _searchResult$data;\n      // Search user first to get ID\n      const searchResult = await apiCall(\"get\", `/api/users/search?query=${encodeURIComponent(friendEmail)}`, null, token);\n      if (!(searchResult !== null && searchResult !== void 0 && (_searchResult$data = searchResult.data) !== null && _searchResult$data !== void 0 && _searchResult$data.length)) {\n        throw new Error(\"Không tìm thấy người dùng với email này\");\n      }\n      const receiverId = searchResult.data[0].userId;\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\");\n      }\n\n      // Check if already friends\n      if (contacts.some(c => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\");\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", {\n        receiverId,\n        message: `Kết bạn từ ${user.name}`\n      }, token);\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`);\n      handleCloseAddFriendModal();\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`);\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`);\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`);\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`);\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false);\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts]);\n  const handleRespondToFriendRequest = useCallback(async (requestId, action) => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    const request = friendRequests.find(req => req.requestId === requestId);\n    if (!request) return;\n    setLoading(true); // Indicate processing\n    // Optimistically remove from list\n    setFriendRequests(prev => prev.filter(req => req.requestId !== requestId));\n    try {\n      const response = await apiCall(\"post\", \"/api/friends/requests/respond\", {\n        requestId,\n        action\n      }, token);\n      console.log(\"Friend request response:\", response);\n      if (action === \"accept\") {\n        var _response$conversatio2, _senderInfo$email;\n        showError(\"Đã chấp nhận lời mời kết bạn\");\n        const senderInfo = request.sender;\n        if (!senderInfo || !senderInfo.userId) {\n          throw new Error(\"Thông tin người gửi không hợp lệ\");\n        }\n\n        // Get conversation ID (might be in response or need creation)\n        let conversationId = (_response$conversatio2 = response.conversation) === null || _response$conversatio2 === void 0 ? void 0 : _response$conversatio2.conversationId;\n        if (!conversationId) {\n          console.log(\"No conversationId in response, creating/getting...\");\n          conversationId = await createOrGetConversation(senderInfo.userId, token);\n        }\n        if (!conversationId) {\n          throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\");\n        }\n\n        // Create new contact object\n        const newContact = {\n          id: senderInfo.userId,\n          name: senderInfo.fullName || ((_senderInfo$email = senderInfo.email) === null || _senderInfo$email === void 0 ? void 0 : _senderInfo$email.split(\"@\")[0]) || \"Unknown\",\n          avatar: senderInfo.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\",\n          conversationId: conversationId\n        };\n        addOrUpdateContact(newContact); // Add/update contact list and localStorage\n\n        // Optionally select the new contact immediately\n        // handleContactSelect(newContact);\n\n        // Emit notification to the sender via socket\n        if (socket.connected) {\n          socket.emit(\"friend_request_accepted_notify\", {\n            accepter: {\n              userId: user.id,\n              fullName: user.name,\n              avatarUrl: user.avatar\n            },\n            senderId: senderInfo.userId,\n            // Target the sender\n            conversationId: conversationId\n          });\n          // Also tell sender to refresh their list\n          socket.emit(\"refresh_contacts_notify\", {\n            targetUserId: senderInfo.userId\n          });\n          console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\");\n        }\n      } else {\n        showError(\"Đã từ chối lời mời kết bạn\");\n        // Optionally notify sender of rejection via socket\n      }\n    } catch (error) {\n      console.error(\"Error responding to friend request:\", error);\n      showError(\"Không thể phản hồi lời mời: \" + error.message);\n      // Revert optimistic removal on error\n      setFriendRequests(prev => [...prev, request]);\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleRemoveFriend = useCallback(async friendId => {\n    if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    console.log(`Attempting to remove friend with ID: ${friendId}`);\n    setLoading(true);\n\n    // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n    const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\");\n    if (!contactToRemove) {\n      showError(\"Không tìm thấy người dùng trong danh sách bạn bè\");\n      setLoading(false);\n      return;\n    }\n\n    // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n    const currentContacts = [...contacts];\n    try {\n      // Cập nhật UI trước khi gọi API (optimistic update)\n      setContacts(prev => prev.filter(contact => contact.id !== friendId || contact.type !== \"contact\"));\n\n      // Cập nhật localStorage\n      try {\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\");\n        const updatedContacts = savedContacts.filter(c => c.id !== friendId || c.type !== \"contact\");\n        localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts));\n      } catch (e) {\n        console.error(\"Error updating localStorage after friend removal\", e);\n      }\n\n      // Bỏ chọn nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === friendId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n\n      // Gọi API để xóa bạn bè\n      try {\n        console.log(`Calling API to remove friend: ${friendId}`);\n        const response = await apiCall(\"delete\", `/api/friends/${friendId}`, undefined, token);\n        console.log(\"Friend removal API response:\", response);\n        showError(\"Đã xóa bạn bè thành công\");\n\n        // Thông báo cho người bạn bị xóa qua socket\n        if (socket && socket.connected) {\n          socket.emit(\"friend_removed_notify\", {\n            removerId: user.id,\n            removedUserId: friendId\n          });\n          console.log(\"Emitted friend_removed_notify\");\n\n          // Thông báo cập nhật danh sách bạn bè\n          socket.emit(\"friend_list_updated\");\n        }\n\n        // Cập nhật lại danh sách bạn bè từ server\n        fetchContactsAndGroups(token);\n      } catch (apiError) {\n        console.error(\"API error removing friend:\", apiError);\n\n        // Kiểm tra lỗi cụ thể\n        if (apiError.response && apiError.response.status === 404) {\n          // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n          showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\");\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token);\n        } else {\n          // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n          showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"));\n          // Khôi phục lại danh sách bạn bè\n          setContacts(currentContacts);\n\n          // Khôi phục localStorage\n          try {\n            localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n          } catch (e) {\n            console.error(\"Error restoring localStorage\", e);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in handleRemoveFriend:\", error);\n      showError(\"Không thể xóa bạn bè: \" + error.message);\n\n      // Khôi phục lại danh sách bạn bè\n      setContacts(currentContacts);\n\n      // Khôi phục localStorage\n      try {\n        localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts));\n      } catch (e) {\n        console.error(\"Error restoring localStorage\", e);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups]);\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true);\n  }, []);\n  const handleGroupCreated = useCallback(newGroupData => {\n    var _newGroupData$members;\n    console.log(\"Group created data:\", newGroupData);\n    const groupObject = {\n      groupId: newGroupData.groupId,\n      id: newGroupData.groupId,\n      // Add id for consistency\n      name: newGroupData.name,\n      avatar: newGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: newGroupData.adminId,\n      memberCount: ((_newGroupData$members = newGroupData.members) === null || _newGroupData$members === void 0 ? void 0 : _newGroupData$members.length) || 1,\n      // At least admin is a member\n      conversationId: newGroupData.conversationId || newGroupData.groupId,\n      createdAt: newGroupData.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    setShowCreateGroupModal(false);\n    showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`);\n    // Automatically select the new group\n    handleContactSelect(groupObject);\n  }, [addOrUpdateGroup, showError, handleContactSelect]);\n  const handleGroupInfo = useCallback(group => {\n    // Fetch full group details if necessary before showing modal\n    setSelectedGroup(group); // Pass the basic group info for now\n    setShowGroupInfoModal(true);\n    // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n  }, [] // No dependencies needed to just show the modal\n  );\n  const handleGroupUpdated = useCallback(updatedGroupData => {\n    var _updatedGroupData$mem;\n    console.log(\"Group updated data:\", updatedGroupData);\n    // Ensure the data structure matches what addOrUpdateGroup expects\n    const groupObject = {\n      groupId: updatedGroupData.groupId,\n      id: updatedGroupData.groupId,\n      name: updatedGroupData.name,\n      avatar: updatedGroupData.avatarUrl || \"\",\n      type: \"group\",\n      adminId: updatedGroupData.adminId,\n      memberCount: updatedGroupData.memberCount || ((_updatedGroupData$mem = updatedGroupData.members) === null || _updatedGroupData$mem === void 0 ? void 0 : _updatedGroupData$mem.length) || 0,\n      conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n      createdAt: updatedGroupData.createdAt\n      // Include other relevant fields if needed\n    };\n    addOrUpdateGroup(groupObject);\n    // Update selected contact if it's the one being edited\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupObject.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    setShowGroupInfoModal(false); // Close modal on success\n    showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleLeaveGroup = useCallback(async groupId => {\n    console.log(\"Leaving group:\", groupId);\n    if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n      return;\n    }\n    const token = localStorage.getItem(\"token\");\n    if (!token) return;\n    setLoading(true);\n    try {\n      // Gọi API để rời nhóm\n      const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, undefined, token);\n      console.log(\"Leave group API response:\", response);\n\n      // Cập nhật UI sau khi API thành công\n      setGroups(prev => prev.filter(group => group.groupId !== groupId));\n\n      // Cập nhật localStorage\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after leaving group\", e);\n      }\n\n      // Bỏ chọn nhóm nếu đang được chọn\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n      setShowGroupInfoModal(false); // Đóng modal\n      showError(\"Bạn đã rời khỏi nhóm thành công\");\n\n      // Thông báo qua socket nếu cần\n      if (socket.connected) {\n        socket.emit(\"left_group\", {\n          groupId\n        });\n      }\n    } catch (error) {\n      console.error(\"Error leaving group:\", error);\n      showError(\"Không thể rời khỏi nhóm: \" + error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedContact, showError, apiCall]);\n  const handleDeleteGroup = useCallback(groupId => {\n    console.log(\"Deleting group:\", groupId);\n    setGroups(prev => prev.filter(group => group.groupId !== groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after deleting group\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    setShowGroupInfoModal(false); // Close modal\n    showError(\"Đã xóa nhóm thành công\");\n    // API call to delete group should be handled within GroupInfoModal or here before state update\n  }, [selectedContact, showError]);\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\");\n    if (!token) {\n      navigate(\"/login\");\n      return;\n    }\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    let socketInitialized = false;\n    const initializeApp = async () => {\n      try {\n        setLoading(true);\n        const userProfile = await fetchUserProfile(token);\n        if (!userProfile || !isMounted) return; // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token);\n        if (!isMounted) return;\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token);\n        if (!isMounted) return;\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\");\n\n          // Set socket auth and query params\n          socket.auth = {\n            token\n          };\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now()\n          };\n\n          // Connect the socket\n          socket.connect();\n          socketInitialized = true;\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\");\n      socket.off(\"reconnect\");\n      socket.off(\"friend_request\");\n      socket.off(\"new_message\");\n      socket.off(\"receive_message\");\n      socket.off(\"group_message\");\n      socket.off(\"friend_request_accepted\");\n      socket.off(\"friend_removed\");\n      socket.off(\"refresh_contacts\");\n      socket.off(\"notification\");\n      socket.off(\"group_created\");\n      socket.off(\"group_updated\");\n      socket.off(\"group_deleted\");\n      socket.off(\"member_added\");\n      socket.off(\"member_removed\");\n    };\n  }, [navigate]); // Only depend on navigate\n\n  // Khi khởi tạo component, đọc cache từ localStorage\n  useEffect(() => {\n    // ... các logic khác\n    const cache = localStorage.getItem('cachedMessages');\n    if (cache) {\n      setCachedMessages(JSON.parse(cache));\n    }\n  }, [navigate]);\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback(data => {\n    var _data$attachments, _data$attachments$, _data$attachments2, _data$attachments2$, _data$attachments3, _data$attachments3$, _data$attachments4, _data$attachments4$, _data$attachments5, _data$attachments5$;\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || !data.messageId && !data.id) {\n      console.error(\"Invalid message data received:\", data);\n      return;\n    }\n    const messageTime = data.createdAt ? new Date(data.createdAt).toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }) : new Date().toLocaleTimeString([], {\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    });\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString();\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type,\n      selectedContactGroupId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.groupId,\n      selectedContactConversationId: selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.conversationId\n    });\n    const isCurrentChat = (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\" && selectedContact.groupId === data.groupId || (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"contact\" && selectedContact.conversationId === data.conversationId;\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n    const newMessage = {\n      id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n      content: data.isDeleted ? \"Tin nhắn đã bị xóa\" : data.isRecalled ? \"Tin nhắn đã bị thu hồi/xóa\" : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\" ? data.content : ((_data$attachments = data.attachments) === null || _data$attachments === void 0 ? void 0 : (_data$attachments$ = _data$attachments[0]) === null || _data$attachments$ === void 0 ? void 0 : _data$attachments$.url) || data.content || \"\",\n      time: messageTime,\n      senderId: data.senderId,\n      isImage: !data.isDeleted && (data.type === \"image\" || data.type === \"imageGroup\"),\n      isVideo: !data.isDeleted && data.type === \"video\",\n      isFile: !data.isDeleted && data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n      isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n      fileUrl: !data.isDeleted && data.type === \"file\" ? (_data$attachments2 = data.attachments) === null || _data$attachments2 === void 0 ? void 0 : (_data$attachments2$ = _data$attachments2[0]) === null || _data$attachments2$ === void 0 ? void 0 : _data$attachments2$.url : null,\n      fileName: !data.isDeleted && data.type === \"file\" ? (_data$attachments3 = data.attachments) === null || _data$attachments3 === void 0 ? void 0 : (_data$attachments3$ = _data$attachments3[0]) === null || _data$attachments3$ === void 0 ? void 0 : _data$attachments3$.name : null,\n      fileType: !data.isDeleted && data.type === \"file\" ? (_data$attachments4 = data.attachments) === null || _data$attachments4 === void 0 ? void 0 : (_data$attachments4$ = _data$attachments4[0]) === null || _data$attachments4$ === void 0 ? void 0 : _data$attachments4$.type : null,\n      duration: !data.isDeleted && data.type === \"video\" ? ((_data$attachments5 = data.attachments) === null || _data$attachments5 === void 0 ? void 0 : (_data$attachments5$ = _data$attachments5[0]) === null || _data$attachments5$ === void 0 ? void 0 : _data$attachments5$.duration) || data.duration : null,\n      messageDate: messageDate\n    };\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || [];\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev;\n        const updated = {\n          ...prev,\n          [data.conversationId]: [...prevList, newMessage]\n        };\n        // Lưu vào localStorage\n        localStorage.setItem('cachedMessages', JSON.stringify(updated));\n        console.log('>>> Updated cachedMessages:', updated);\n        return updated;\n      });\n    }\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id);\n        if (exists) return prev;\n        return [...prev, newMessage];\n      });\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles(prev => {\n          var _data$attachments6, _data$attachments6$;\n          return [{\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: ((_data$attachments6 = data.attachments) === null || _data$attachments6 === void 0 ? void 0 : (_data$attachments6$ = _data$attachments6[0]) === null || _data$attachments6$ === void 0 ? void 0 : _data$attachments6$.size) || 0,\n            duration: newMessage.duration\n          }, ...prev // Add to beginning\n          ];\n        });\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments(prev => {\n          var _newMessage$fileName, _data$attachments7, _data$attachments7$;\n          return [{\n            id: newMessage.id,\n            type: ((_newMessage$fileName = newMessage.fileName) === null || _newMessage$fileName === void 0 ? void 0 : _newMessage$fileName.split(\".\").pop().toLowerCase()) || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: ((_data$attachments7 = data.attachments) === null || _data$attachments7 === void 0 ? void 0 : (_data$attachments7$ = _data$attachments7[0]) === null || _data$attachments7$ === void 0 ? void 0 : _data$attachments7$.size) || 0\n          }, ...prev // Add to beginning\n          ];\n        });\n      }\n    } else {\n      var _data$content, _data$content2;\n      // Notification for message in other chat\n      let senderName = \"Người dùng\";\n      let contactId = data.senderId; // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find(g => g.groupId === data.groupId);\n        senderName = `${data.senderName || \"Ai đó\"} (${(group === null || group === void 0 ? void 0 : group.name) || \"Nhóm\"})`;\n      } else {\n        const contact = contacts.find(c => c.id === data.senderId); // Tìm contact dựa trên senderId\n        senderName = (contact === null || contact === void 0 ? void 0 : contact.name) || data.senderName || \"Ai đó\";\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n      const preview = data.type === \"text\" ? ((_data$content = data.content) === null || _data$content === void 0 ? void 0 : _data$content.substring(0, 30)) + (((_data$content2 = data.content) === null || _data$content2 === void 0 ? void 0 : _data$content2.length) > 30 ? \"...\" : \"\") : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`;\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`);\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview,\n              // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(c => c.conversationId === data.conversationId || c.id === data.senderId);\n        if (foundContact) {\n          setSelectedContact(foundContact);\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || []);\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      var _contacts$find, _groups$find;\n      const contactName = data.senderName || \"Người dùng\";\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: ((_contacts$find = contacts.find(c => c.id === data.senderId)) === null || _contacts$find === void 0 ? void 0 : _contacts$find.avatar) || ((_groups$find = groups.find(g => g.groupId === data.groupId)) === null || _groups$find === void 0 ? void 0 : _groups$find.avatar) || \"/favicon.ico\" // Optional icon\n      });\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages]);\n  const handleFriendRequest = useCallback(data => {\n    if (!data || !data.requestId || !data.sender) return;\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab]);\n  const handleFriendRequestAccepted = useCallback(data => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\");\n      return;\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user]);\n  const handleFriendRemoved = useCallback(data => {\n    if (!data || !data.removerId) return;\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError]);\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\");\n    if (token) {\n      fetchContactsAndGroups(token);\n    }\n  }, [fetchContactsAndGroups]);\n  const handleSocketGroupCreated = useCallback(data => {\n    var _group$members3;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_created event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: ((_group$members3 = group.members) === null || _group$members3 === void 0 ? void 0 : _group$members3.length) || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`);\n  }, [addOrUpdateGroup, showError]);\n  const handleSocketGroupUpdated = useCallback(data => {\n    var _group$members4;\n    if (!(data !== null && data !== void 0 && data.group)) return;\n    console.log(\"Received group_updated event:\", data.group);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members4 = group.members) === null || _group$members4 === void 0 ? void 0 : _group$members4.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`);\n  }, [addOrUpdateGroup, selectedContact, showError]);\n  const handleGroupDeleted = useCallback(data => {\n    var _groups$find2;\n    if (!(data !== null && data !== void 0 && data.groupId)) return;\n    console.log(\"Received group_deleted event:\", data.groupId);\n    const groupName = ((_groups$find2 = groups.find(g => g.groupId === data.groupId)) === null || _groups$find2 === void 0 ? void 0 : _groups$find2.name) || \"Một nhóm\";\n    setGroups(prev => prev.filter(group => group.groupId !== data.groupId));\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n      const updatedGroups = savedGroups.filter(g => g.groupId !== data.groupId);\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n    } catch (e) {\n      console.error(\"Error updating localStorage after group delete\", e);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === data.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(null);\n      setMessages([]);\n      setMediaFiles([]);\n      setDocuments([]);\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`);\n  }, [groups, selectedContact, showError]);\n  const handleMemberAdded = useCallback(data => {\n    var _group$members5;\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.member) || !(data !== null && data !== void 0 && data.addedBy)) return;\n    console.log(\"Received member_added event:\", data);\n    const group = data.group;\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || ((_group$members5 = group.members) === null || _group$members5 === void 0 ? void 0 : _group$members5.length) || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt\n    };\n    addOrUpdateGroup(groupObject);\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`);\n    }\n    if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n      setSelectedContact(groupObject);\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleMemberRemoved = useCallback(data => {\n    if (!(data !== null && data !== void 0 && data.group) || !(data !== null && data !== void 0 && data.memberId) || !(data !== null && data !== void 0 && data.removedBy)) return;\n    console.log(\"Received member_removed event:\", data);\n    const group = data.group;\n    const groupId = group.groupId;\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`);\n      setGroups(prev => prev.filter(g => g.groupId !== groupId));\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\");\n        const updatedGroups = savedGroups.filter(g => g.groupId !== groupId);\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups));\n      } catch (e) {\n        console.error(\"Error updating localStorage after being removed from group\", e);\n      }\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(null);\n        setMessages([]);\n        setMediaFiles([]);\n        setDocuments([]);\n      }\n    } else {\n      var _group$members6, _data$member;\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || ((_group$members6 = group.members) === null || _group$members6 === void 0 ? void 0 : _group$members6.length) || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt\n      };\n      addOrUpdateGroup(groupObject);\n      const memberName = ((_data$member = data.member) === null || _data$member === void 0 ? void 0 : _data$member.fullName) || \"một thành viên\";\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`);\n      if ((selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.id) === group.groupId && (selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.type) === \"group\") {\n        setSelectedContact(groupObject);\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError]);\n  const handleNotification = useCallback(data => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data);\n      return;\n    }\n    if (data.type === \"success\") {\n      showError(data.message);\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\");\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\");\n    } else {\n      showError(data.message);\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\");\n      if (token) {\n        fetchContactsAndGroups(token);\n      }\n    }\n  }, [showError, fetchContactsAndGroups]);\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true;\n    const handleConnect = () => {\n      if (!isMounted) return;\n      console.log(\"Socket re-connected inside hook.\");\n      setIsConnected(true);\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\");\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId);\n      }\n    };\n\n    // Add handler for message_sent event\n    const handleMessageSent = data => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data);\n        return;\n      }\n      console.log(\"Received message_sent_success event:\", data);\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n        // Match by tempMessageId if available\n        data.tempMessageId && msg.id === data.tempMessageId ||\n        // Or match by conversationId and content if tempMessageId not available\n        data.conversationId && msg.conversationId === data.conversationId && msg.content === data.content)) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          });\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          };\n        }\n        return msg;\n      }));\n    };\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect);\n    socket.on(\"message_sent_success\", handleMessageSent); // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage);\n    socket.on(\"receive_message\", handleNewMessage);\n    socket.on(\"group_message\", handleNewMessage);\n    socket.on(\"friend_request\", handleFriendRequest);\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted);\n    socket.on(\"friend_removed\", handleFriendRemoved);\n    socket.on(\"refresh_contacts\", handleRefreshContacts);\n    socket.on(\"notification\", handleNotification);\n    socket.on(\"group_created\", handleSocketGroupCreated);\n    socket.on(\"group_updated\", handleSocketGroupUpdated);\n    socket.on(\"group_deleted\", handleGroupDeleted);\n    socket.on(\"member_added\", handleMemberAdded);\n    socket.on(\"member_removed\", handleMemberRemoved);\n    socket.on(\"message_reacted\", handleMessageReacted);\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false;\n      socket.off(\"connect\", handleConnect);\n      socket.off(\"message_sent_success\", handleMessageSent); // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage);\n      socket.off(\"receive_message\", handleNewMessage);\n      socket.off(\"group_message\", handleNewMessage);\n      socket.off(\"friend_request\", handleFriendRequest);\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted);\n      socket.off(\"friend_removed\", handleFriendRemoved);\n      socket.off(\"refresh_contacts\", handleRefreshContacts);\n      socket.off(\"notification\", handleNotification);\n      socket.off(\"group_created\", handleSocketGroupCreated);\n      socket.off(\"group_updated\", handleSocketGroupUpdated);\n      socket.off(\"group_deleted\", handleGroupDeleted);\n      socket.off(\"member_added\", handleMemberAdded);\n      socket.off(\"member_removed\", handleMemberRemoved);\n      socket.off(\"message_reacted\", handleMessageReacted);\n    };\n  }, [handleNewMessage, handleFriendRequest, handleFriendRequestAccepted, handleFriendRemoved, handleRefreshContacts, handleNotification, handleSocketGroupCreated, handleSocketGroupUpdated, handleGroupDeleted, handleMemberAdded, handleMemberRemoved, selectedContact,\n  // Add selectedContact as dependency\n  handleMessageReacted]);\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]); // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n      var _messagesEndRef$curre;\n      (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"end\"\n      });\n    }, 100);\n  };\n\n  // ... existing code ...\n  useEffect(() => {\n    // ... các event khác ...\n    const handleMessageDeleted = data => {\n      setMessages(prev => prev.map(msg => msg.id === data.messageId ? {\n        ...msg,\n        content: \"Tin nhắn đã bị xóa\",\n        isUnsent: true\n      } : msg));\n    };\n    socket.on(\"message_deleted\", handleMessageDeleted);\n    // ... cleanup ...\n    return () => {\n      socket.off(\"message_deleted\", handleMessageDeleted);\n      // ... cleanup các event khác ...\n    };\n  }, [setMessages]);\n  // ... existing code ...\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(contact => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const filteredGroups = groups.filter(group => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()));\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"]; // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts,\n    // Return full contacts list if needed elsewhere\n    groups,\n    // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab,\n    // Needed for friend request notification\n    setShowProfileModal,\n    // Needed for closing modal from component\n    setProfileData,\n    // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal,\n    // Needed for closing modal from component\n    setFriendEmail,\n    // Needed for form input\n    // setError, // Internal state\n    setShowToast,\n    // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal,\n    // Needed for closing modal from component\n    setShowGroupInfoModal,\n    // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile,\n    // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError,\n    // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"),\n    // Pass token for Modals\n    reactionEmojis,\n    // Trả về danh sách emoji\n\n    // Handlers\n    handleReactToMessage // Trả về handler thả cảm xúc\n  };\n};\n_s(useChat, \"urPpq+lyH32eQEbBCzhMEotgXl4=\", false, function () {\n  return [useNavigate];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useNavigate","axios","io","API_BASE_URL","socket","autoConnect","reconnection","reconnectionAttempts","Number","POSITIVE_INFINITY","reconnectionDelay","reconnectionDelayMax","timeout","transports","upgrade","forceNew","query","timestamp","Date","now","on","console","log","id","err","error","reason","window","originalConsoleError","args","includes","apply","useChat","_s","navigate","user","setUser","name","avatar","contacts","setContacts","groups","setGroups","selectedContact","setSelectedContact","messages","setMessages","newMessage","setNewMessage","isConnected","setIsConnected","connected","showEmojiPicker","setShowEmojiPicker","searchQuery","setSearchQuery","mediaFiles","setMediaFiles","documents","setDocuments","showMedia","setShowMedia","showFiles","setShowFiles","activeTab","setActiveTab","showProfileModal","setShowProfileModal","profileData","setProfileData","fullName","birthdate","gender","avatarUrl","loading","setLoading","showAddFriendModal","setShowAddFriendModal","friendEmail","setFriendEmail","setError","showToast","setShowToast","friendRequests","setFriendRequests","recoveredContacts","setRecoveredContacts","showCreateGroupModal","setShowCreateGroupModal","showGroupInfoModal","setShowGroupInfoModal","selectedGroup","setSelectedGroup","cachedMessages","setCachedMessages","messagesEndRef","fileInputRef","imageInputRef","videoInputRef","reactionEmojis","showError","message","apiCall","method","url","data","token","toUpperCase","FormData","config","headers","Authorization","Pragma","response","status","_error$response","_error$response2","_error$response2$data","localStorage","removeItem","Error","errorMessage","addOrUpdateContact","newContact","savedContacts","getItem","contactsArray","JSON","parse","filter","c","push","setItem","stringify","storageError","prev","exists","some","contact","map","addOrUpdateGroup","newGroup","groupId","savedGroups","groupsArray","g","group","fetchUserProfile","userData","userId","toISOString","split","fetchMessages","conversationId","isGroup","warn","endpoint","messagesData","Array","isArray","mappedMessages","msg","index","_msg$attachments","_msg$attachments$","_msg$attachments2","_msg$attachments$2","_msg$attachments3","_msg$attachments$3","_msg$attachments4","_msg$attachments$4","_msg$attachments5","_msg$attachments$5","messageId","sender","senderId","senderName","content","isDeleted","isRecalled","type","attachments","time","toLocaleTimeString","hour","minute","isImage","isVideo","isFile","isUnsent","isSystemMessage","fileUrl","length","fileName","fileType","duration","messageDate","toLocaleDateString","reactions","systemMessage","unshift","mergedMessages","cacheFromStorage","cacheList","newFromCache","cacheMsg","sort","a","b","aTime","createdAt","bTime","media","_msg$attachments6","_msg$attachments6$","date","size","reverse","files","_msg$fileName","_msg$attachments7","_msg$attachments7$","pop","toLowerCase","fetchContactsAndGroups","fetchedContacts","fetchedGroups","friendsResponse","confirmedFriends","friends","validFriends","friend","friendshipId","mappedFriends","_friend$email","email","convResponse","conversationsMap","Map","forEach","conv","participants","otherUserId","find","set","has","get","existingContactsMap","existingContact","groupsResponse","userGroups","members","member","_group$members","_group$members2","adminId","admin","memberIds","memberCount","e","fetchFriendRequests","createOrGetConversation","_response$conversatio","conversation","handleContactSelect","contactOrGroup","roomToLeave","eventName","emit","updatedContact","currentContacts","updatedContactsList","read","unreadCount","readError","handleSendMessage","preventDefault","trim","tempMessageId","messageTime","optimisticMessage","isSending","messageToSend","scrollToBottom","messageDataForSocket","_selectedContact$memb","messageContent","messageData","_error$response3","_error$response4","_response$messageData","_response$messageData2","receiverId","isError","handleSendFile","file","maxSize","startsWith","videoDuration","getVideoDuration","Math","round","tempUrl","URL","createObjectURL","formData","apiUrl","apiKey","append","revokeObjectURL","_messageData$attachme","attachment","newItem","socketEventData","socketEventName","Promise","resolve","reject","video","document","createElement","preload","onloadedmetadata","src","onerror","handleEmojiSelect","emoji","handleMessageAction","action","originalMessages","isDeleting","undefined","doc","toggleMediaView","toggleFilesView","handleTabChange","tab","handleProfileClick","userProfile","handleCloseProfileModal","handleAvatarChange","handleUpdateProfile","handleAddFriend","handleCloseAddFriendModal","handleSubmitAddFriend","emailRegex","test","_searchResult$data","searchResult","encodeURIComponent","handleRespondToFriendRequest","requestId","request","req","_response$conversatio2","_senderInfo$email","senderInfo","accepter","targetUserId","handleRemoveFriend","friendId","confirm","contactToRemove","updatedContacts","removerId","removedUserId","apiError","handleCreateGroup","handleGroupCreated","newGroupData","_newGroupData$members","groupObject","handleGroupInfo","handleGroupUpdated","updatedGroupData","_updatedGroupData$mem","handleLeaveGroup","updatedGroups","handleDeleteGroup","isMounted","socketInitialized","initializeApp","auth","opts","connect","off","cache","handleNewMessage","_data$attachments","_data$attachments$","_data$attachments2","_data$attachments2$","_data$attachments3","_data$attachments3$","_data$attachments4","_data$attachments4$","_data$attachments5","_data$attachments5$","selectedContactType","selectedContactGroupId","selectedContactConversationId","isCurrentChat","prevList","updated","_data$attachments6","_data$attachments6$","_newMessage$fileName","_data$attachments7","_data$attachments7$","_data$content","_data$content2","contactId","targetId","isGroupMessage","preview","substring","item","itemIdToMatch","lastMessage","lastMessageAt","foundContact","hidden","Notification","permission","_contacts$find","_groups$find","contactName","body","icon","handleFriendRequest","handleFriendRequestAccepted","handleFriendRemoved","handleRefreshContacts","handleSocketGroupCreated","_group$members3","handleSocketGroupUpdated","_group$members4","handleGroupDeleted","_groups$find2","groupName","handleMemberAdded","_group$members5","addedBy","handleMemberRemoved","memberId","removedBy","_group$members6","_data$member","memberName","handleNotification","refreshContacts","handleConnect","handleMessageSent","prevMessages","oldId","newId","handleMessageReacted","setTimeout","_messagesEndRef$curre","current","scrollIntoView","behavior","block","handleMessageDeleted","filteredContacts","filteredGroups","emojis","handleReactToMessage"],"sources":["C:/Users/ADMIN/Desktop/Nhom12_Zalo_Web/FE-WebAppZola/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js\nimport { useState, useEffect, useRef, useCallback } from \"react\"\nimport { useNavigate } from \"react-router-dom\"\nimport axios from \"axios\"\nimport { io } from \"socket.io-client\"\n\n// --- Constants and Socket Setup (Outside Hook) ---\n\n// API URL cơ sở\nconst API_BASE_URL = \"http://localhost:5000\"\n\n// Tạo kết nối socket.io với cấu hình phù hợp\nconst socket = io(API_BASE_URL, {\n  autoConnect: false, // Don't connect automatically, wait for initializeSocket\n  reconnection: true,\n  reconnectionAttempts: Number.POSITIVE_INFINITY,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n  transports: [\"websocket\"],\n  upgrade: false,\n  forceNew: false, // Changed to false to prevent multiple connections\n  query: {\n    timestamp: Date.now(),\n  },\n})\n\n// Debug socket connection (Initial setup outside hook)\nsocket.on(\"connect\", () => {\n  console.log(\"Socket connected successfully! ID:\", socket.id)\n})\n\nsocket.on(\"connect_error\", (err) => {\n  console.error(\"Socket connection error:\", err)\n})\n\nsocket.on(\"disconnect\", (reason) => {\n  console.log(\"Socket disconnected:\", reason)\n})\n\nsocket.on(\"error\", (err) => {\n  console.error(\"Socket error:\", err)\n})\n\nsocket.on(\"reconnect_error\", (err) => {\n  console.error(\"Socket reconnection error:\", err)\n})\n\n// Chặn lỗi \"Could not establish connection\" từ Chrome\nif (typeof window !== \"undefined\") {\n  const originalConsoleError = console.error\n  console.error = (...args) => {\n    if (\n      args[0] &&\n      typeof args[0] === \"string\" &&\n      (args[0].includes(\"Could not establish connection\") || args[0].includes(\"Receiving end does not exist\"))\n    ) {\n      return\n    }\n    originalConsoleError.apply(console, args)\n  }\n}\n\n// --- Custom Hook ---\n\nconst useChat = () => {\n  const navigate = useNavigate()\n\n  // State Management\n  const [user, setUser] = useState({ id: \"\", name: \"User\", avatar: \"\" })\n  const [contacts, setContacts] = useState([])\n  const [groups, setGroups] = useState([])\n  const [selectedContact, setSelectedContact] = useState(null)\n  const [messages, setMessages] = useState([])\n  const [newMessage, setNewMessage] = useState(\"\")\n  const [isConnected, setIsConnected] = useState(socket.connected) // Initial state from socket\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false)\n  const [searchQuery, setSearchQuery] = useState(\"\")\n  const [mediaFiles, setMediaFiles] = useState([])\n  const [documents, setDocuments] = useState([])\n  const [showMedia, setShowMedia] = useState(true)\n  const [showFiles, setShowFiles] = useState(false)\n  const [activeTab, setActiveTab] = useState(\"chat\")\n  const [showProfileModal, setShowProfileModal] = useState(false)\n  const [profileData, setProfileData] = useState({\n    fullName: \"\",\n    birthdate: \"\",\n    gender: \"\",\n    avatarUrl: null,\n  })\n  const [loading, setLoading] = useState(false)\n  const [showAddFriendModal, setShowAddFriendModal] = useState(false)\n  const [friendEmail, setFriendEmail] = useState(\"\")\n  const [error, setError] = useState(null)\n  const [showToast, setShowToast] = useState(false)\n  const [friendRequests, setFriendRequests] = useState([])\n  const [recoveredContacts, setRecoveredContacts] = useState([]) // Keep for recovery logic\n  const [showCreateGroupModal, setShowCreateGroupModal] = useState(false)\n  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false)\n  const [selectedGroup, setSelectedGroup] = useState(null)\n  // Thêm state lưu cache tin nhắn theo conversationId\n  const [cachedMessages, setCachedMessages] = useState({})\n\n  // Refs (Keep refs needed by the UI component)\n  const messagesEndRef = useRef(null)\n  const fileInputRef = useRef(null)\n  const imageInputRef = useRef(null)\n  const videoInputRef = useRef(null)\n\n  // Thêm state cho danh sách emoji có thể reaction\n  const reactionEmojis = [\"👍\", \"❤️\", \"😂\", \"😢\", \"🙏\", \"🎉\"]; // Danh sách emoji react\n\n  // --- Utility Functions ---\n\n  const showError = useCallback((message) => {\n    console.log(\"Showing Toast:\", message)\n    setError(message)\n    setShowToast(true)\n    // Automatically hide toast after 3 seconds (optional, if Toast component doesn't autohide)\n    // setTimeout(() => setShowToast(false), 3000);\n  }, [])\n\n  const apiCall = useCallback(\n    async (method, url, data = null, token) => {\n      try {\n        console.log(`API Call: ${method.toUpperCase()} ${url}`)\n        if (data) {\n          console.log(\"Request data:\", data instanceof FormData ? \"FormData\" : data)\n        }\n\n        const config = {\n          method,\n          url: `${API_BASE_URL}${url}`,\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n            \"If-None-Match\": \"\", // Prevent 304 responses\n          },\n          data,\n        }\n\n        if (!(data instanceof FormData)) {\n          config.headers[\"Content-Type\"] = \"application/json\"\n        }\n\n        console.log(\"Using config:\", {\n          method: config.method,\n          url: config.url,\n          headers: { ...config.headers, Authorization: \"Bearer [HIDDEN]\" },\n        })\n\n        const response = await axios(config)\n        console.log(`API Response ${url}:`, response.status, response.data)\n        return response.data\n      } catch (error) {\n        console.error(`API Error ${url}:`, error)\n        if (error.response) {\n          console.error(\"Response status:\", error.response.status)\n          console.error(\"Response data:\", error.response.data)\n        }\n\n        if (error.response?.status === 401) {\n          localStorage.removeItem(\"token\")\n          localStorage.removeItem(\"userProfile\") // Clear profile too\n          navigate(\"/login\")\n          // Use showError for consistency\n          showError(\"Phiên đăng nhập hết hạn. Vui lòng đăng nhập lại.\")\n          throw new Error(\"Phiên đăng nhập hết hạn.\") // Throw to stop further execution\n        }\n\n        const errorMessage = error.response?.data?.message || error.message || \"Đã xảy ra lỗi không xác định\"\n        // Don't automatically show toast here, let the calling function decide\n        // showError(errorMessage);\n        throw new Error(errorMessage)\n      }\n    },\n    [navigate, showError],\n  ) // Add navigate and showError as dependencies\n\n  // --- Contact and Group Management ---\n\n  const addOrUpdateContact = useCallback((newContact) => {\n    if (!newContact || !newContact.id) {\n      console.error(\"Invalid contact data:\", newContact)\n      return\n    }\n    console.log(\"Adding or updating contact:\", newContact)\n    try {\n      const savedContacts = localStorage.getItem(\"savedContacts\")\n      let contactsArray = savedContacts ? JSON.parse(savedContacts) : []\n      contactsArray = contactsArray.filter((c) => c.id !== newContact.id)\n      contactsArray.push(newContact)\n      localStorage.setItem(\"savedContacts\", JSON.stringify(contactsArray))\n      console.log(\"Saved contact to localStorage:\", newContact.id)\n    } catch (storageError) {\n      console.error(\"Error saving contact to localStorage:\", storageError)\n    }\n    setContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n    // Update recoveredContacts as well if needed, or simplify recovery logic\n    setRecoveredContacts((prev) => {\n      const exists = prev.some((contact) => contact.id === newContact.id)\n      if (exists) {\n        return prev.map((contact) => (contact.id === newContact.id ? { ...contact, ...newContact } : contact))\n      }\n      return [...prev, newContact]\n    })\n  }, [])\n\n  const addOrUpdateGroup = useCallback((newGroup) => {\n    if (!newGroup || !newGroup.groupId) {\n      console.error(\"Invalid group data:\", newGroup)\n      return\n    }\n    console.log(\"Adding or updating group:\", newGroup)\n    try {\n      const savedGroups = localStorage.getItem(\"savedGroups\")\n      let groupsArray = savedGroups ? JSON.parse(savedGroups) : []\n      groupsArray = groupsArray.filter((g) => g.groupId !== newGroup.groupId)\n      groupsArray.push(newGroup)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(groupsArray))\n      console.log(\"Saved group to localStorage:\", newGroup.groupId)\n    } catch (storageError) {\n      console.error(\"Error saving group to localStorage:\", storageError)\n    }\n    setGroups((prev) => {\n      const exists = prev.some((group) => group.groupId === newGroup.groupId)\n      if (exists) {\n        return prev.map((group) => (group.groupId === newGroup.groupId ? { ...group, ...newGroup } : group))\n      }\n      return [...prev, newGroup]\n    })\n  }, [])\n\n  // --- Data Fetching ---\n\n  const fetchUserProfile = useCallback(\n    async (token) => {\n      try {\n        const response = await apiCall(\"get\", \"/api/users/profile\", null, token)\n        const userData = {\n          id: response.userId,\n          name: response.fullName || \"User\",\n          avatar: response.avatarUrl || \"\",\n        }\n        setUser(userData)\n        setProfileData({\n          fullName: response.fullName || \"\",\n          birthdate: response.birthdate ? new Date(response.birthdate).toISOString().split(\"T\")[0] : \"\",\n          gender: response.gender || \"\",\n          avatarUrl: response.avatarUrl || null,\n        })\n        // Save profile to localStorage after fetching\n        localStorage.setItem(\"userProfile\", JSON.stringify(response))\n        return response // Return the full profile\n      } catch (error) {\n        console.error(\"Error fetching user profile:\", error)\n        showError(\"Không thể lấy thông tin người dùng: \" + error.message)\n        // No need to navigate here, apiCall handles 401\n        return null\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const fetchMessages = useCallback(\n    async (token, conversationId, isGroup = false) => {\n      if (!token || !conversationId) {\n        console.warn(\"fetchMessages called without token or conversationId\")\n        setMessages([]) // Clear messages if no ID\n        setMediaFiles([])\n        setDocuments([])\n        return\n      }\n      setLoading(true) // Indicate loading messages\n      try {\n        let response\n        // Sử dụng endpoint messages/conversations cho cả tin nhắn nhóm và cá nhân\n        const endpoint = `/api/messages/conversations/${conversationId}/messages`\n\n        console.log(\"Fetching messages from endpoint:\", endpoint)\n        response = await apiCall(\"get\", endpoint, null, token)\n        console.log(\"Messages API response:\", response)\n\n        const messagesData = Array.isArray(response) ? response : response.data || []\n\n        const mappedMessages = messagesData\n          .map((msg, index) => ({\n              id: msg.messageId || `temp-${Date.now()}-${index}`,\n              sender: msg.senderId === user.id ? \"Me\" : msg.senderName || \"Unknown\",\n              content:\n                msg.isDeleted\n                  ? \"Tin nhắn đã bị xóa\"\n                  : msg.isRecalled\n                    ? \"Tin nhắn đã bị thu hồi/xóa\"\n                    : msg.type === \"text\" || msg.type === \"emoji\" || msg.type === \"system\"\n                      ? msg.content\n                      : msg.attachments?.[0]?.url || msg.content || \"\",\n              time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n              senderId: msg.senderId,\n              isImage: !msg.isDeleted && (msg.type === \"image\" || msg.type === \"imageGroup\"),\n              isVideo: !msg.isDeleted && msg.type === \"video\",\n              isFile: !msg.isDeleted && msg.type === \"file\",\n              isUnsent: msg.isRecalled || msg.isDeleted,\n              isSystemMessage: msg.isSystemMessage || msg.senderId === \"system\",\n              fileUrl: !msg.isDeleted && msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.url : null,\n              fileName: !msg.isDeleted && msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.name : null,\n              fileType: !msg.isDeleted && msg.type === \"file\" && msg.attachments?.length > 0 ? msg.attachments[0]?.type : null,\n              duration: !msg.isDeleted && msg.type === \"video\" && msg.attachments?.length > 0 ? msg.attachments[0]?.duration : null,\n              messageDate: new Date().toLocaleDateString(),\n              reactions: msg.reactions || [], // Thêm trường reactions\n          }))\n          .filter((msg) => msg.id) // Filter out messages without an ID\n\n        // Add system message if needed\n        if (mappedMessages.length === 0 || !mappedMessages.some((msg) => msg.isSystemMessage)) {\n          const systemMessage = isGroup\n            ? \"Chào mừng bạn đến với nhóm chat!\"\n            : \"Các bạn đã trở thành bạn bè, hãy bắt đầu cuộc trò chuyện!\"\n          mappedMessages.unshift({\n            id: `system-${Date.now()}`,\n            senderId: \"system\",\n            content: systemMessage,\n            time: new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" }),\n            isSystemMessage: true,\n          })\n        }\n\n        // Merge thêm các tin nhắn cache (nếu có) mà chưa có trong mappedMessages\n        let mergedMessages = mappedMessages\n        // Lấy cache mới nhất từ localStorage thay vì chỉ lấy từ state\n        const cacheFromStorage = JSON.parse(localStorage.getItem('cachedMessages') || '{}')\n        const cacheList = cacheFromStorage[conversationId] || []\n        console.log('Cache for this conversation:', cacheList)\n        const newFromCache = cacheList.filter(\n          cacheMsg => !mappedMessages.some(msg => msg.id === cacheMsg.id)\n        )\n        mergedMessages = [...mappedMessages, ...newFromCache]\n        // Sắp xếp lại theo thời gian (nếu có trường createdAt)\n        mergedMessages.sort((a, b) => {\n          const aTime = new Date(a.createdAt || a.time || a.messageDate)\n          const bTime = new Date(b.createdAt || b.time || b.messageDate)\n          return aTime - bTime\n        })\n        console.log('Merged messages after cache merge:', mergedMessages)\n        setMessages(mergedMessages)\n\n        // Update Media and Documents\n        const media = mappedMessages\n          .filter((msg) => (msg.isImage || msg.isVideo) && !msg.isUnsent && msg.content)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.isImage ? \"image\" : \"video\",\n            url: msg.content,\n            name: msg.fileName || (msg.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0, // Might not be available, default to 0\n            duration: msg.duration,\n          }))\n        setMediaFiles(media.reverse()) // Show newest first\n\n        const files = mappedMessages\n          .filter((msg) => msg.isFile && !msg.isUnsent && msg.fileUrl)\n          .map((msg) => ({\n            id: msg.id,\n            type: msg.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: msg.fileUrl,\n            name: msg.fileName,\n            date: msg.messageDate,\n            size: msg.attachments?.[0]?.size || 0,\n          }))\n        setDocuments(files.reverse()) // Show newest first\n      } catch (error) {\n        console.error(\"Error fetching messages:\", error)\n        showError(\"Không thể tải tin nhắn: \" + error.message)\n        setMessages([]) // Clear messages on error\n        setMediaFiles([])\n        setDocuments([])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id, cachedMessages], // Depend on user.id and cachedMessages\n  )\n\n  const fetchContactsAndGroups = useCallback(\n    async (token) => {\n      if (!token) return { contacts: [], groups: [] }\n      setLoading(true)\n      let fetchedContacts = []\n      let fetchedGroups = []\n\n      try {\n        // Fetch Friends (Contacts) from server first\n        console.log(\"Fetching friends from server...\")\n        const friendsResponse = await apiCall(\"get\", \"/api/friends\", null, token)\n        console.log(\"Friends API response:\", friendsResponse)\n\n        // Lọc ra những người bạn đã được xác nhận\n        // API /api/friends đã được cải thiện để chỉ trả về bạn bè thực sự\n        const confirmedFriends = friendsResponse?.friends || []\n        console.log(\"Confirmed friends:\", confirmedFriends)\n\n        // Kiểm tra xem danh sách bạn bè có hợp lệ không\n        const validFriends = confirmedFriends.filter(friend =>\n          friend && friend.userId && friend.friendshipId\n        )\n\n        if (validFriends.length !== confirmedFriends.length) {\n          console.log(`Filtered out ${confirmedFriends.length - validFriends.length} invalid friends`)\n        }\n\n        const mappedFriends = validFriends.map((friend) => ({\n          id: friend.userId,\n          name: friend.fullName || friend.email?.split(\"@\")[0] || \"Unknown\",\n          avatar: friend.avatarUrl || \"\",\n          type: \"contact\",\n          status: \"Bạn bè\", // Trạng thái mặc định\n          friendshipId: friend.friendshipId, // Lưu friendshipId để dễ dàng xóa sau này\n          conversationId: null, // Will be populated later\n        }))\n\n        // Fetch Conversations to get conversation IDs\n        console.log(\"Fetching conversations...\")\n        const convResponse = await apiCall(\"get\", \"/api/messages/conversations\", null, token)\n        const conversationsMap = new Map()\n        if (convResponse && Array.isArray(convResponse)) {\n          convResponse.forEach((conv) => {\n            if (conv.participants && conv.participants.length === 2 && conv.conversationId) {\n              const otherUserId = conv.participants.find((id) => id !== user.id)\n              if (otherUserId) {\n                conversationsMap.set(otherUserId, conv.conversationId)\n              }\n            }\n          })\n        }\n\n        // Update conversationId for mapped friends\n        mappedFriends.forEach((friend) => {\n          if (conversationsMap.has(friend.id)) {\n            friend.conversationId = conversationsMap.get(friend.id)\n          }\n        })\n\n        // Merge with existing contacts to preserve any additional data\n        const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n\n        // Create a map of existing contacts for quick lookup\n        const existingContactsMap = new Map()\n        savedContacts.forEach(contact => {\n          if (contact && contact.id) {\n            existingContactsMap.set(contact.id, contact)\n          }\n        })\n\n        // Merge server data with existing data, prioritizing server data\n        fetchedContacts = mappedFriends.map(friend => {\n          const existingContact = existingContactsMap.get(friend.id)\n          if (existingContact) {\n            // Preserve conversationId if it exists in saved contact but not in server data\n            if (!friend.conversationId && existingContact.conversationId) {\n              friend.conversationId = existingContact.conversationId\n            }\n            return { ...existingContact, ...friend }\n          }\n          return friend\n        })\n\n        // Update state and localStorage\n        setContacts(fetchedContacts)\n        localStorage.setItem(\"savedContacts\", JSON.stringify(fetchedContacts))\n        console.log(\"Updated contacts from API:\", fetchedContacts.length)\n\n        // Fetch Groups\n        console.log(\"Fetching groups...\")\n        const groupsResponse = await apiCall(\"get\", \"/api/groups\", null, token)\n        console.log(\"Groups API response:\", groupsResponse)\n\n        if (groupsResponse && groupsResponse.groups) {\n          // Lọc các nhóm mà người dùng là thành viên\n          const userGroups = groupsResponse.groups.filter(\n            (group) => group.members && group.members.some(member => member.userId === user.id)\n          )\n          console.log(`Filtered user groups: ${userGroups.length} out of ${groupsResponse.groups.length}`)\n\n          fetchedGroups = userGroups.map((group) => ({\n            groupId: group.groupId,\n            id: group.groupId,\n            name: group.name,\n            avatar: group.avatarUrl || \"\",\n            type: \"group\",\n            adminId: group.admin,\n            admin: group.admin,\n            members: group.members || [], // Lưu toàn bộ thông tin thành viên\n            memberIds: group.members?.map(member => member.userId) || [], // Thêm mảng memberIds để dễ kiểm tra\n            memberCount: group.memberCount || group.members?.length || 0,\n            conversationId: group.conversationId,\n            createdAt: group.createdAt,\n          }))\n          setGroups(fetchedGroups)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(fetchedGroups))\n          console.log(\"Updated groups from API:\", fetchedGroups.length)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } catch (error) {\n        console.error(\"Error fetching contacts/groups:\", error)\n        showError(\"Không thể tải danh bạ/nhóm: \" + error.message)\n\n        // Fallback to localStorage only if server fetch fails\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n\n          if (savedContacts.length > 0) {\n            console.log(\"Falling back to contacts from localStorage\")\n            setContacts(savedContacts)\n            fetchedContacts = savedContacts\n          }\n\n          if (savedGroups.length > 0) {\n            console.log(\"Falling back to groups from localStorage\")\n            setGroups(savedGroups)\n            fetchedGroups = savedGroups\n          }\n        } catch (e) {\n          console.error(\"Error reading contacts/groups from localStorage\", e)\n        }\n\n        return { contacts: fetchedContacts, groups: fetchedGroups }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, user.id], // Depend on user.id for conversation mapping\n  )\n\n  const fetchFriendRequests = useCallback(\n    async (token) => {\n      if (!token) return\n      // No need for setLoading(true) here unless it's a primary action\n      try {\n        const response = await apiCall(\"get\", \"/api/friends/requests/received\", null, token)\n        setFriendRequests(response.data || [])\n      } catch (error) {\n        console.error(\"Không thể lấy danh sách lời mời kết bạn:\", error)\n        // showError(\"Lỗi tải lời mời kết bạn: \" + error.message); // Optional: show error\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Conversation Handling ---\n\n  const createOrGetConversation = useCallback(\n    async (otherUserId, token) => {\n      console.log(`Creating/getting conversation with user: ${otherUserId}`)\n      if (!token || !otherUserId) {\n        throw new Error(\"Token or otherUserId missing for createOrGetConversation\")\n      }\n      try {\n        const response = await apiCall(\"get\", `/api/messages/conversations/user/${otherUserId}`, null, token)\n        if (response?.conversation?.conversationId) {\n          console.log(\"Successfully created/retrieved conversation ID:\", response.conversation.conversationId)\n          return response.conversation.conversationId\n        } else {\n          throw new Error(\"Invalid response structure from conversation API\")\n        }\n      } catch (error) {\n        console.error(\"Error in createOrGetConversation:\", error)\n        if (error.message.includes(\"403\") || error.message.includes(\"only chat with friends\")) {\n          throw new Error(\"Bạn chỉ có thể nhắn tin với bạn bè\")\n        }\n        throw new Error(`Không thể tạo/lấy cuộc trò chuyện: ${error.message}`) // Rethrow with context\n      }\n    },\n    [apiCall],\n  )\n\n  // --- Contact/Group Selection ---\n\n  const handleContactSelect = useCallback(\n    async (contactOrGroup) => {\n      if (!contactOrGroup || contactOrGroup.id === selectedContact?.id) {\n        console.log(\"Selection unchanged or invalid.\")\n        return // Avoid re-selecting the same contact/group\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        navigate(\"/login\")\n        return\n      }\n\n      console.log(\"Selected:\", contactOrGroup.type, contactOrGroup.name, contactOrGroup.id)\n\n      // Leave previous room\n      if (selectedContact) {\n        const roomToLeave =\n          selectedContact.type === \"group\" ? selectedContact.groupId : selectedContact.conversationId\n        if (roomToLeave) {\n          const eventName = selectedContact.type === \"group\" ? \"leave_group\" : \"leave_conversation\"\n          socket.emit(eventName, roomToLeave)\n          console.log(`Left ${selectedContact.type} room:`, roomToLeave)\n        }\n      }\n\n      // Clear previous state\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n      setSelectedContact(contactOrGroup) // Set selected contact immediately for UI update\n\n      try {\n        setLoading(true) // Show loading for message fetch\n\n        if (contactOrGroup.type === \"group\") {\n          const groupId = contactOrGroup.groupId\n          // Sử dụng conversationId từ group object\n          const conversationId = contactOrGroup.conversationId || groupId\n          socket.emit(\"join_group\", groupId)\n          console.log(\"Joined group room:\", groupId)\n          console.log(\"Using conversationId for group:\", conversationId)\n          await fetchMessages(token, conversationId, true)\n        } else {\n          // Handle individual contact\n          let conversationId = contactOrGroup.conversationId\n\n          // If conversationId is missing, try to fetch/create it\n          if (!conversationId) {\n            console.log(\"Conversation ID missing, attempting to fetch/create...\")\n            try {\n              conversationId = await createOrGetConversation(contactOrGroup.id, token)\n              // Update the contact in the list and the selected contact state\n              const updatedContact = { ...contactOrGroup, conversationId }\n              setSelectedContact(updatedContact) // Update selected state with new ID\n              setContacts((prev) => prev.map((c) => (c.id === contactOrGroup.id ? updatedContact : c)))\n              // Optionally save updated contacts list to localStorage\n              const currentContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n              const updatedContactsList = currentContacts.map((c) =>\n                c.id === contactOrGroup.id ? updatedContact : c,\n              )\n              localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContactsList))\n            } catch (error) {\n              showError(error.message) // Show error from createOrGetConversation\n              setSelectedContact(null) // Deselect if conversation fails\n              setLoading(false)\n              return // Stop execution if conversation fails\n            }\n          }\n\n          if (conversationId) {\n            socket.emit(\"join_conversation\", conversationId)\n            console.log(\"Joined conversation room:\", conversationId)\n            await fetchMessages(token, conversationId, false)\n\n            // Mark conversation as read with proper request body\n            try {\n              await apiCall(\"put\", `/api/messages/conversations/${conversationId}/read`, { read: true }, token)\n\n              // Update contacts list to remove unread badge\n              setContacts((prev) =>\n                prev.map((c) =>\n                  c.id === contactOrGroup.id ? { ...c, unreadCount: 0 } : c\n                )\n              )\n            } catch (readError) {\n              console.error(\"Error marking conversation as read:\", readError)\n              // Don't show error to user since this is a non-critical operation\n            }\n          } else {\n            // This case should ideally not be reached if createOrGetConversation throws errors\n            showError(\"Không thể tìm thấy hoặc tạo cuộc trò chuyện.\")\n            setSelectedContact(null)\n          }\n        }\n      } catch (error) {\n        // Catch errors from fetchMessages or socket emits\n        console.error(\"Error in handleContactSelect processing:\", error)\n        showError(`Lỗi khi chọn liên hệ: ${error.message}`)\n        setSelectedContact(null) // Deselect on error\n      } finally {\n        setLoading(false) // Ensure loading is turned off\n      }\n    },\n    [selectedContact, fetchMessages, createOrGetConversation, showError, navigate, apiCall, cachedMessages],\n  )\n\n  // --- Message Sending ---\n\n  const handleSendMessage = useCallback(\n    async (e) => {\n      e.preventDefault()\n      if (!newMessage.trim() || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      const tempMessageId = `temp-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: newMessage,\n        time: messageTime,\n        senderId: user.id,\n        isSending: true, // Indicate sending state\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      const messageToSend = newMessage // Store message before clearing\n      setNewMessage(\"\") // Clear input immediately\n      scrollToBottom() // Scroll after adding optimistic message\n\n      try {\n        let response\n        let messageDataForSocket\n\n        if (selectedContact.type === \"group\") {\n          const groupId = selectedContact.groupId\n          console.log(\"Attempting to send group message:\", {\n            groupId,\n            messageContent: messageToSend,\n            selectedContact\n          })\n\n          if (!groupId) {\n            throw new Error(\"GroupId is missing\")\n          }\n\n          // Kiểm tra xem người dùng có phải là thành viên của nhóm không\n          if (!selectedContact.memberIds?.includes(user.id)) {\n            console.error(\"User not in group members:\", {\n              userId: user.id,\n              memberIds: selectedContact.memberIds,\n              members: selectedContact.members\n            })\n            throw new Error(\"Bạn không phải là thành viên của nhóm này\")\n          }\n\n          try {\n            response = await apiCall(\n              \"post\", \n              `/api/groups/${groupId}/messages`, \n              { content: messageToSend }, \n              token\n            )\n            \n            console.log(\"Group message API response:\", response)\n            \n            if (!response) {\n              throw new Error(\"No response from server\")\n            }\n\n            if (!response.messageData) {\n              console.error(\"Invalid response structure:\", response)\n              throw new Error(\"Invalid response structure from server\")\n            }\n            \n            const messageData = response.messageData\n            messageDataForSocket = {\n              messageId: messageData.messageId,\n              groupId: groupId,\n              senderId: user.id,\n              senderName: user.name,\n              content: messageToSend,\n              type: \"text\",\n              createdAt: messageData.createdAt || new Date().toISOString(),\n            }\n\n            console.log(\"Emitting socket event with data:\", messageDataForSocket)\n            socket.emit(\"group_message\", messageDataForSocket)\n\n            // Update optimistic message with real ID and remove sending state\n            setMessages((prev) =>\n              prev.map((msg) =>\n                msg.id === tempMessageId\n                  ? {\n                      ...msg,\n                      id: messageData.messageId,\n                      isSending: false,\n                      time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    }\n                  : msg\n              )\n            )\n          } catch (error) {\n            console.error(\"Error details:\", {\n              error,\n              groupId,\n              selectedContact,\n              user: { id: user.id, name: user.name }\n            })\n            \n            if (error.response?.status === 404) {\n              throw new Error(\"Không tìm thấy nhóm chat\")\n            } else if (error.response?.status === 403) {\n              throw new Error(\"Bạn không có quyền gửi tin nhắn trong nhóm này\")\n            } else {\n              throw error\n            }\n          }\n        } else {\n          // Handle individual contact message sending\n          const conversationId = selectedContact.conversationId\n          if (!conversationId) {\n            throw new Error(\"Không tìm thấy cuộc trò chuyện để gửi tin nhắn\")\n          }\n          response = await apiCall(\n            \"post\",\n            \"/api/messages/send/text\",\n            { \n              conversationId: conversationId, \n              content: messageToSend,\n              tempMessageId: tempMessageId // Add tempMessageId to help match response\n            },\n            token\n          )\n          messageDataForSocket = {\n            messageId: response.messageData?.messageId || response.messageId,\n            tempMessageId: tempMessageId, // Include tempMessageId in socket event\n            conversationId: conversationId,\n            senderId: user.id,\n            senderName: user.name,\n            receiverId: selectedContact.id,\n            content: messageToSend,\n            type: \"text\",\n            createdAt: response.messageData?.createdAt || new Date().toISOString(),\n            time: messageTime // Include original time for matching\n          }\n          socket.emit(\"new_message\", messageDataForSocket)\n        }\n      } catch (error) {\n        console.error(\"Error sending message:\", error)\n        showError(\"Không thể gửi tin nhắn: \" + error.message)\n        // Remove or mark optimistic message as failed\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n      }\n    },\n    [newMessage, isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  // --- File/Media Sending ---\n\n  const handleSendFile = useCallback(\n    async (file, fileType = \"file\") => {\n      // fileType can be 'file', 'image', 'video'\n      if (!file || !isConnected || !selectedContact) return\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) {\n        showError(\"Vui lòng đăng nhập lại.\")\n        return\n      }\n\n      // Size/Type checks (already done in Home.jsx handlers, but good to have here too)\n      const maxSize = 50 * 1024 * 1024 // 50MB\n      if (file.size > maxSize) {\n        showError(`File quá lớn (tối đa ${maxSize / (1024 * 1024)}MB)`)\n        return\n      }\n      if (fileType === \"image\" && !file.type.startsWith(\"image/\")) {\n        showError(\"Chỉ chấp nhận file hình ảnh.\")\n        return\n      }\n      if (fileType === \"video\" && !file.type.startsWith(\"video/\")) {\n        showError(\"Chỉ chấp nhận file video.\")\n        return\n      }\n\n      // Video duration check\n      let videoDuration = null\n      if (fileType === \"video\") {\n        try {\n          const duration = await getVideoDuration(file)\n          if (duration > 90) {\n            showError(\"Video không được dài quá 90 giây.\")\n            return\n          }\n          videoDuration = Math.round(duration)\n        } catch (err) {\n          showError(\"Không thể đọc thông tin video.\")\n          return\n        }\n      }\n\n      const tempMessageId = `temp-file-${Date.now()}`\n      const messageTime = new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      const tempUrl = URL.createObjectURL(file) // For optimistic UI\n\n      // Optimistic UI update\n      const optimisticMessage = {\n        id: tempMessageId,\n        sender: \"Me\",\n        content: fileType === \"text\" ? file.name : tempUrl, // Use tempUrl for image/video\n        time: messageTime,\n        senderId: user.id,\n        isSending: true,\n        isFile: fileType === \"file\",\n        isImage: fileType === \"image\",\n        isVideo: fileType === \"video\",\n        fileName: file.name,\n        fileType: file.type,\n        duration: videoDuration,\n      }\n      setMessages((prev) => [...prev, optimisticMessage])\n      scrollToBottom()\n\n      const formData = new FormData()\n      let apiUrl = \"\"\n      let apiKey = \"\" // Key for the file in FormData\n\n      if (selectedContact.type === \"group\") {\n        const groupId = selectedContact.groupId\n        formData.append(\"groupId\", groupId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = `/api/groups/${groupId}/images`\n            apiKey = \"image\" // Match backend key\n            break\n          case \"video\":\n            apiUrl = `/api/groups/${groupId}/videos`\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = `/api/groups/${groupId}/files`\n            apiKey = \"file\"\n            break\n        }\n      } else {\n        const conversationId = selectedContact.conversationId\n        if (!conversationId) {\n          showError(\"Không tìm thấy cuộc trò chuyện để gửi file\")\n          URL.revokeObjectURL(tempUrl)\n          setMessages((prev) => prev.filter((msg) => msg.id !== tempMessageId)) // Remove optimistic msg\n          return\n        }\n        formData.append(\"conversationId\", conversationId)\n        switch (fileType) {\n          case \"image\":\n            apiUrl = \"/api/messages/send/image\"\n            apiKey = \"images\" // Match backend key (plural for this endpoint)\n            break\n          case \"video\":\n            apiUrl = \"/api/messages/send/video\"\n            apiKey = \"video\"\n            break\n          default: // file\n            apiUrl = \"/api/messages/send/file\"\n            apiKey = \"file\"\n            break\n        }\n      }\n\n      formData.append(apiKey, file)\n\n      try {\n        const response = await apiCall(\"post\", apiUrl, formData, token)\n        const messageData = response.messageData || response // Adjust based on API response structure\n        const attachment = messageData.attachments?.[0]\n\n        if (!messageData || !messageData.messageId || !attachment || !attachment.url) {\n          throw new Error(\"Phản hồi API không hợp lệ sau khi gửi file.\")\n        }\n\n        // Update optimistic message\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === tempMessageId\n              ? {\n                  ...msg,\n                  id: messageData.messageId,\n                  content: attachment.url, // Use final URL\n                  fileUrl: fileType === \"file\" ? attachment.url : null,\n                  isSending: false,\n                  time: new Date(messageData.createdAt).toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                  }),\n                }\n              : msg,\n          ),\n        )\n\n        // Update media/documents list\n        const newItem = {\n          id: messageData.messageId,\n          type: fileType === \"file\" ? file.name.split(\".\").pop().toLowerCase() : fileType,\n          url: attachment.url,\n          name: attachment.name || file.name,\n          date: new Date(messageData.createdAt).toLocaleDateString(),\n          size: attachment.size || file.size,\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        if (fileType === \"image\" || fileType === \"video\") {\n          setMediaFiles((prev) => [newItem, ...prev]) // Add to beginning (newest)\n        } else {\n          setDocuments((prev) => [newItem, ...prev])\n        }\n\n        // Emit socket event\n        const socketEventData = {\n          messageId: messageData.messageId,\n          conversationId: selectedContact.type === \"group\" ? null : selectedContact.conversationId,\n          groupId: selectedContact.type === \"group\" ? selectedContact.groupId : null,\n          senderId: user.id,\n          senderName: user.name,\n          receiverId: selectedContact.type === \"group\" ? null : selectedContact.id,\n          type: fileType, // 'file', 'image', 'video'\n          content: fileType === \"file\" ? `File: ${attachment.name || file.name}` : null, // Content might be null for media\n          attachments: messageData.attachments,\n          createdAt: messageData.createdAt || new Date().toISOString(),\n          duration: fileType === \"video\" ? videoDuration || attachment.duration : null,\n        }\n        const socketEventName = selectedContact.type === \"group\" ? \"group_message\" : \"new_message\"\n        socket.emit(socketEventName, socketEventData)\n\n        URL.revokeObjectURL(tempUrl) // Clean up temp URL\n      } catch (error) {\n        console.error(`Error sending ${fileType}:`, error)\n        showError(`Không thể gửi ${fileType}: ${error.message}`)\n        setMessages((prev) =>\n          prev.map((msg) => (msg.id === tempMessageId ? { ...msg, isSending: false, isError: true } : msg)),\n        )\n        URL.revokeObjectURL(tempUrl)\n      }\n    },\n    [isConnected, selectedContact, apiCall, showError, user.id, user.name],\n  )\n\n  const getVideoDuration = (file) => {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement(\"video\")\n      video.preload = \"metadata\"\n      video.onloadedmetadata = () => {\n        URL.revokeObjectURL(video.src)\n        resolve(video.duration)\n      }\n      video.onerror = () => {\n        URL.revokeObjectURL(video.src)\n        reject(new Error(\"Không thể tải metadata video\"))\n      }\n      video.src = URL.createObjectURL(file)\n    })\n  }\n\n  // --- Other Handlers ---\n\n  const handleEmojiSelect = useCallback((emoji) => {\n    setNewMessage((prev) => prev + emoji)\n    setShowEmojiPicker(false)\n  }, [])\n\n  const handleMessageAction = useCallback(\n    async (messageId, action) => {\n      if (action === \"delete\") {\n        const token = localStorage.getItem(\"token\")\n        if (!token || !selectedContact) return\n\n        // Optimistic UI update\n        const originalMessages = [...messages]\n        setMessages((prev) =>\n          prev.map((msg) =>\n            msg.id === messageId ? { ...msg, content: \"Đang xóa...\", isUnsent: true, isDeleting: true } : msg,\n          ),\n        )\n\n        try {\n          if (selectedContact.type === \"group\") {\n            await apiCall(\"delete\", `/api/groups/${selectedContact.groupId}/messages/${messageId}`, undefined, token)\n          } else {\n            await apiCall(\"delete\", `/api/messages/${messageId}`, undefined, token)\n          }\n\n          // Confirm deletion in UI\n          setMessages((prev) =>\n            prev.map((msg) =>\n              msg.id === messageId ? { ...msg, content: \"Tin nhắn đã bị xóa\", isDeleting: false } : msg,\n            ),\n          )\n\n          // Remove from media/documents lists\n          setMediaFiles((prev) => prev.filter((media) => media.id !== messageId))\n          setDocuments((prev) => prev.filter((doc) => doc.id !== messageId))\n\n          // TODO: Emit socket event for deletion if needed by backend/other clients\n        } catch (error) {\n          console.error(\"Error deleting message:\", error)\n          showError(\"Không thể xóa tin nhắn: \" + error.message)\n          // Revert optimistic update on error\n          setMessages(originalMessages)\n        }\n      }\n      // Handle other actions like 'recall' if implemented\n    },\n    [apiCall, selectedContact, showError, messages], // Include messages in dependency array\n  )\n\n  const toggleMediaView = useCallback(() => {\n    setShowMedia(true)\n    setShowFiles(false)\n  }, [])\n\n  const toggleFilesView = useCallback(() => {\n    setShowMedia(false)\n    setShowFiles(true)\n  }, [])\n\n  const handleTabChange = useCallback((tab) => {\n    setActiveTab(tab)\n    // Fetch friend requests when switching to contacts tab\n    if (tab === \"contacts\") {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchFriendRequests(token)\n      }\n    }\n  }, [fetchFriendRequests]) // Add fetchFriendRequests dependency\n\n  const handleProfileClick = useCallback(() => {\n    // Ensure profile data is current before showing modal\n    const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n    setProfileData({\n      fullName: userProfile.fullName || user.name || \"\",\n      birthdate: userProfile.birthdate ? new Date(userProfile.birthdate).toISOString().split(\"T\")[0] : \"\",\n      gender: userProfile.gender || \"\",\n      avatarUrl: userProfile.avatarUrl || user.avatar || null,\n    })\n    setShowProfileModal(true)\n  }, [user.name, user.avatar]) // Depend on user state\n\n  const handleCloseProfileModal = useCallback(() => {\n    setShowProfileModal(false)\n  }, [])\n\n  const handleAvatarChange = useCallback(\n    async (file) => {\n      // File validation\n      if (!file || !file.type.startsWith(\"image/\") || file.size > 5 * 1024 * 1024) {\n        showError(\"Avatar không hợp lệ hoặc quá lớn (>5MB)\")\n        return\n      }\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const formData = new FormData()\n      formData.append(\"avatar\", file)\n\n      try {\n        setLoading(true) // Indicate loading\n        const response = await apiCall(\"post\", \"/api/users/avatar\", formData, token)\n        // Update state optimistically/realistically\n        setProfileData((prev) => ({ ...prev, avatarUrl: response.avatarUrl }))\n        setUser((prev) => ({ ...prev, avatar: response.avatarUrl }))\n        // Update localStorage userProfile\n        const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n        userProfile.avatarUrl = response.avatarUrl\n        localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n        showError(\"Cập nhật ảnh đại diện thành công!\")\n      } catch (error) {\n        showError(\"Không thể tải avatar: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError],\n  )\n\n  const handleUpdateProfile = useCallback(async () => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    try {\n      setLoading(true)\n      const response = await apiCall(\n        \"put\",\n        \"/api/users/profile\",\n        {\n          fullName: profileData.fullName,\n          // Ensure birthdate is sent correctly or omitted if empty\n          birthdate: profileData.birthdate ? new Date(profileData.birthdate).toISOString() : undefined,\n          gender: profileData.gender || undefined, // Send undefined if empty to potentially clear it\n        },\n        token,\n      )\n      // Update user state\n      setUser((prev) => ({\n        ...prev,\n        name: response.fullName || prev.name,\n        // Avatar might not be in this response, keep existing one\n      }))\n      // Update localStorage userProfile\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      userProfile.fullName = response.fullName\n      userProfile.birthdate = response.birthdate\n      userProfile.gender = response.gender\n      localStorage.setItem(\"userProfile\", JSON.stringify(userProfile))\n\n      showError(\"Cập nhật hồ sơ thành công!\")\n      handleCloseProfileModal()\n    } catch (error) {\n      showError(\"Không thể cập nhật hồ sơ: \" + error.message)\n    } finally {\n      setLoading(false)\n    }\n  }, [apiCall, profileData, showError, handleCloseProfileModal])\n\n  const handleAddFriend = useCallback(() => {\n    setShowAddFriendModal(true)\n  }, [])\n\n  const handleCloseAddFriendModal = useCallback(() => {\n    setShowAddFriendModal(false)\n    setFriendEmail(\"\") // Reset email field\n  }, [])\n\n  const handleSubmitAddFriend = useCallback(async () => {\n    if (!friendEmail.trim()) {\n      showError(\"Vui lòng nhập email\")\n      return\n    }\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(friendEmail)) {\n      showError(\"Email không hợp lệ.\")\n      return\n    }\n\n    const token = localStorage.getItem(\"token\")\n    if (!token) return\n\n    setLoading(true)\n    try {\n      // Search user first to get ID\n      const searchResult = await apiCall(\n        \"get\",\n        `/api/users/search?query=${encodeURIComponent(friendEmail)}`,\n        null,\n        token,\n      )\n      if (!searchResult?.data?.length) {\n        throw new Error(\"Không tìm thấy người dùng với email này\")\n      }\n      const receiverId = searchResult.data[0].userId\n\n      if (receiverId === user.id) {\n        throw new Error(\"Bạn không thể tự kết bạn với chính mình\")\n      }\n\n      // Check if already friends\n      if (contacts.some((c) => c.id === receiverId)) {\n        throw new Error(\"Bạn và người này đã là bạn bè\")\n      }\n\n      // Check existing sent requests (optional, backend might handle this)\n      // const existingSent = await apiCall(\"get\", `/api/friends/requests/sent`, null, token);\n      // if (existingSent?.data?.some(req => req.receiver.userId === receiverId)) {\n      //     throw new Error(\"Bạn đã gửi lời mời kết bạn cho người này rồi\");\n      // }\n\n      // Send request\n      await apiCall(\"post\", \"/api/friends/requests\", { receiverId, message: `Kết bạn từ ${user.name}` }, token)\n      showError(`Đã gửi lời mời kết bạn đến ${friendEmail}`)\n      handleCloseAddFriendModal()\n    } catch (error) {\n      // Handle specific errors from backend if available\n      if (error.message.includes(\"already friends\")) {\n        showError(`Bạn và ${friendEmail} đã là bạn bè.`)\n      } else if (error.message.includes(\"request already sent\")) {\n        showError(`Bạn đã gửi lời mời kết bạn cho ${friendEmail} trước đó.`)\n      } else if (error.message.includes(\"pending request from this user\")) {\n        showError(`${friendEmail} đã gửi lời mời kết bạn cho bạn. Vui lòng kiểm tra lời mời.`)\n      } else {\n        showError(`Lỗi: ${error.message || \"Không thể gửi lời mời kết bạn\"}`)\n      }\n      // Don't close modal on error, let user see the message\n      // handleCloseAddFriendModal();\n    } finally {\n      setLoading(false)\n    }\n  }, [friendEmail, apiCall, showError, handleCloseAddFriendModal, user.name, user.id, contacts])\n\n  const handleRespondToFriendRequest = useCallback(\n    async (requestId, action) => {\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      const request = friendRequests.find((req) => req.requestId === requestId)\n      if (!request) return\n\n      setLoading(true) // Indicate processing\n      // Optimistically remove from list\n      setFriendRequests((prev) => prev.filter((req) => req.requestId !== requestId))\n\n      try {\n        const response = await apiCall(\"post\", \"/api/friends/requests/respond\", { requestId, action }, token)\n        console.log(\"Friend request response:\", response)\n\n        if (action === \"accept\") {\n          showError(\"Đã chấp nhận lời mời kết bạn\")\n          const senderInfo = request.sender\n          if (!senderInfo || !senderInfo.userId) {\n            throw new Error(\"Thông tin người gửi không hợp lệ\")\n          }\n\n          // Get conversation ID (might be in response or need creation)\n          let conversationId = response.conversation?.conversationId\n          if (!conversationId) {\n            console.log(\"No conversationId in response, creating/getting...\")\n            conversationId = await createOrGetConversation(senderInfo.userId, token)\n          }\n\n          if (!conversationId) {\n            throw new Error(\"Không thể tạo hoặc lấy cuộc trò chuyện\")\n          }\n\n          // Create new contact object\n          const newContact = {\n            id: senderInfo.userId,\n            name: senderInfo.fullName || senderInfo.email?.split(\"@\")[0] || \"Unknown\",\n            avatar: senderInfo.avatarUrl || \"\",\n            type: \"contact\",\n            status: \"Bạn bè\",\n            conversationId: conversationId,\n          }\n\n          addOrUpdateContact(newContact) // Add/update contact list and localStorage\n\n          // Optionally select the new contact immediately\n          // handleContactSelect(newContact);\n\n          // Emit notification to the sender via socket\n          if (socket.connected) {\n            socket.emit(\"friend_request_accepted_notify\", {\n              accepter: { userId: user.id, fullName: user.name, avatarUrl: user.avatar },\n              senderId: senderInfo.userId, // Target the sender\n              conversationId: conversationId,\n            })\n            // Also tell sender to refresh their list\n            socket.emit(\"refresh_contacts_notify\", { targetUserId: senderInfo.userId })\n            console.log(\"Emitted friend_request_accepted_notify and refresh_contacts_notify\")\n          }\n        } else {\n          showError(\"Đã từ chối lời mời kết bạn\")\n          // Optionally notify sender of rejection via socket\n        }\n      } catch (error) {\n        console.error(\"Error responding to friend request:\", error)\n        showError(\"Không thể phản hồi lời mời: \" + error.message)\n        // Revert optimistic removal on error\n        setFriendRequests((prev) => [...prev, request])\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, friendRequests, showError, createOrGetConversation, addOrUpdateContact, user],\n  )\n\n  const handleRemoveFriend = useCallback(\n    async (friendId) => {\n      if (!window.confirm(\"Bạn có chắc muốn xóa người này khỏi danh sách bạn bè không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      console.log(`Attempting to remove friend with ID: ${friendId}`)\n      setLoading(true)\n\n      // Lưu trữ thông tin liên hệ trước khi xóa để có thể khôi phục nếu cần\n      const contactToRemove = contacts.find(contact => contact.id === friendId && contact.type === \"contact\")\n      if (!contactToRemove) {\n        showError(\"Không tìm thấy người dùng trong danh sách bạn bè\")\n        setLoading(false)\n        return\n      }\n\n      // Tạo bản sao của danh sách bạn bè hiện tại để khôi phục nếu cần\n      const currentContacts = [...contacts]\n\n      try {\n        // Cập nhật UI trước khi gọi API (optimistic update)\n        setContacts((prev) => prev.filter((contact) => contact.id !== friendId || contact.type !== \"contact\"))\n\n        // Cập nhật localStorage\n        try {\n          const savedContacts = JSON.parse(localStorage.getItem(\"savedContacts\") || \"[]\")\n          const updatedContacts = savedContacts.filter((c) => c.id !== friendId || c.type !== \"contact\")\n          localStorage.setItem(\"savedContacts\", JSON.stringify(updatedContacts))\n        } catch (e) {\n          console.error(\"Error updating localStorage after friend removal\", e)\n        }\n\n        // Bỏ chọn nếu đang được chọn\n        if (selectedContact?.id === friendId && selectedContact?.type === \"contact\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        // Gọi API để xóa bạn bè\n        try {\n          console.log(`Calling API to remove friend: ${friendId}`)\n          const response = await apiCall(\"delete\", `/api/friends/${friendId}`, undefined, token)\n          console.log(\"Friend removal API response:\", response)\n\n          showError(\"Đã xóa bạn bè thành công\")\n\n          // Thông báo cho người bạn bị xóa qua socket\n          if (socket && socket.connected) {\n            socket.emit(\"friend_removed_notify\", { removerId: user.id, removedUserId: friendId })\n            console.log(\"Emitted friend_removed_notify\")\n\n            // Thông báo cập nhật danh sách bạn bè\n            socket.emit(\"friend_list_updated\")\n          }\n\n          // Cập nhật lại danh sách bạn bè từ server\n          fetchContactsAndGroups(token)\n        } catch (apiError) {\n          console.error(\"API error removing friend:\", apiError)\n\n          // Kiểm tra lỗi cụ thể\n          if (apiError.response && apiError.response.status === 404) {\n            // Nếu lỗi là \"Friendship not found\", có thể bạn bè đã bị xóa trước đó\n            showError(\"Mối quan hệ bạn bè không tồn tại hoặc đã bị xóa trước đó\")\n            // Cập nhật lại danh sách bạn bè từ server\n            fetchContactsAndGroups(token)\n          } else {\n            // Đối với các lỗi khác, hiển thị thông báo và khôi phục UI\n            showError(\"Lỗi khi xóa bạn bè: \" + (apiError.message || \"Lỗi không xác định\"))\n            // Khôi phục lại danh sách bạn bè\n            setContacts(currentContacts)\n\n            // Khôi phục localStorage\n            try {\n              localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n            } catch (e) {\n              console.error(\"Error restoring localStorage\", e)\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error in handleRemoveFriend:\", error)\n        showError(\"Không thể xóa bạn bè: \" + error.message)\n\n        // Khôi phục lại danh sách bạn bè\n        setContacts(currentContacts)\n\n        // Khôi phục localStorage\n        try {\n          localStorage.setItem(\"savedContacts\", JSON.stringify(currentContacts))\n        } catch (e) {\n          console.error(\"Error restoring localStorage\", e)\n        }\n      } finally {\n        setLoading(false)\n      }\n    },\n    [apiCall, showError, selectedContact, user.id, contacts, fetchContactsAndGroups],\n  )\n\n  // --- Group Handlers ---\n  const handleCreateGroup = useCallback(() => {\n    setShowCreateGroupModal(true)\n  }, [])\n\n  const handleGroupCreated = useCallback(\n    (newGroupData) => {\n      console.log(\"Group created data:\", newGroupData)\n      const groupObject = {\n        groupId: newGroupData.groupId,\n        id: newGroupData.groupId, // Add id for consistency\n        name: newGroupData.name,\n        avatar: newGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: newGroupData.adminId,\n        memberCount: newGroupData.members?.length || 1, // At least admin is a member\n        conversationId: newGroupData.conversationId || newGroupData.groupId,\n        createdAt: newGroupData.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      setShowCreateGroupModal(false)\n      showError(`Đã tạo nhóm \"${newGroupData.name}\" thành công`)\n      // Automatically select the new group\n      handleContactSelect(groupObject)\n    },\n    [addOrUpdateGroup, showError, handleContactSelect],\n  )\n\n  const handleGroupInfo = useCallback(\n    (group) => {\n      // Fetch full group details if necessary before showing modal\n      setSelectedGroup(group) // Pass the basic group info for now\n      setShowGroupInfoModal(true)\n      // TODO: Optionally fetch full member list etc. inside GroupInfoModal or here\n    },\n    [], // No dependencies needed to just show the modal\n  )\n\n  const handleGroupUpdated = useCallback(\n    (updatedGroupData) => {\n      console.log(\"Group updated data:\", updatedGroupData)\n      // Ensure the data structure matches what addOrUpdateGroup expects\n      const groupObject = {\n        groupId: updatedGroupData.groupId,\n        id: updatedGroupData.groupId,\n        name: updatedGroupData.name,\n        avatar: updatedGroupData.avatarUrl || \"\",\n        type: \"group\",\n        adminId: updatedGroupData.adminId,\n        memberCount: updatedGroupData.memberCount || updatedGroupData.members?.length || 0,\n        conversationId: updatedGroupData.conversationId || updatedGroupData.groupId,\n        createdAt: updatedGroupData.createdAt,\n        // Include other relevant fields if needed\n      }\n      addOrUpdateGroup(groupObject)\n      // Update selected contact if it's the one being edited\n      if (selectedContact?.id === groupObject.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n      setShowGroupInfoModal(false) // Close modal on success\n      showError(`Đã cập nhật thông tin nhóm \"${groupObject.name}\"`)\n    },\n    [addOrUpdateGroup, selectedContact, showError],\n  )\n\n  const handleLeaveGroup = useCallback(\n    async (groupId) => {\n      console.log(\"Leaving group:\", groupId)\n\n      if (!window.confirm(\"Bạn có chắc muốn rời khỏi nhóm này không?\")) {\n        return\n      }\n\n      const token = localStorage.getItem(\"token\")\n      if (!token) return\n\n      setLoading(true)\n\n      try {\n        // Gọi API để rời nhóm\n        const response = await apiCall(\"delete\", `/api/groups/${groupId}/leave`, undefined, token)\n        console.log(\"Leave group API response:\", response)\n\n        // Cập nhật UI sau khi API thành công\n        setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n\n        // Cập nhật localStorage\n        try {\n          const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n          const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n          localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n        } catch (e) {\n          console.error(\"Error updating localStorage after leaving group\", e)\n        }\n\n        // Bỏ chọn nhóm nếu đang được chọn\n        if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n          setSelectedContact(null)\n          setMessages([])\n          setMediaFiles([])\n          setDocuments([])\n        }\n\n        setShowGroupInfoModal(false) // Đóng modal\n        showError(\"Bạn đã rời khỏi nhóm thành công\")\n\n        // Thông báo qua socket nếu cần\n        if (socket.connected) {\n          socket.emit(\"left_group\", { groupId })\n        }\n      } catch (error) {\n        console.error(\"Error leaving group:\", error)\n        showError(\"Không thể rời khỏi nhóm: \" + error.message)\n      } finally {\n        setLoading(false)\n      }\n    },\n    [selectedContact, showError, apiCall],\n  )\n\n  const handleDeleteGroup = useCallback(\n    (groupId) => {\n      console.log(\"Deleting group:\", groupId)\n      setGroups((prev) => prev.filter((group) => group.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch (e) {\n        console.error(\"Error updating localStorage after deleting group\", e)\n      }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n      setShowGroupInfoModal(false) // Close modal\n      showError(\"Đã xóa nhóm thành công\")\n      // API call to delete group should be handled within GroupInfoModal or here before state update\n    },\n    [selectedContact, showError],\n  )\n\n  // --- Effects ---\n\n  // Initial Load: Token Check, User Profile, Contacts, Groups, Socket Init\n  useEffect(() => {\n    const token = localStorage.getItem(\"token\")\n    if (!token) {\n      navigate(\"/login\")\n      return\n    }\n\n    let isMounted = true // Flag to prevent state updates on unmounted component\n    let socketInitialized = false\n\n    const initializeApp = async () => {\n      try {\n        setLoading(true)\n        const userProfile = await fetchUserProfile(token)\n        if (!userProfile || !isMounted) return // Stop if fetch failed or component unmounted\n\n        // Fetch contacts and groups after getting user profile\n        await fetchContactsAndGroups(token)\n        if (!isMounted) return\n\n        // Fetch initial friend requests\n        await fetchFriendRequests(token)\n        if (!isMounted) return\n\n        // Initialize Socket only once\n        if (!socketInitialized && userProfile.userId && !socket.connected) {\n          console.log(\"Initializing socket connection...\")\n          \n          // Set socket auth and query params\n          socket.auth = { token }\n          socket.io.opts.query = {\n            userId: userProfile.userId,\n            timestamp: Date.now(),\n          }\n\n          // Connect the socket\n          socket.connect()\n          socketInitialized = true\n        }\n      } catch (error) {\n        console.error(\"Initialization error:\", error)\n      } finally {\n        if (isMounted) {\n          setLoading(false)\n        }\n      }\n    }\n\n    initializeApp()\n\n    // Cleanup function\n    return () => {\n      isMounted = false\n      // Don't disconnect socket on component unmount\n      // Just remove listeners if needed\n      socket.off(\"connect\")\n      socket.off(\"reconnect\")\n      socket.off(\"friend_request\")\n      socket.off(\"new_message\")\n      socket.off(\"receive_message\")\n      socket.off(\"group_message\")\n      socket.off(\"friend_request_accepted\")\n      socket.off(\"friend_removed\")\n      socket.off(\"refresh_contacts\")\n      socket.off(\"notification\")\n      socket.off(\"group_created\")\n      socket.off(\"group_updated\")\n      socket.off(\"group_deleted\")\n      socket.off(\"member_added\")\n      socket.off(\"member_removed\")\n    }\n  }, [navigate]) // Only depend on navigate\n\n  // Khi khởi tạo component, đọc cache từ localStorage\n  useEffect(() => {\n    // ... các logic khác\n    const cache = localStorage.getItem('cachedMessages')\n    if (cache) {\n      setCachedMessages(JSON.parse(cache))\n    }\n  }, [navigate])\n\n  // Define socket event handlers using useCallback\n  const handleNewMessage = useCallback((data) => {\n    console.log(\"Received new message event:\", data); // Log toàn bộ dữ liệu tin nhắn nhận được\n\n    if (!data || (!data.messageId && !data.id)) {\n      console.error(\"Invalid message data received:\", data)\n      return\n    }\n\n    const messageTime = data.createdAt\n      ? new Date(data.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n      : new Date().toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })\n    const messageDate = data.createdAt ? new Date(data.createdAt).toLocaleDateString() : new Date().toLocaleDateString()\n\n    console.log(\"Current selected contact:\", selectedContact); // Log thông tin contact đang được chọn\n    console.log(\"Message data:\", {\n      groupId: data.groupId,\n      conversationId: data.conversationId,\n      selectedContactType: selectedContact?.type,\n      selectedContactGroupId: selectedContact?.groupId,\n      selectedContactConversationId: selectedContact?.conversationId\n    });\n\n    const isCurrentChat =\n      (selectedContact?.type === \"group\" && selectedContact.groupId === data.groupId) ||\n      (selectedContact?.type === \"contact\" && selectedContact.conversationId === data.conversationId)\n\n    console.log(\"Is current chat:\", isCurrentChat); // Log kết quả kiểm tra isCurrentChat\n\n      const newMessage = {\n        id: data.messageId || data.id,\n      sender: data.senderId === user.id ? \"Me\" : data.senderName || \"Người khác\",\n        content:\n          data.isDeleted\n            ? \"Tin nhắn đã bị xóa\"\n            : data.isRecalled\n              ? \"Tin nhắn đã bị thu hồi/xóa\"\n              : data.type === \"text\" || data.type === \"emoji\" || data.type === \"system\"\n                ? data.content\n                : data.attachments?.[0]?.url || data.content || \"\",\n        time: messageTime,\n        senderId: data.senderId,\n        isImage: !data.isDeleted && (data.type === \"image\" || data.type === \"imageGroup\"),\n        isVideo: !data.isDeleted && data.type === \"video\",\n        isFile: !data.isDeleted && data.type === \"file\",\n      isUnsent: data.isRecalled || data.isDeleted,\n        isSystemMessage: data.isSystemMessage || data.senderId === \"system\",\n        fileUrl: !data.isDeleted && data.type === \"file\" ? data.attachments?.[0]?.url : null,\n        fileName: !data.isDeleted && data.type === \"file\" ? data.attachments?.[0]?.name : null,\n        fileType: !data.isDeleted && data.type === \"file\" ? data.attachments?.[0]?.type : null,\n        duration: !data.isDeleted && data.type === \"video\" ? data.attachments?.[0]?.duration || data.duration : null,\n        messageDate: messageDate,\n      }\n\n    // LUÔN LUÔN lưu vào cache theo conversationId, kể cả khi không phải chat đang mở\n    if (data.conversationId) {\n      setCachedMessages(prev => {\n        const prevList = prev[data.conversationId] || []\n        if (prevList.some(msg => msg.id === newMessage.id)) return prev\n        const updated = { ...prev, [data.conversationId]: [...prevList, newMessage] }\n        // Lưu vào localStorage\n        localStorage.setItem('cachedMessages', JSON.stringify(updated))\n        console.log('>>> Updated cachedMessages:', updated)\n        return updated\n      })\n    }\n\n    if (isCurrentChat) {\n      setMessages(prev => {\n        const exists = prev.some(msg => msg.id === newMessage.id)\n        if (exists) return prev\n        return [...prev, newMessage]\n      })\n      // Add to media/documents if it's a file/media\n      if ((newMessage.isImage || newMessage.isVideo) && newMessage.content) {\n        setMediaFiles((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.isImage ? \"image\" : \"video\",\n            url: newMessage.content,\n            name: newMessage.fileName || (newMessage.isImage ? \"image.jpg\" : \"video.mp4\"),\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n            duration: newMessage.duration,\n          },\n          ...prev, // Add to beginning\n        ])\n      } else if (newMessage.isFile && newMessage.fileUrl) {\n        setDocuments((prev) => [\n          {\n            id: newMessage.id,\n            type: newMessage.fileName?.split(\".\").pop().toLowerCase() || \"file\",\n            url: newMessage.fileUrl,\n            name: newMessage.fileName,\n            date: newMessage.messageDate,\n            size: data.attachments?.[0]?.size || 0,\n          },\n          ...prev, // Add to beginning\n        ])\n      }\n    } else {\n      // Notification for message in other chat\n      let senderName = \"Người dùng\"\n      let contactId = data.senderId // Default to senderId for contacts\n      let targetId = data.senderId; // Use senderId or groupId to find the item in the list\n      let isGroupMessage = !!data.groupId;\n\n      if (isGroupMessage) {\n        targetId = data.groupId; // If it's a group message, target the group\n        const group = groups.find((g) => g.groupId === data.groupId)\n        senderName = `${data.senderName || \"Ai đó\"} (${group?.name || \"Nhóm\"})`\n      } else {\n        const contact = contacts.find((c) => c.id === data.senderId) // Tìm contact dựa trên senderId\n        senderName = contact?.name || data.senderName || \"Ai đó\"\n        contactId = data.senderId; // Xác định contactId cho tin nhắn cá nhân\n      }\n\n      const preview =\n        data.type === \"text\"\n          ? data.content?.substring(0, 30) + (data.content?.length > 30 ? \"...\" : \"\")\n          : `[${data.type === \"image\" ? \"Hình ảnh\" : data.type === \"video\" ? \"Video\" : \"Tệp\"}]`\n      showError(`Tin nhắn mới từ ${senderName}: ${preview}`)\n\n      // Cập nhật số tin nhắn chưa đọc và tin nhắn cuối cùng trong danh sách liên hệ/nhóm\n      setContacts(prev => prev.map(item => {\n        // Tìm item (contact hoặc group) cần cập nhật\n        const itemIdToMatch = item.type === 'group' ? item.groupId : item.id;\n        if (itemIdToMatch === targetId) {\n          console.log(`Updating unread count and last message for ${item.type}: ${item.name || item.id}`);\n          // Cập nhật unreadCount và lastMessage\n          return {\n            ...item,\n            unreadCount: (item.unreadCount || 0) + 1,\n            lastMessage: {\n              content: data.type === \"text\" ? data.content : preview, // Use full content for text, preview for media/files\n              type: data.type,\n              senderId: data.senderId,\n              createdAt: data.createdAt || new Date().toISOString()\n            },\n            lastMessageAt: data.createdAt || new Date().toISOString()\n          };\n        }\n        return item;\n      }));\n\n      // Update groups list similarly if needed (currently handleNewMessage is for both based on data structure)\n      // Potentially refactor to handle contact and group updates separately for clarity if data structures diverge.\n\n      // Nếu chưa có chat nào đang mở, tự động mở chat với người gửi\n      if (!selectedContact && data.conversationId) {\n        // Tìm contact hoặc group tương ứng\n        let foundContact = contacts.find(\n          c => c.conversationId === data.conversationId || c.id === data.senderId\n        )\n        if (foundContact) {\n          setSelectedContact(foundContact)\n          // Hiển thị luôn tin nhắn cache\n          setMessages(cachedMessages[data.conversationId] || [])\n        }\n      }\n    }\n\n    // Browser notification\n    if (document.hidden && \"Notification\" in window && Notification.permission === \"granted\") {\n      const contactName = data.senderName || \"Người dùng\"\n      new Notification(contactName, {\n        body: data.type === \"text\" ? data.content : `Đã gửi một ${data.type}`,\n        icon: contacts.find((c) => c.id === data.senderId)?.avatar || groups.find(g => g.groupId === data.groupId)?.avatar || \"/favicon.ico\", // Optional icon\n      })\n    }\n  }, [user.id, contacts, groups, selectedContact, showError, cachedMessages])\n\n  const handleFriendRequest = useCallback((data) => {\n    if (!data || !data.requestId || !data.sender) return\n    // ... rest of handleFriendRequest implementation ...\n  }, [showError, fetchFriendRequests, setActiveTab])\n\n  const handleFriendRequestAccepted = useCallback((data) => {\n    if (!data) {\n      console.error(\"Invalid friend_request_accepted data: null\")\n      return\n    }\n    // ... rest of handleFriendRequestAccepted implementation ...\n  }, [showError, createOrGetConversation, addOrUpdateContact, user])\n\n  const handleFriendRemoved = useCallback((data) => {\n    if (!data || !data.removerId) return\n    // ... rest of handleFriendRemoved implementation ...\n  }, [contacts, selectedContact, showError])\n\n  const handleRefreshContacts = useCallback(() => {\n    const token = localStorage.getItem(\"token\")\n    if (token) {\n      fetchContactsAndGroups(token)\n    }\n  }, [fetchContactsAndGroups])\n\n  const handleSocketGroupCreated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_created event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.members?.length || 1,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    showError(`Bạn đã được thêm vào nhóm \"${group.name}\"`)\n  }, [addOrUpdateGroup, showError])\n\n  const handleSocketGroupUpdated = useCallback((data) => {\n    if (!data?.group) return\n    console.log(\"Received group_updated event:\", data.group)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n    showError(`Nhóm \"${group.name}\" đã được cập nhật`)\n  }, [addOrUpdateGroup, selectedContact, showError])\n\n  const handleGroupDeleted = useCallback((data) => {\n    if (!data?.groupId) return\n    console.log(\"Received group_deleted event:\", data.groupId)\n    const groupName = groups.find(g => g.groupId === data.groupId)?.name || \"Một nhóm\"\n    setGroups((prev) => prev.filter((group) => group.groupId !== data.groupId))\n    try {\n      const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n      const updatedGroups = savedGroups.filter((g) => g.groupId !== data.groupId)\n      localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n    } catch (e) { console.error(\"Error updating localStorage after group delete\", e) }\n\n    if (selectedContact?.id === data.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(null)\n      setMessages([])\n      setMediaFiles([])\n      setDocuments([])\n    }\n    showError(`Nhóm \"${groupName}\" đã bị xóa`)\n  }, [groups, selectedContact, showError])\n\n  const handleMemberAdded = useCallback((data) => {\n    if (!data?.group || !data?.member || !data?.addedBy) return\n    console.log(\"Received member_added event:\", data)\n    const group = data.group\n    const groupObject = {\n      groupId: group.groupId,\n      id: group.groupId,\n      name: group.name,\n      avatar: group.avatarUrl || \"\",\n      type: \"group\",\n      adminId: group.adminId,\n      memberCount: group.memberCount || group.members?.length || 0,\n      conversationId: group.conversationId || group.groupId,\n      createdAt: group.createdAt,\n    }\n    addOrUpdateGroup(groupObject)\n    if (data.member.userId !== user.id) {\n      showError(`${data.addedBy.fullName || 'Admin'} đã thêm ${data.member.fullName || 'thành viên mới'} vào nhóm \"${group.name}\"`)\n    }\n    if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n      setSelectedContact(groupObject)\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleMemberRemoved = useCallback((data) => {\n    if (!data?.group || !data?.memberId || !data?.removedBy) return\n    console.log(\"Received member_removed event:\", data)\n    const group = data.group\n    const groupId = group.groupId\n\n    if (data.memberId === user.id) {\n      showError(`Bạn đã bị xóa khỏi nhóm \"${group.name}\"`)\n      setGroups((prev) => prev.filter((g) => g.groupId !== groupId))\n      try {\n        const savedGroups = JSON.parse(localStorage.getItem(\"savedGroups\") || \"[]\")\n        const updatedGroups = savedGroups.filter((g) => g.groupId !== groupId)\n        localStorage.setItem(\"savedGroups\", JSON.stringify(updatedGroups))\n      } catch(e) { console.error(\"Error updating localStorage after being removed from group\", e) }\n      if (selectedContact?.id === groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(null)\n        setMessages([])\n        setMediaFiles([])\n        setDocuments([])\n      }\n    } else {\n      const groupObject = {\n        groupId: group.groupId,\n        id: group.groupId,\n        name: group.name,\n        avatar: group.avatarUrl || \"\",\n        type: \"group\",\n        adminId: group.adminId,\n        memberCount: group.memberCount || group.members?.length || 0,\n        conversationId: group.conversationId || group.groupId,\n        createdAt: group.createdAt,\n      }\n      addOrUpdateGroup(groupObject)\n      const memberName = data.member?.fullName || \"một thành viên\"\n      showError(`${data.removedBy.fullName || 'Admin'} đã xóa ${memberName} khỏi nhóm \"${group.name}\"`)\n      if (selectedContact?.id === group.groupId && selectedContact?.type === \"group\") {\n        setSelectedContact(groupObject)\n      }\n    }\n  }, [user.id, addOrUpdateGroup, selectedContact, showError])\n\n  const handleNotification = useCallback((data) => {\n    if (!data || !data.message) {\n      console.error(\"Invalid notification data:\", data)\n      return\n    }\n    if (data.type === \"success\") {\n      showError(data.message)\n    } else if (data.type === \"error\") {\n      showError(data.message, \"error\")\n    } else if (data.type === \"warning\") {\n      showError(data.message, \"warning\")\n    } else {\n      showError(data.message)\n    }\n    if (data.refreshContacts) {\n      const token = localStorage.getItem(\"token\")\n      if (token) {\n        fetchContactsAndGroups(token)\n      }\n    }\n  }, [showError, fetchContactsAndGroups])\n\n  // Socket Event Listeners Effect\n  useEffect(() => {\n    let isMounted = true\n\n    const handleConnect = () => {\n      if (!isMounted) return\n      console.log(\"Socket re-connected inside hook.\")\n      setIsConnected(true)\n      const userProfile = JSON.parse(localStorage.getItem(\"userProfile\") || \"{}\")\n      if (userProfile.userId) {\n        socket.emit(\"user_connected\", userProfile.userId)\n      }\n    }\n\n    // Add handler for message_sent event\n    const handleMessageSent = (data) => {\n      if (!data || !data.messageId) {\n        console.error(\"Invalid message_sent_success data:\", data)\n        return\n      }\n      console.log(\"Received message_sent_success event:\", data)\n\n      // Update the message status in messages list\n      setMessages(prevMessages => prevMessages.map(msg => {\n        // Check if this is the message we're looking for\n        if (msg.isSending && (\n          // Match by tempMessageId if available\n          (data.tempMessageId && msg.id === data.tempMessageId) ||\n          // Or match by conversationId and content if tempMessageId not available\n          (data.conversationId && msg.conversationId === data.conversationId && \n           msg.content === data.content)\n        )) {\n          console.log(\"Updating message status:\", {\n            oldId: msg.id,\n            newId: data.messageId,\n            content: msg.content\n          })\n          return {\n            ...msg,\n            id: data.messageId,\n            messageId: data.messageId,\n            isSending: false,\n            createdAt: data.createdAt || msg.createdAt\n          }\n        }\n        return msg\n      }))\n    }\n\n    // Add socket listeners only if socket is connected\n    socket.on(\"connect\", handleConnect)\n    socket.on(\"message_sent_success\", handleMessageSent) // Listen for message confirmation\n    socket.on(\"new_message\", handleNewMessage)\n    socket.on(\"receive_message\", handleNewMessage)\n    socket.on(\"group_message\", handleNewMessage)\n    socket.on(\"friend_request\", handleFriendRequest)\n    socket.on(\"friend_request_accepted\", handleFriendRequestAccepted)\n    socket.on(\"friend_removed\", handleFriendRemoved)\n    socket.on(\"refresh_contacts\", handleRefreshContacts)\n    socket.on(\"notification\", handleNotification)\n    socket.on(\"group_created\", handleSocketGroupCreated)\n    socket.on(\"group_updated\", handleSocketGroupUpdated)\n    socket.on(\"group_deleted\", handleGroupDeleted)\n    socket.on(\"member_added\", handleMemberAdded)\n    socket.on(\"member_removed\", handleMemberRemoved)\n    socket.on(\"message_reacted\", handleMessageReacted)\n\n    // Cleanup listeners on unmount or dependency change\n    return () => {\n      isMounted = false\n      socket.off(\"connect\", handleConnect)\n      socket.off(\"message_sent_success\", handleMessageSent) // Remove message_sent handler\n      socket.off(\"new_message\", handleNewMessage)\n      socket.off(\"receive_message\", handleNewMessage)\n      socket.off(\"group_message\", handleNewMessage)\n      socket.off(\"friend_request\", handleFriendRequest)\n      socket.off(\"friend_request_accepted\", handleFriendRequestAccepted)\n      socket.off(\"friend_removed\", handleFriendRemoved)\n      socket.off(\"refresh_contacts\", handleRefreshContacts)\n      socket.off(\"notification\", handleNotification)\n      socket.off(\"group_created\", handleSocketGroupCreated)\n      socket.off(\"group_updated\", handleSocketGroupUpdated)\n      socket.off(\"group_deleted\", handleGroupDeleted)\n      socket.off(\"member_added\", handleMemberAdded)\n      socket.off(\"member_removed\", handleMemberRemoved)\n      socket.off(\"message_reacted\", handleMessageReacted)\n    }\n  }, [\n    handleNewMessage,\n    handleFriendRequest,\n    handleFriendRequestAccepted,\n    handleFriendRemoved,\n    handleRefreshContacts,\n    handleNotification,\n    handleSocketGroupCreated,\n    handleSocketGroupUpdated,\n    handleGroupDeleted,\n    handleMemberAdded,\n    handleMemberRemoved,\n    selectedContact, // Add selectedContact as dependency\n    handleMessageReacted\n  ])\n\n  // Scroll to bottom effect\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages]) // Run whenever messages array changes\n\n  // Function to scroll messages\n  const scrollToBottom = () => {\n    // Add a slight delay to allow the DOM to update after new message added\n    setTimeout(() => {\n        messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\n    }, 100);\n  }\n\n  // ... existing code ...\n  useEffect(() => {\n    // ... các event khác ...\n    const handleMessageDeleted = (data) => {\n      setMessages((prev) =>\n        prev.map((msg) =>\n          msg.id === data.messageId\n            ? { ...msg, content: \"Tin nhắn đã bị xóa\", isUnsent: true }\n            : msg\n        )\n      )\n    }\n    socket.on(\"message_deleted\", handleMessageDeleted)\n    // ... cleanup ...\n    return () => {\n      socket.off(\"message_deleted\", handleMessageDeleted)\n      // ... cleanup các event khác ...\n    }\n  }, [setMessages])\n  // ... existing code ...\n\n  // --- Derived State ---\n  const filteredContacts = contacts.filter(\n    (contact) => contact.type === \"contact\" && contact.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n  const filteredGroups = groups.filter(\n    (group) => group.type === \"group\" && group.name.toLowerCase().includes(searchQuery.toLowerCase()),\n  )\n\n  const emojis = [\"😊\", \"😂\", \"❤️\", \"👍\", \"🎉\", \"🔥\", \"😎\", \"🙏\", \"💯\", \"🤔\"] // Keep emojis here or move to constants\n\n  // --- Return Values ---\n  return {\n    // State\n    user,\n    contacts, // Return full contacts list if needed elsewhere\n    groups,   // Return full groups list if needed elsewhere\n    selectedContact,\n    messages,\n    newMessage,\n    isConnected,\n    showEmojiPicker,\n    searchQuery,\n    mediaFiles,\n    documents,\n    showMedia,\n    showFiles,\n    activeTab,\n    showProfileModal,\n    profileData,\n    loading,\n    showAddFriendModal,\n    friendEmail,\n    error,\n    showToast,\n    friendRequests,\n    showCreateGroupModal,\n    showGroupInfoModal,\n    selectedGroup,\n\n    // Setters (Only expose necessary setters)\n    setNewMessage,\n    setShowEmojiPicker,\n    setSearchQuery,\n    // setShowMedia, // Handled by toggle functions\n    // setShowFiles, // Handled by toggle functions\n    setActiveTab, // Needed for friend request notification\n    setShowProfileModal, // Needed for closing modal from component\n    setProfileData, // Needed for form inputs\n    // setLoading, // Internal state\n    setShowAddFriendModal, // Needed for closing modal from component\n    setFriendEmail, // Needed for form input\n    // setError, // Internal state\n    setShowToast, // Needed for closing toast from component\n    // setFriendRequests, // Internal state\n    setShowCreateGroupModal, // Needed for closing modal from component\n    setShowGroupInfoModal, // Needed for closing modal from component\n    // setSelectedGroup, // Handled by handleGroupInfo\n\n    // Refs\n    messagesEndRef,\n    fileInputRef,\n    imageInputRef,\n    videoInputRef,\n\n    // Handlers\n    handleContactSelect,\n    handleSendMessage,\n    handleSendFile, // Consolidated file sending\n    handleEmojiSelect,\n    handleMessageAction,\n    toggleMediaView,\n    toggleFilesView,\n    handleTabChange,\n    handleProfileClick,\n    handleCloseProfileModal,\n    handleAvatarChange,\n    handleUpdateProfile,\n    handleAddFriend,\n    handleCloseAddFriendModal,\n    handleSubmitAddFriend,\n    handleRespondToFriendRequest,\n    handleRemoveFriend,\n    handleCreateGroup,\n    handleGroupCreated,\n    handleGroupInfo,\n    handleGroupUpdated,\n    handleLeaveGroup,\n    handleDeleteGroup,\n    showError, // Expose showError if needed externally\n\n    // Derived Data\n    filteredContacts,\n    filteredGroups,\n    emojis,\n    token: localStorage.getItem(\"token\"), // Pass token for Modals\n    reactionEmojis, // Trả về danh sách emoji\n\n    // Handlers\n    handleReactToMessage, // Trả về handler thả cảm xúc\n  }\n}\n\nexport default useChat\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}